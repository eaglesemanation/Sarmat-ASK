CREATE OR REPLACE FUNCTION obj_robot."DIR_CW"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 1;
END;
$BODY$;
ALTER FUNCTION obj_robot."DIR_CW"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."DIR_CW"() IS 'DIR: по часовой, от меньшего к большему';
CREATE OR REPLACE FUNCTION obj_robot."DIR_CCW"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_robot."DIR_CCW"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."DIR_CCW"() IS 'DIR: против часовой, от большего к меньшему';
CREATE OR REPLACE FUNCTION obj_robot."DIR_NONE"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_robot."DIR_NONE"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."DIR_NONE"() IS 'DIR: нет никакого направления';

CREATE OR REPLACE FUNCTION obj_robot."CMD_LOAD"(
    )
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 'LOAD';
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_LOAD"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_LOAD"() IS 'Символьные названия команд: LOAD';
CREATE OR REPLACE FUNCTION obj_robot."CMD_UNLOAD"(
    )
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 'UNLOAD';
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_UNLOAD"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_UNLOAD"() IS 'Символьные названия команд: UNLOAD';
CREATE OR REPLACE FUNCTION obj_robot."CMD_MOVE"(
    )
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 'MOVE';
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_MOVE"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_MOVE"() IS 'Символьные названия команд: MOVE';
CREATE OR REPLACE FUNCTION obj_robot."CMD_INITY"(
    )
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 'INITY';
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_INITY"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_INITY"() IS 'Символьные названия команд: INITY';

CREATE OR REPLACE FUNCTION obj_robot."CMD_LOAD_TYPE_ID"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 4;
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_LOAD_TYPE_ID"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_LOAD_TYPE_ID"() IS 'Числовой код команды: LOAD';
CREATE OR REPLACE FUNCTION obj_robot."CMD_UNLOAD_TYPE_ID"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 5;
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_UNLOAD_TYPE_ID"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_UNLOAD_TYPE_ID"() IS 'Числовой код команды: UNLOAD';
CREATE OR REPLACE FUNCTION obj_robot."CMD_MOVE_TYPE_ID"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 6;
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_MOVE_TYPE_ID"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_MOVE_TYPE_ID"() IS 'Числовой код команды: MOVE';
CREATE OR REPLACE FUNCTION obj_robot."CMD_INITY_TYPE_ID"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 32;
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_INITY_TYPE_ID"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_INITY_TYPE_ID"() IS 'Числовой код команды: INITY';

CREATE OR REPLACE FUNCTION obj_robot."ROBOT_STATE_READY"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_robot."ROBOT_STATE_READY"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."ROBOT_STATE_READY"() IS 'Состояние робота: готов';
CREATE OR REPLACE FUNCTION obj_robot."ROBOT_STATE_BUSY"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 1;
END;
$BODY$;
ALTER FUNCTION obj_robot."ROBOT_STATE_BUSY"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."ROBOT_STATE_BUSY"() IS 'Состояние робота: работает';
CREATE OR REPLACE FUNCTION obj_robot."ROBOT_STATE_ERROR"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 2;
END;
$BODY$;
ALTER FUNCTION obj_robot."ROBOT_STATE_ERROR"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."ROBOT_STATE_ERROR"() IS 'Состояние робота: в ошибке';
CREATE OR REPLACE FUNCTION obj_robot."ROBOT_STATE_INIT"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 3;
END;
$BODY$;
ALTER FUNCTION obj_robot."ROBOT_STATE_INIT"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."ROBOT_STATE_INIT"() IS 'Состояние робота: в режиме инициализации';
CREATE OR REPLACE FUNCTION obj_robot."ROBOT_STATE_REPAIR"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 6;
END;
$BODY$;
ALTER FUNCTION obj_robot."ROBOT_STATE_REPAIR"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."ROBOT_STATE_REPAIR"() IS 'Состояние робота: в починке';
CREATE OR REPLACE FUNCTION obj_robot."ROBOT_STATE_DISCONNECT"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 8;
END;
$BODY$;
ALTER FUNCTION obj_robot."ROBOT_STATE_DISCONNECT"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."ROBOT_STATE_DISCONNECT"() IS 'Состояние робота: нет связи';

CREATE OR REPLACE FUNCTION obj_robot."PR_UNLOAD_RETRY"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 5;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_UNLOAD_RETRY"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_UNLOAD_RETRY"() IS 'Варианты решения проблемы: повторить команду UNLOAD';
CREATE OR REPLACE FUNCTION obj_robot."PR_UNLOAD_HANDLE"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 6;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_UNLOAD_HANDLE"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_UNLOAD_HANDLE"() IS 'Варианты решения проблемы: UNLOAD выполнена вручную';
CREATE OR REPLACE FUNCTION obj_robot."PR_UNLOAD_MARK_BAD_REDIRECT"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 14;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_UNLOAD_MARK_BAD_REDIRECT"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_UNLOAD_MARK_BAD_REDIRECT"() IS 'Варианты решения проблемы: UNLOAD - пометить целевую ячейку как плохую и перенаправить контейнер в другую ячейку';
CREATE OR REPLACE FUNCTION obj_robot."PR_UNLOAD_INDICATE_REDIRECT"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 15;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_UNLOAD_INDICATE_REDIRECT"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_UNLOAD_INDICATE_REDIRECT"() IS 'Варианты решения проблемы: UNLOAD - Указать какой контейнер находится в ячейке и перенаправить текущий контейнер в другую ячейку';
CREATE OR REPLACE FUNCTION obj_robot."PR_LOAD_RETRY"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 1;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_LOAD_RETRY"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_LOAD_RETRY"() IS 'Варианты решения проблемы: повторить LOAD';
CREATE OR REPLACE FUNCTION obj_robot."PR_LOAD_HANDLE"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 2;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_LOAD_HANDLE"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_LOAD_HANDLE"() IS 'Варианты решения проблемы: LOAD выполнена вручную';
CREATE OR REPLACE FUNCTION obj_robot."PR_LOAD_CELL_EMPTY"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 16;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_LOAD_CELL_EMPTY"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_LOAD_CELL_EMPTY"() IS 'Варианты решения проблемы: LOAD - целевая ячейка пуста';
CREATE OR REPLACE FUNCTION obj_robot."PR_LOAD_CELL_BAD"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 18;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_LOAD_CELL_BAD"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_LOAD_CELL_BAD"() IS 'Варианты решения проблемы: LOAD - Контейнер в целевой ячейке заклинило';


CREATE OR REPLACE FUNCTION obj_robot.get_log_file_name(
    robot_id_ numeric)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 'robot_ora_' || robot_id_ || '_'
        || to_char(LOCALTIMESTAMP,'ddmmyy') || '.log';
END;
$BODY$;
ALTER FUNCTION obj_robot.get_log_file_name(numeric) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_log_file_name(numeric)
    IS 'Generates log name based on robot id and date.
получить имя файла лога';


CREATE OR REPLACE PROCEDURE obj_robot.log(
    robot_id_ bigint,
    txt_ text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    filename TEXT;
BEGIN
    filename := obj_robot.get_log_file_name(robot_id_);
    PERFORM pg_catalog.pg_file_write(
        filename,
        to_char(LOCALTIMESTAMP,'HH24:MI:SS.MS') || ' ' || txt_ || E'\n',
        true
    );
END;
$BODY$;
COMMENT ON PROCEDURE obj_robot.log(bigint, text)
    IS 'Adds timestamped entry into log for specified robot
процедура ведения журнала';


CREATE OR REPLACE FUNCTION obj_robot.is_robot_ready_for_cmd(
    rid_ bigint,
    not_connected_is_ready_ boolean DEFAULT false)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    ncir BIGINT;
    rr robot;
BEGIN
    ncir := 0;
    IF not_connected_is_ready_ THEN
        ncir := 1;
    END IF;
    FOR rr in (
        SELECT *
            FROM robot
            WHERE id = rid_
                AND ((state = 0) OR (ncir = 1 AND state IN (0,8)))
                AND is_present = 1
                AND coalesce(command_rp_id, 0) = 0
                AND coalesce(command_inner_assigned_id, 0) = 0
                AND coalesce(command_inner_id, 0) = 0
                AND coalesce(wait_for_problem_resolve, 0) = 0
    ) LOOP
        RETURN 1;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_robot.is_robot_ready_for_cmd(bigint, boolean) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.is_robot_ready_for_cmd(bigint, boolean)
    IS 'робот готов для команд перемещения контейнера?';


CREATE OR REPLACE FUNCTION obj_robot.is_robot_ready_for_cmd_inner(
    rid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr robot;
BEGIN
    FOR rr IN (
        SELECT *
            FROM robot
            WHERE id = rid_
                AND state = 0
                AND is_present = 1
                AND coalesce(command_inner_assigned_id, 0) = 0
                AND coalesce(command_inner_id, 0) = 0
                AND coalesce(wait_for_problem_resolve, 0) = 0
    ) LOOP
        RETURN 1;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_robot.is_robot_ready_for_cmd_inner(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.is_robot_ready_for_cmd_inner(bigint)
    IS 'робот готов для подкоманд перемещения контейнера (load/unload)?';


CREATE OR REPLACE FUNCTION obj_robot.get_ci_cnt_bc(
    rid_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr robot;
    crp command_rp;
    cc container;
BEGIN
    FOR rr IN (
        SELECT * FROM robot WHERE id = rid_
    ) LOOP
        FOR crp IN (
            SELECT * FROM command_rp WHERE id = rr.command_rp_id
        ) LOOP
            FOR cc IN (
                SELECT * FROM container WHERE id = crp.container_id
            ) LOOP
                RETURN cc.barcode;
            END LOOP;
        END LOOP;
    END LOOP;
    RETURN '';
END;
$BODY$;
ALTER FUNCTION obj_robot.get_ci_cnt_bc(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_ci_cnt_bc(bigint)
    IS 'взять ШК контейнера команды перемещения контейнера по id роботу';


CREATE OR REPLACE FUNCTION obj_robot.get_ci_cell_src(
    rid_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr robot;
    ci command_inner;
    cc cell;
BEGIN
    FOR rr IN (
        SELECT * FROM robot WHERE id = rid_
    ) LOOP
        FOR ci IN (
            SELECT * FROM command_inner WHERE id = rr.command_inner_id
        ) LOOP
            FOR cc IN (
                SELECT * FROM cell WHERE id = ci.cell_src_id
            ) LOOP
                RETURN cc.sname;
            END LOOP;
        END LOOP;
    END LOOP;
    RETURN '';
END;
$BODY$;
ALTER FUNCTION obj_robot.get_ci_cell_src(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_ci_cell_src(bigint)
    IS 'взять имя ячейки источника команды робота по id роботу';


CREATE OR REPLACE FUNCTION obj_robot.get_ci_cell_dst(
    rid_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr robot;
    ci command_inner;
    crp command_rp;
    cc cell;
BEGIN
    FOR rr IN (
        SELECT * FROM robot WHERE id = rid_
    ) LOOP
        FOR ci IN (
            SELECT * FROM command_inner WHERE id = rr.command_inner_id
        ) LOOP
            FOR crp IN (
                SELECT * FROM command_rp WHERE id = ci.command_rp_id
            ) LOOP
                FOR cc IN (
                    SELECT * FROM cell WHERE id = crp.cell_dest_id
                ) LOOP
                    RETURN cc.sname;
                END LOOP;
            END LOOP;
        END LOOP;
    END LOOP;
    RETURN '';
END;
$BODY$;
ALTER FUNCTION obj_robot.get_ci_cell_dst(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_ci_cell_dst(bigint)
    IS 'взять имя ячейки назначения команды робота по id роботу';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_cell_src(
    rid_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr RECORD;
BEGIN
    FOR rr IN (
        SELECT /*+RULE*/ crp.cell_src_sname
            FROM robot r
            INNER JOIN command_rp crp
                ON coalesce(r.command_rp_id, 0) = crp.id
            WHERE r.id = rid_
    ) LOOP
        RETURN rr.cell_src_sname;
    END LOOP;
    RETURN '';
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_cell_src(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_cell_src(bigint)
    IS 'получить имя ячейки-источника для команды перемещения контейнера по ID робота';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_cell_dest(
    rid_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr RECORD;
BEGIN
    FOR rr IN (
        SELECT /*+RULE*/  crp.cell_dest_sname
            FROM robot r
            INNER JOIN command_rp crp
                ON coalesce(r.command_rp_id, 0) = crp.id
            WHERE r.id = rid_
    ) LOOP
        RETURN rr.cell_dest_sname;
    END LOOP;
    RETURN '';
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_cell_dest(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_cell_dest(bigint)
    IS 'получить имя ячейки назначения для команды перемещения контейнера по ID робота';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_container(
    rid_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr RECORD;
BEGIN
    FOR rr IN (
        SELECT /*+RULE*/ cnt.barcode
            FROM robot r
            INNER JOIN command_rp crp
                ON coalesce(r.command_rp_id, 0) = crp.id
            INNER JOIN container cnt
                ON crp.container_id = cnt.id
            WHERE r.id = rid_
    ) LOOP
        RETURN rr.barcode;
    END LOOP;
    RETURN '';
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_container(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_container(bigint)
    IS 'получить ШК контейнера команды перемещения контейнера по ID робота';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_dir(
    rid_ bigint,
    nnm_ bigint DEFAULT 1)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr RECORD;
BEGIN
    FOR rr IN (
        SELECT /*+RULE*/ crp.direction_1, crp.direction_2
            FROM robot r
            INNER JOIN command_rp crp
                ON coalesce(r.command_rp_id,0) = crp.id
            WHERE r.id = rid_
    ) LOOP
        IF (nnm_ = 1) THEN
            RETURN rr.direction_1;
        ELSE
            RETURN rr.direction_2;
        END IF;
    END LOOP;
    RETURN null;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_dir(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_dir(bigint, bigint)
    IS 'получить направление команды перемещения контейнера по ID робота (доп. параметр - часть команды)';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_inner_checkpoint(
    cmd_inner_id_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    new_id_ BIGINT;
    last_sended_ DATE;
    ci command_inner;
    ls_ RECORD;
    rr robot;
    chp command_inner_checkpoint;
BEGIN
    FOR ci IN (
        SELECT *
            FROM command_inner
            WHERE id = cmd_inner_id_
                AND (LOCALTIMESTAMP - coalesce(date_time_begin, LOCALTIMESTAMP)) > INTERVAL '5 seconds'
    ) LOOP -- чтоб после начала слало только
        last_sended_ := LOCALTIMESTAMP - INTERVAL '1 day';
        FOR ls_ IN (
            SELECT date_time_sended
                FROM command_inner_checkpoint
                WHERE cmd_inner_id_ = command_inner_id
                    AND date_time_sended IS NOT null
                ORDER BY date_time_sended DESC
        ) LOOP
            last_sended_ := ls_.date_time_sended;
            EXIT;
        END LOOP;
        IF (
            LOCALTIMESTAMP - last_sended_ <= INTERVAL '3 seconds'
        ) THEN -- еще слишком мало прошло времени с последней подачи команды промежуточной
            RAISE NOTICE 'Слишком рано %', to_char(last_sended_,'dd.mm.yy hh24:mi:ss');
            RETURN '-1';
        END IF;
        FOR rr IN (
            SELECT *
                FROM robot
                WHERE id = ci.robot_id
                    AND coalesce(wait_for_problem_resolve, 0) = 0
                    AND state = 1
        ) LOOP -- только для работающего робота не в состоянии ошибки
            FOR chp IN (
                SELECT *
                    FROM command_inner_checkpoint
                    WHERE cmd_inner_id_ = command_inner_id
                        AND status < 3
                    ORDER BY id DESC
            ) LOOP
                IF (chp.npp = obj_robot.get_cmd_inner_npp_dest(cmd_inner_id_)) THEN
                    IF coalesce(chp.gv_ci_id, 0) > 0 THEN
                        new_id_ := chp.gv_ci_id;
                        --update command_inner_checkpoint set DATE_TIME_SENDED=sysdate where id=chp.id;
                    ELSE
                        new_id_ := nextval('seq_command_inner');
                        UPDATE command_inner_checkpoint
                            SET gv_ci_id = new_id_ /*, DATE_TIME_SENDED=sysdate */
                            WHERE id = chp.id;
                    END IF;
                    COMMIT;
                    RETURN new_id_ || ';-1'; -- уже достигли конечной точки, передает необходимость delete checkpoint
                ELSE
                    IF coalesce(chp.gv_ci_id, 0) > 0 THEN
                        new_id_ := chp.gv_ci_id;
                        --update command_inner_checkpoint set DATE_TIME_SENDED=sysdate where id=chp.id;
                    ELSE
                        new_id_ := nextval('seq_command_inner');
                        UPDATE command_inner_checkpoint
                            SET gv_ci_id = new_id_/*, DATE_TIME_SENDED=sysdate */
                            WHERE id = chp.id;
                    END IF;
                    COMMIT;
                    RETURN new_id_ || ';' || chp.npp;
                END IF;
            END LOOP;
        END LOOP;
    END LOOP;
    RETURN '-1';
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_inner_checkpoint(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_inner_checkpoint(bigint)
    IS 'возвращает ID и NPP промежуточной точки команды, или -1 если нет такой - для сервера штабелров для команды checkpoint';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_inner_cp_process(
    cmd_inner_id_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    res_ TEXT;
    tmp_ BIGINT;
    cc command_inner;
    rr robot;
    chp command_inner_checkpoint;
BEGIN
    res_ := '';
    FOR cc IN (
        SELECT *
            FROM command_inner
            WHERE id = cmd_inner_id_
    ) LOOP
        FOR rr IN (
            SELECT *
                FROM robot
                WHERE id = cc.robot_id
                    AND is_use_checkpoint = 1
        ) LOOP
            tmp_ := null;
            FOR chp IN (
                SELECT *
                    FROM command_inner_checkpoint
                    WHERE cmd_inner_id_ = command_inner_id
                    ORDER BY id DESC
            ) LOOP
                tmp_ := chp.npp;
                EXIT;
            END LOOP;
            IF (tmp_ IS null) THEN
                RETURN '-';
            ELSE
                res_ := tmp_ || '/';
                tmp_ := null;
                FOR chp IN (
                    SELECT *
                        FROM command_inner_checkpoint
                        WHERE cmd_inner_id_ = command_inner_id
                            AND status = 3
                        ORDER BY id DESC
                ) LOOP
                    tmp_ := chp.npp;
                    EXIT;
                END LOOP;
                IF (tmp_ IS null) THEN
                    RETURN res_ || '-';
                ELSE
                    RETURN res_ || tmp_;
                END IF;
            END IF;
        END LOOP;
    END LOOP;
    RETURN res_;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_inner_cp_process(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_inner_cp_process(bigint)
    IS 'возвращает строку лога работы с промежуточными точками по команде';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_inner_dtb(
    cid_ bigint)
    RETURNS date
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    ci__ command_inner;
BEGIN
    FOR ci__ IN (
        SELECT *
            FROM command_inner
            WHERE id = cid_
    ) LOOP
        RETURN ci__.date_time_begin;
    END LOOP;
    RETURN null;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_inner_dtb(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_inner_dtb(bigint)
    IS 'получить дату-время начала команды робота по ID';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_inner_imi_type(
    cid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    cp_npp_ BIGINT;
    dest_ BIGINT;
    ci command_inner;
BEGIN
    FOR ci IN (
        SELECT *
            FROM command_inner
            WHERE id = cid_
    ) LOOP
        IF (ci.command_type_id = obj_robot."CMD_MOVE_TYPE_ID"()) THEN
            RETURN ci.command_type_id;
        ELSIF (ci.check_point IS null) THEN
            RETURN ci.command_type_id;
        ELSE
            cp_npp_ := obj_robot.get_cmd_inner_last_checkpoint(cid_);
            dest_ := obj_robot.get_cmd_inner_npp_dest(cid_);
            IF (cp_npp_ = dest_) THEN
                RETURN ci.command_type_id;
            ELSE
                RETURN obj_robot."CMD_MOVE_TYPE_ID"();
            END IF;
        END IF;
    END LOOP;
    RETURN null;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_inner_imi_type(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_inner_imi_type(bigint)
    IS 'получить тип команда для имитационного моделирования (с учетом перемещений попромежуточным точкам)';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_inner_last_checkpoint(
    IN cmd_inner_id_ bigint,
    IN in_status_ bigint DEFAULT null)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    ci command_inner;
    chp command_inner_checkpoint;
BEGIN
    FOR ci IN (
        SELECT *
            FROM command_inner
            WHERE id = cmd_inner_id_
                AND check_point IS NOT null
    ) LOOP
        FOR chp IN (
            SELECT *
                FROM command_inner_checkpoint
                WHERE cmd_inner_id_ = command_inner_id
                    AND status = coalesce(in_status_, status)
                ORDER BY id DESC
        ) LOOP
            RETURN chp.npp;
        END LOOP;
        RETURN ci.check_point;
    END LOOP;
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_inner_last_checkpoint(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_inner_last_checkpoint(bigint, bigint)
    IS 'возвращает NPP последней промежуточной точки команды, или -1 если нет такой';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_inner_npp_dest(
    IN cid_ bigint,
    IN is_use_cp_ bigint DEFAULT 0)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    res_ BIGINT;
    ci__ command_inner;
    chp command_inner_checkpoint;
BEGIN
    FOR ci__ IN (
        SELECT *
            FROM command_inner
            WHERE id = cid_
    ) LOOP
        IF (is_use_cp_ = 1)
            AND (ci__.check_point IS NOT null)
        THEN -- есть промежуточные точки
            res_ := ci__.check_point;
            FOR chp IN (
                SELECT *
                    FROM command_inner_checkpoint
                    WHERE command_inner_id = cid_
                    ORDER BY id DESC
            ) LOOP
                res_ := chp.npp;
                EXIT;
            END LOOP;
            RETURN res_;
        ELSE
            IF (ci__.command_type_id = obj_robot."CMD_LOAD_TYPE_ID"()) THEN
                RETURN ci__.npp_src;
            ELSE
                RETURN ci__.npp_dest;
            END IF;
        END IF;
    END LOOP;
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_inner_npp_dest(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_inner_npp_dest(bigint, bigint)
    IS 'получить № целевого трека команды робота';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_inner_time_work(
    cid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    delta__ INTERVAL;
    max_d__ INTERVAL;
    ci__ command_inner;
BEGIN
    max_d__ := INTERVAL '6 minutes';
    FOR ci__ IN (
        SELECT *
            FROM command_inner
            WHERE id = cid_
    ) LOOP
        delta__ := LOCALTIMESTAMP - coalesce(ci__.date_time_begin, ci__.date_time_create);
        IF (delta__ >= max_d__) THEN
            RETURN extract(epoch FROM max_d__);
        ELSE
            RETURN extract(epoch FROM delta__);
        END IF;
    END LOOP;
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_inner_time_work(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_inner_time_work(bigint)
    IS 'получить сколько времени в секундах уже работает команда работа (но не более 6 минут)';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_inner_txt(
    rid_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr RECORD;
BEGIN
    FOR rr IN (
        SELECT /*+RULE*/ ci.command_to_run
            FROM robot r
            INNER JOIN command_inner ci
                ON coalesce(r.command_inner_id, 0) = ci.id
            WHERE r.id = rid_
    ) LOOP
        RETURN rr.command_to_run;
    END LOOP;
    RETURN '';
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_inner_txt(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_inner_txt(bigint)
    IS 'получить текст команды робота по ID робота';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_inner_type(
    rid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr RECORD;
BEGIN
    FOR rr IN (
        SELECT /*+RULE*/ ci.command_type_id
            FROM robot r
            INNER JOIN command_inner ci
                ON coalesce(r.command_inner_id, 0) = ci.id
            WHERE r.id = rid_
    ) LOOP
        RETURN rr.command_type_id;
    END LOOP;
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_inner_type(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_inner_type(bigint)
    IS 'получить тип команды робота по ID робота';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_robot_name(
    cmd_id_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr RECORD;
BEGIN
    FOR rr IN (
        SELECT r.name
            FROM command_rp crp
            INNER JOIN robot r
                ON crp.robot_id = r.id
            WHERE command_id = cmd_id_
            ORDER BY crp.id DESC
    ) LOOP
        RETURN rr.name;
    END LOOP;
    RETURN '';
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_robot_name(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_robot_name(bigint)
    IS 'возвращает робота, который делал команду перемещения контейнеров';


CREATE FUNCTION obj_robot.get_cmd_text_another_dir(IN ct text)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    res TEXT;
BEGIN
    IF position('CCW' IN ct) > 0 THEN
        res := replace(ct, 'CCW', '');
    ELSE
        res := replace(ct, ';;', ';CCW;');
    END IF;
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_text_another_dir(text) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_text_another_dir(text)
    IS 'возвращает текст команды робота с иным направлением движения по/против часовой стрелке';


CREATE FUNCTION obj_robot.get_cmd_text_new_cp(
    IN ct_ text,
    IN new_cp_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    lp_ BIGINT;
    ncitext TEXT;
BEGIN
    ncitext := obj_robot.get_cmd_text_wo_cp(ct_); -- убрали, если было
    lp_ := position(';' IN ncitext);
    IF (new_cp_ IS null) THEN
        RAISE EXCEPTION 'Нельзя менять промежуточную секцию на пустоту!'
            USING errcode = 50003;
    END IF;
    IF (lp_ > 0) THEN -- есть ;
        -- FIXME: Casting from BIGINT to INT, possible data loss
        RETURN trim(substring(ncitext FROM 1 FOR lp_::int - 1)) || ' cp=' || new_cp_ || substring(ncitext FROM lp_::int);
    ELSE -- нет ';', просто лупим в конец
        RETURN ncitext || ' cp=' || new_cp_;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_text_new_cp(text, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_text_new_cp(text, bigint)
    IS 'заменяет ''cp=NNN'' в тексте команды на другую секцию';


CREATE FUNCTION obj_robot.get_cmd_text_wo_cp(IN ct_ text)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    lp_ BIGINT;
    sc_ BIGINT;
    ncitext TEXT;
BEGIN
    ncitext := ct_;
    lp_ := position('cp' IN ncitext);
    IF (lp_ > 0) THEN
        sc_ := position(';' IN ncitext);
        IF (sc_ <= 0) THEN
            -- FIXME: Casting from BIGINT to INT, possible data loss
            RETURN trim(substring(ncitext FROM 1 FOR lp_::int - 1));
        ELSE
            RETURN trim(substring(ncitext FROM 1 FOR lp_::int - 1)) || substring(ncitext FROM sc_::int);
        END IF;
    ELSE -- и так нет
        RETURN ncitext;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_text_wo_cp(text) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_text_wo_cp(text)
    IS 'исключает ''cp=NNN'' из текста команды';


CREATE FUNCTION obj_robot.get_robot_name(
    rid_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr RECORD;
BEGIN
    FOR rr IN (
        SELECT r.name, r.port, rp.name rpname
            FROM robot r
            INNER JOIN repository_part rp
                ON r.repository_part_id = rp.id
            WHERE r.id = rid_
    ) LOOP
        RETURN rr.rpname || ':' || rr.name || ':' || rr.port;
    END LOOP;
    RETURN '';
END;
$BODY$;
ALTER FUNCTION obj_robot.get_robot_name(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_robot_name(bigint)
    IS 'получить имя робота по его ID для отчета';


CREATE FUNCTION obj_robot.get_robot_rp_id(
    rid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr robot;
BEGIN
    FOR rr IN (
        SELECT *
            FROM robot
            WHERE id = rid_
    ) LOOP
        RETURN rr.repository_part_id;
    END LOOP;
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_robot_rp_id(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_robot_rp_id(bigint)
    IS 'получить подсклад робота по его ID';


CREATE FUNCTION obj_robot.get_robot_rp_name(
    rid_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr RECORD;
BEGIN
    FOR rr IN (
        SELECT rp.name
            FROM robot r
            INNER JOIN repository_part rp
                ON r.repository_part_id = rp.id
            WHERE r.id = rid_
    ) LOOP
        RETURN rr.name;
    END LOOP;
    RETURN '';
END;
$BODY$;
ALTER FUNCTION obj_robot.get_robot_rp_name(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_robot_rp_name(bigint)
    IS 'получить имя подсклада робота по ID робота';


CREATE FUNCTION obj_robot.get_robot_state(
    rid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr robot;
BEGIN
    FOR rr IN (
        SELECT *
            FROM robot
            WHERE id = rid_
    ) LOOP
        RETURN rr.state;
    END LOOP;
    RETURN null;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_robot_state(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_robot_state(bigint)
    IS 'получить состояние робота по его ID';


CREATE FUNCTION obj_robot.get_problem_resolve_text(
    comp_name_ text)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    ci_id_ BIGINT;
    cc RECORD;
    pr problem_resolving;
BEGIN
    ci_id_ := obj_robot.get_last_comp_ci(comp_name_);
    IF (ci_id_ > 0) THEN
        FOR cc IN (
            SELECT ci.*, r.platform_busy
                FROM command_inner ci
                INNER JOIN robot r
                    ON r.id = ci.robot_id
                WHERE ci.id = ci_id_
                    AND ci.state NOT IN (2,5)
                ORDER BY ci.id DESC
        ) LOOP
            FOR pr IN (
                SELECT *
                    FROM problem_resolving
                    WHERE command_type_id = cc.command_type_id
                        AND (
                            platform_busy IS null
                            OR
                            coalesce(platform_busy, -1) = cc.platform_busy
                        )
            ) LOOP
                RETURN pr.text;
            END LOOP;
            EXIT;
        END LOOP;
    END IF;
    RETURN '';
END;
$BODY$;
ALTER FUNCTION obj_robot.get_problem_resolve_text(text) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_problem_resolve_text(text)
    IS 'берем простой вариант запроса для решения проблемы (Да/нет), чтобы потом задать его оператору';


CREATE OR REPLACE PROCEDURE obj_robot.set_command_inner(
    robot_id_ bigint,
    crp_id_ bigint,
    new_cmd_state_ bigint,
    cmd_inner_type_ bigint,
    dir_ bigint,
    cell_src_sname_ text,
    cell_dest_sname_ text,
    cmd_text_ text,
    container_id_ bigint DEFAULT 0,
    check_point_ bigint DEFAULT NULL::bigint)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rob_rec__ RECORD;
    ci_rec__ command_inner;
    cc BOOLEAN;
    ciid__ BIGINT;
    cnt__ BIGINT;
    errmm__ TEXT;
    -- lpfix__ TEXT;
    rp_id__ BIGINT;
    nomr__ BIGINT;
    npp_rd__ BIGINT;
BEGIN
    SELECT * INTO rob_rec__ FROM robot WHERE id = robot_id_;
    rp_id__ := rob_rec__.repository_part_id;
    SELECT num_of_robots INTO nomr__ FROM repository_part WHERE id = rp_id__;
    CALL obj_robot.log(robot_id_, 'set_command_inner: robot_id_=' || robot_id_
                                    || '; crp_id_=' || crp_id_
                                    || '; new_cmd_state=' || new_cmd_state_
                                    || '; cmd_inner_type=' || cmd_inner_type_
                                    || '; dir=' || dir_
                                    || '; cell_src_sname_=' || cell_src_sname_
                                    || '; cell_dest_sname_=' || cell_dest_sname_
                                    || '; cmd_text=' || cmd_text_);
    SELECT count(*) INTO cnt__ FROM command_inner WHERE robot_id = robot_id_ AND state = 3;
    IF (cnt__ <> 0) THEN
        errmm__ := 'ERROR постановки команды - назначается новая, а есть еще старая ';
        CALL obj_robot.log(robot_id_, errmm__);
        RAISE EXCEPTION '%', errmm__ USING errcode = 50003;
    END IF;
    IF (rob_rec__.state <> 0) THEN
        errmm__ := 'ERROR постановки команды для робота ' || robot_id_ || ' - робот занят!';
        CALL obj_robot.log(robot_id_, errmm__);
        RAISE EXCEPTION '%', errmm__ USING errcode = 50012;
    END IF;
    IF (coalesce(rob_rec__.command_inner_assigned_id, 0) <> 0) THEN
        errmm__ := 'ERROR постановки команды для робота ' || robot_id_ ||
            ' - уже закреплена но не запущена команда ' || rob_rec__.command_inner_assigned_id;
        CALL obj_robot.log(robot_id_, errmm__);
        RAISE EXCEPTION '%', errmm__ USING errcode = 50012;
    END IF;
    IF (cell_src_sname_ IS NULL) AND (cell_dest_sname_ IS NULL) THEN
        errmm__ := 'ERROR постановки команды для робота ' || robot_id_ || ' - пустые и источник и приемник!';
        CALL obj_robot.log(robot_id_, errmm__);
        RAISE EXCEPTION '%', errmm__ USING errcode = 50012;
    END IF;
    rob_rec__.state := 1;
    ci_rec__.command_type_id := cmd_inner_type_;
    ci_rec__.direction := dir_;
    IF (cell_src_sname_ IS NOT NULL) THEN
        SELECT c.id, t.npp, t.id
            INTO ci_rec__.cell_src_id, ci_rec__.npp_src, ci_rec__.track_src_id
            FROM cell c
            INNER JOIN shelving s
                ON c.shelving_id = s.id
            INNER JOIN track t
                ON s.track_id = t.id
            WHERE c.sname = cell_src_sname_
                AND t.repository_part_id = rob_rec__.repository_part_id;
    ELSE
        ci_rec__.cell_src_id := 0;
        ci_rec__.npp_src := 0;
        ci_rec__.track_src_id := 0;
    END IF;
    IF (cell_dest_sname_ IS NOT NULL) THEN
        SELECT c.id, t.npp, t.id
        INTO ci_rec__.cell_dest_id, ci_rec__.npp_dest, ci_rec__.track_dest_id
        FROM cell c
        INNER JOIN shelving s
            ON c.shelving_id = s.id
        INNER JOIN track t
            ON s.track_id = t.id
        WHERE c.sname = cell_dest_sname_
            AND t.repository_part_id = rob_rec__.repository_part_id;
    ELSE
        ci_rec__.cell_dest_id := 0;
        ci_rec__.npp_dest := 0;
        ci_rec__.track_dest_id := 0;
    END IF;
    -- проверка на занятость плафтормы
    IF (cmd_inner_type_ IN (5)) THEN -- unload
        IF (rob_rec__.platform_busy = 0) THEN
            UPDATE robot SET wait_for_problem_resolve = 1 WHERE id = robot_id_;
            errmm__ := '  ERROR for robot=' || robot_id_ || ' rob_rec.platform_busy=0';
            CALL obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT"(), rp_id__, robot_id_, errmm__);
            CALL obj_robot.log(robot_id_, errmm__);
            RETURN;
            --raise_application_error (-20012, 'Неовзможно дать команду unload при пустой плафторме');
        END IF;
    ELSIF (cmd_inner_type_ IN (4)) THEN -- load
        IF (rob_rec__.platform_busy = 1) THEN
            UPDATE robot SET wait_for_problem_resolve = 1 WHERE id = robot_id_;
            errmm__ := '  ERROR for robot=' || robot_id_ || ' rob_rec.platform_busy=1';
            CALL obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT"(), rp_id__, robot_id_, errmm__);
            CALL obj_robot.log(robot_id_, errmm__);
            RETURN;
        END IF;
    END IF;
    IF (nomr__ > 1) THEN -- проверяем, а заблокирован ли трек до цели в случае > 1-го робота
        IF (cmd_inner_type_ IN (5,6)) THEN
            npp_rd__ := ci_rec__.npp_dest;
        ELSE
            npp_rd__ := ci_rec__.npp_src;
        END IF;
        IF check_point_ IS NOT NULL THEN
            npp_rd__ := check_point_;
        END IF;
        IF (obj_rpart.is_track_locked(robot_id_, npp_rd__, dir_) = 0) THEN
            errmm__ := 'ERROR - Ошибка постановки команды для робота ' || robot_id_
                        || ' - команды ' || cmd_text_
                        || ' - незаблокирован трек до секции ' || npp_rd__ || '!';
            CALL obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT_RP"(), rp_id__, robot_id_, errmm__);
            CALL obj_robot.log(robot_id_, errmm__);
            RAISE EXCEPTION '%', errmm__ USING errcode = 50012;
        END IF;
    END IF;
    -- проверка для LOAD/UNLOAD
    IF (service.is_cell_full_check() = 1) THEN
        IF (cmd_inner_type_ = obj_robot."CMD_LOAD_TYPE_ID"()) THEN
            SELECT exists(
                SELECT * FROM cell
                WHERE id = ci_rec__.cell_src_id AND is_full = 0
            ) INTO cc;
            IF cc THEN
                errmm__ := 'ERROR - Ошибка постановки команды для робота ' || robot_id_
                            || ' - команды ' || cmd_text_
                            || ' - ячейка - источник для LOAD пуста!';
                CALL obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT"(), rp_id__, robot_id_, errmm__);
                CALL obj_robot.log(robot_id_, errmm__);
                RAISE EXCEPTION '%', errmm__ USING errcode = 50012;
            END IF;
        ELSIF (cmd_inner_type_ = obj_robot."CMD_UNLOAD_TYPE_ID"()) THEN
            SELECT exists(
                SELECT * FROM cell
                WHERE id = ci_rec__.cell_dest_id AND is_full >= max_full_size
            ) INTO cc;
            IF cc THEN
                errmm__ := 'ERROR - Ошибка постановки команды для робота ' || robot_id_
                            || ' - команды ' || cmd_text_
                            || ' - ячейка - приемник для UNLOAD переполнена!';
                CALL obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT"(), rp_id__, robot_id_, errmm__);
                CALL obj_robot.log(robot_id_, errmm__);
                RAISE EXCEPTION '%', errmm__ USING errcode = 50012;
            END IF;
        END IF;
    END IF;
    INSERT INTO command_inner (command_type_id, rp_id,
        cell_src_sname, cell_src_id, track_src_id, npp_src,
        cell_dest_sname, cell_dest_id, track_dest_id, npp_dest,
        track_npp_begin,
        state, command_rp_id, robot_id, command_to_run, direction, container_id, check_point)
    VALUES (cmd_inner_type_,rob_rec__.repository_part_id,
        cell_src_sname_, ci_rec__.cell_src_id, ci_rec__.track_src_id, ci_rec__.npp_src,
        cell_dest_sname_, ci_rec__.cell_dest_id, ci_rec__.track_dest_id, ci_rec__.npp_dest,
        rob_rec__.current_track_npp,
        1, crp_id_, robot_id_, cmd_text_, dir_, container_id_, check_point_)
    RETURNING id INTO ciid__;
    UPDATE robot SET command_inner_assigned_id = ciid__ WHERE id = robot_id_;
    CALL obj_robot.log(robot_id_, 'Успешно назначили cmd_inner id=' || ciid__);
END;
$BODY$;
COMMENT ON PROCEDURE obj_robot.set_command_inner(bigint, bigint, bigint, bigint, bigint, text, text, text, bigint, bigint)
    IS 'выдаем роботу простую команду типа load/Unload/Move';


CREATE OR REPLACE PROCEDURE obj_robot.redirect_robot_to_new_cell(
    robot_id_ bigint,
    cmd_rp_id_ bigint,
    container_id_ bigint,
    ci_npp_dest_ bigint,
    ci_cell_dest_id_ bigint)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr robot;
    cellrec cell;
    direction_ BIGINT;
BEGIN
    FOR rr IN (
        SELECT *
            FROM robot
            WHERE id = robot_id_
                AND platform_busy = 1
    ) LOOP
        IF obj_rpart.has_free_cell_by_cnt(container_id_, rr.repository_part_id) > 0 -- есть еще место на складе
            AND ci_npp_dest_ = rr.current_track_npp  -- чтоб точно быть уверенным, что дело именно в этом
            AND obj_rpart.is_poss_ass_new_unload_cell(ci_cell_dest_id_, robot_id_) = 1 -- а можно ли выгрузить в какую-нить другую ячейку  принципе?
        THEN
            CALL obj_rpart.try_assign_new_unload_cell(ci_cell_dest_id_, robot_id_, cellrec, direction_);
            IF (cellrec.track_npp IS NOT null) THEN
                UPDATE robot
                    SET state = 0, command_inner_id = null, cmd_error_descr = null
                    WHERE id = robot_id_;
                --update command_inner set state=2, error_code_id=error_code  where id=cirec.id;
                --update cell set is_error=1 where id=cirec.cell_dest_id;
                CALL obj_rpart.change_cmd_rp_goal(cmd_rp_id_, cellrec.id);
                UPDATE command_rp
                    SET substate = 3, direction_2 = direction_
                    WHERE id = cmd_rp_id_;
                RETURN;
            END IF;
        END IF;
    END LOOP;
    RAISE EXCEPTION 'Невозможно перенаправить робота в другую ячейку!'
        USING errcode = 50003;
END;
$BODY$;
COMMENT ON PROCEDURE obj_robot.redirect_robot_to_new_cell(bigint, bigint, bigint, bigint, bigint)
    IS 'перенаправить робота в новую целевую ячейку (Unload)';


-- vim: ft=pgsql
