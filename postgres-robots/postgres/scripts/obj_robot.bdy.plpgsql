CREATE OR REPLACE FUNCTION obj_robot."DIR_CW"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 1;
END;
$BODY$;
ALTER FUNCTION obj_robot."DIR_CW"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."DIR_CW"() IS 'DIR: по часовой, от меньшего к большему';
CREATE OR REPLACE FUNCTION obj_robot."DIR_CCW"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_robot."DIR_CCW"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."DIR_CCW"() IS 'DIR: против часовой, от большего к меньшему';
CREATE OR REPLACE FUNCTION obj_robot."DIR_NONE"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_robot."DIR_NONE"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."DIR_NONE"() IS 'DIR: нет никакого направления';

CREATE OR REPLACE FUNCTION obj_robot."CMD_LOAD"(
    )
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 'LOAD';
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_LOAD"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_LOAD"() IS 'Символьные названия команд: LOAD';
CREATE OR REPLACE FUNCTION obj_robot."CMD_UNLOAD"(
    )
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 'UNLOAD';
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_UNLOAD"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_UNLOAD"() IS 'Символьные названия команд: UNLOAD';
CREATE OR REPLACE FUNCTION obj_robot."CMD_MOVE"(
    )
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 'MOVE';
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_MOVE"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_MOVE"() IS 'Символьные названия команд: MOVE';
CREATE OR REPLACE FUNCTION obj_robot."CMD_INITY"(
    )
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 'INITY';
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_INITY"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_INITY"() IS 'Символьные названия команд: INITY';

CREATE OR REPLACE FUNCTION obj_robot."CMD_LOAD_TYPE_ID"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 4;
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_LOAD_TYPE_ID"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_LOAD_TYPE_ID"() IS 'Числовой код команды: LOAD';
CREATE OR REPLACE FUNCTION obj_robot."CMD_UNLOAD_TYPE_ID"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 5;
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_UNLOAD_TYPE_ID"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_UNLOAD_TYPE_ID"() IS 'Числовой код команды: UNLOAD';
CREATE OR REPLACE FUNCTION obj_robot."CMD_MOVE_TYPE_ID"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 6;
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_MOVE_TYPE_ID"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_MOVE_TYPE_ID"() IS 'Числовой код команды: MOVE';
CREATE OR REPLACE FUNCTION obj_robot."CMD_INITY_TYPE_ID"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 32;
END;
$BODY$;
ALTER FUNCTION obj_robot."CMD_INITY_TYPE_ID"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."CMD_INITY_TYPE_ID"() IS 'Числовой код команды: INITY';

CREATE OR REPLACE FUNCTION obj_robot."ROBOT_STATE_READY"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_robot."ROBOT_STATE_READY"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."ROBOT_STATE_READY"() IS 'Состояние робота: готов';
CREATE OR REPLACE FUNCTION obj_robot."ROBOT_STATE_BUSY"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 1;
END;
$BODY$;
ALTER FUNCTION obj_robot."ROBOT_STATE_BUSY"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."ROBOT_STATE_BUSY"() IS 'Состояние робота: работает';
CREATE OR REPLACE FUNCTION obj_robot."ROBOT_STATE_ERROR"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 2;
END;
$BODY$;
ALTER FUNCTION obj_robot."ROBOT_STATE_ERROR"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."ROBOT_STATE_ERROR"() IS 'Состояние робота: в ошибке';
CREATE OR REPLACE FUNCTION obj_robot."ROBOT_STATE_INIT"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 3;
END;
$BODY$;
ALTER FUNCTION obj_robot."ROBOT_STATE_INIT"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."ROBOT_STATE_INIT"() IS 'Состояние робота: в режиме инициализации';
CREATE OR REPLACE FUNCTION obj_robot."ROBOT_STATE_REPAIR"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 6;
END;
$BODY$;
ALTER FUNCTION obj_robot."ROBOT_STATE_REPAIR"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."ROBOT_STATE_REPAIR"() IS 'Состояние робота: в починке';
CREATE OR REPLACE FUNCTION obj_robot."ROBOT_STATE_DISCONNECT"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 8;
END;
$BODY$;
ALTER FUNCTION obj_robot."ROBOT_STATE_DISCONNECT"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."ROBOT_STATE_DISCONNECT"() IS 'Состояние робота: нет связи';

CREATE OR REPLACE FUNCTION obj_robot."PR_UNLOAD_RETRY"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 5;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_UNLOAD_RETRY"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_UNLOAD_RETRY"() IS 'Варианты решения проблемы: повторить команду UNLOAD';
CREATE OR REPLACE FUNCTION obj_robot."PR_UNLOAD_HANDLE"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 6;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_UNLOAD_HANDLE"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_UNLOAD_HANDLE"() IS 'Варианты решения проблемы: UNLOAD выполнена вручную';
CREATE OR REPLACE FUNCTION obj_robot."PR_UNLOAD_MARK_BAD_REDIRECT"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 14;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_UNLOAD_MARK_BAD_REDIRECT"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_UNLOAD_MARK_BAD_REDIRECT"() IS 'Варианты решения проблемы: UNLOAD - пометить целевую ячейку как плохую и перенаправить контейнер в другую ячейку';
CREATE OR REPLACE FUNCTION obj_robot."PR_UNLOAD_INDICATE_REDIRECT"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 15;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_UNLOAD_INDICATE_REDIRECT"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_UNLOAD_INDICATE_REDIRECT"() IS 'Варианты решения проблемы: UNLOAD - Указать какой контейнер находится в ячейке и перенаправить текущий контейнер в другую ячейку';
CREATE OR REPLACE FUNCTION obj_robot."PR_LOAD_RETRY"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 1;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_LOAD_RETRY"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_LOAD_RETRY"() IS 'Варианты решения проблемы: повторить LOAD';
CREATE OR REPLACE FUNCTION obj_robot."PR_LOAD_HANDLE"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 2;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_LOAD_HANDLE"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_LOAD_HANDLE"() IS 'Варианты решения проблемы: LOAD выполнена вручную';
CREATE OR REPLACE FUNCTION obj_robot."PR_LOAD_CELL_EMPTY"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 16;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_LOAD_CELL_EMPTY"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_LOAD_CELL_EMPTY"() IS 'Варианты решения проблемы: LOAD - целевая ячейка пуста';
CREATE OR REPLACE FUNCTION obj_robot."PR_LOAD_CELL_BAD"(
    )
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 18;
END;
$BODY$;
ALTER FUNCTION obj_robot."PR_LOAD_CELL_BAD"() OWNER TO postgres;
COMMENT ON FUNCTION obj_robot."PR_LOAD_CELL_BAD"() IS 'Варианты решения проблемы: LOAD - Контейнер в целевой ячейке заклинило';


CREATE OR REPLACE FUNCTION obj_robot.get_log_file_name(
    robot_id_ numeric)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 'robot_ora_' || robot_id_ || '_'
        || to_char(LOCALTIMESTAMP,'ddmmyy') || '.log';
END;
$BODY$;
ALTER FUNCTION obj_robot.get_log_file_name(numeric) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_log_file_name(numeric)
    IS 'Generates log name based on robot id and date.
получить имя файла лога';


CREATE OR REPLACE PROCEDURE obj_robot.log(
    robot_id_ bigint,
    txt_ text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    filename TEXT;
BEGIN
    filename := obj_robot.get_log_file_name(robot_id_);
    PERFORM pg_catalog.pg_file_write(
        filename,
        to_char(LOCALTIMESTAMP,'HH24:MI:SS.MS') || ' ' || txt_ || E'\n',
        true
    );
END;
$BODY$;
COMMENT ON PROCEDURE obj_robot.log(bigint, text)
    IS 'Adds timestamped entry into log for specified robot
процедура ведения журнала';


CREATE OR REPLACE FUNCTION obj_robot.is_robot_ready_for_cmd(
    rid_ bigint,
    not_connected_is_ready_ boolean DEFAULT false)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    ncir BIGINT;
    rr robot;
BEGIN
    ncir := 0;
    IF not_connected_is_ready_ THEN
        ncir := 1;
    END IF;
    FOR rr in (
        SELECT *
            FROM robot
            WHERE id = rid_
                AND ((state = 0) OR (ncir = 1 AND state IN (0,8)))
                AND is_present = 1
                AND coalesce(command_rp_id, 0) = 0
                AND coalesce(command_inner_assigned_id, 0) = 0
                AND coalesce(command_inner_id, 0) = 0
                AND coalesce(wait_for_problem_resolve, 0) = 0
    ) LOOP
        RETURN 1;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_robot.is_robot_ready_for_cmd(bigint, boolean) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.is_robot_ready_for_cmd(bigint, boolean)
    IS 'робот готов для команд перемещения контейнера?';


CREATE OR REPLACE FUNCTION obj_robot.is_robot_ready_for_cmd_inner(
    rid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr robot;
BEGIN
    FOR rr IN (
        SELECT *
            FROM robot
            WHERE id = rid_
                AND state = 0
                AND is_present = 1
                AND coalesce(command_inner_assigned_id, 0) = 0
                AND coalesce(command_inner_id, 0) = 0
                AND coalesce(wait_for_problem_resolve, 0) = 0
    ) LOOP
        RETURN 1;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_robot.is_robot_ready_for_cmd_inner(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.is_robot_ready_for_cmd_inner(bigint)
    IS 'робот готов для подкоманд перемещения контейнера (load/unload)?';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_inner_npp_dest(
    IN cid_ bigint,
    IN is_use_cp_ bigint DEFAULT 0)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    res_ BIGINT;
    ci__ command_inner;
    chp command_inner_checkpoint;
BEGIN
    FOR ci__ IN (
        SELECT *
            FROM command_inner
            WHERE id = cid_
    ) LOOP
        IF (is_use_cp_ = 1)
            AND (ci__.check_point IS NOT null)
        THEN -- есть промежуточные точки
            res_ := ci__.check_point;
            FOR chp IN (
                SELECT *
                    FROM command_inner_checkpoint
                    WHERE command_inner_id = cid_
                    ORDER BY id DESC
            ) LOOP
                res_ := chp.npp;
                EXIT;
            END LOOP;
            RETURN res_;
        ELSE
            IF (ci__.command_type_id = obj_robot."CMD_LOAD_TYPE_ID"()) THEN
                RETURN ci__.npp_src;
            ELSE
                RETURN ci__.npp_dest;
            END IF;
        END IF;
    END LOOP;
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_inner_npp_dest(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_inner_npp_dest(bigint, bigint)
    IS 'получить № целевого трека команды робота';


CREATE OR REPLACE FUNCTION obj_robot.get_cmd_inner_last_checkpoint(
    IN cmd_inner_id_ bigint,
    IN in_status_ bigint DEFAULT null)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    ci command_inner;
    chp command_inner_checkpoint;
BEGIN
    FOR ci IN (
        SELECT *
            FROM command_inner
            WHERE id = cmd_inner_id_
                AND check_point IS NOT null
    ) LOOP
        FOR chp IN (
            SELECT *
                FROM command_inner_checkpoint
                WHERE cmd_inner_id_ = command_inner_id
                    AND status = coalesce(in_status_, status)
                ORDER BY id DESC
        ) LOOP
            RETURN chp.npp;
        END LOOP;
        RETURN ci.check_point;
    END LOOP;
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_inner_last_checkpoint(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_inner_last_checkpoint(bigint, bigint)
    IS 'возвращает NPP последней промежуточной точки команды, или -1 если нет такой';


CREATE FUNCTION obj_robot.get_cmd_text_another_dir(IN ct text)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    res TEXT;
BEGIN
    IF position('CCW' IN ct) > 0 THEN
        res := replace(ct, 'CCW', '');
    ELSE
        res := replace(ct, ';;', ';CCW;');
    END IF;
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_text_another_dir(text) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_text_another_dir(text)
    IS 'возвращает текст команды робота с иным направлением движения по/против часовой стрелке';


CREATE FUNCTION obj_robot.get_cmd_text_wo_cp(IN ct_ text)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    lp_ BIGINT;
    sc_ BIGINT;
    ncitext TEXT;
BEGIN
    ncitext := ct_;
    lp_ := position('cp' IN ncitext);
    IF (lp_ > 0) THEN
        sc_ := position(';' IN ncitext);
        IF (sc_ <= 0) THEN
            -- FIXME: Casting from BIGINT to INT, possible data loss
            RETURN trim(substring(ncitext FROM 1 FOR lp_::int - 1));
        ELSE
            RETURN trim(substring(ncitext FROM 1 FOR lp_::int - 1)) || substring(ncitext FROM sc_::int);
        END IF;
    ELSE -- и так нет
        RETURN ncitext;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_text_wo_cp(text) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_text_wo_cp(text)
    IS 'исключает ''cp=NNN'' из текста команды';


CREATE FUNCTION obj_robot.get_cmd_text_new_cp(
    IN ct_ text,
    IN new_cp_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    lp_ BIGINT;
    ncitext TEXT;
BEGIN
    ncitext := obj_robot.get_cmd_text_wo_cp(ct_); -- убрали, если было
    lp_ := position(';' IN ncitext);
    IF (new_cp_ IS null) THEN
        RAISE EXCEPTION 'Нельзя менять промежуточную секцию на пустоту!'
            USING errcode = 50003;
    END IF;
    IF (lp_ > 0) THEN -- есть ;
        -- FIXME: Casting from BIGINT to INT, possible data loss
        RETURN trim(substring(ncitext FROM 1 FOR lp_::int - 1)) || ' cp=' || new_cp_ || substring(ncitext FROM lp_::int);
    ELSE -- нет ';', просто лупим в конец
        RETURN ncitext || ' cp=' || new_cp_;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_robot.get_cmd_text_new_cp(text, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_robot.get_cmd_text_new_cp(text, bigint)
    IS 'заменяет ''cp=NNN'' в тексте команды на другую секцию';


CREATE OR REPLACE PROCEDURE obj_robot.set_command_inner(
    robot_id_ bigint,
    crp_id_ bigint,
    new_cmd_state_ bigint,
    cmd_inner_type_ bigint,
    dir_ bigint,
    cell_src_sname_ text,
    cell_dest_sname_ text,
    cmd_text_ text,
    container_id_ bigint DEFAULT 0,
    check_point_ bigint DEFAULT NULL::bigint)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rob_rec__ RECORD;
    ci_rec__ command_inner;
    cc BOOLEAN;
    ciid__ BIGINT;
    cnt__ BIGINT;
    errmm__ TEXT;
    -- lpfix__ TEXT;
    rp_id__ BIGINT;
    nomr__ BIGINT;
    npp_rd__ BIGINT;
BEGIN
    SELECT * INTO rob_rec__ FROM robot WHERE id = robot_id_;
    rp_id__ := rob_rec__.repository_part_id;
    SELECT num_of_robots INTO nomr__ FROM repository_part WHERE id = rp_id__;
    CALL obj_robot.log(robot_id_, 'set_command_inner: robot_id_=' || robot_id_
                                    || '; crp_id_=' || crp_id_
                                    || '; new_cmd_state=' || new_cmd_state_
                                    || '; cmd_inner_type=' || cmd_inner_type_
                                    || '; dir=' || dir_
                                    || '; cell_src_sname_=' || cell_src_sname_
                                    || '; cell_dest_sname_=' || cell_dest_sname_
                                    || '; cmd_text=' || cmd_text_);
    SELECT count(*) INTO cnt__ FROM command_inner WHERE robot_id = robot_id_ AND state = 3;
    IF (cnt__ <> 0) THEN
        errmm__ := 'ERROR постановки команды - назначается новая, а есть еще старая ';
        CALL obj_robot.log(robot_id_, errmm__);
        RAISE EXCEPTION '%', errmm__ USING errcode = 50003;
    END IF;
    IF (rob_rec__.state <> 0) THEN
        errmm__ := 'ERROR постановки команды для робота ' || robot_id_ || ' - робот занят!';
        CALL obj_robot.log(robot_id_, errmm__);
        RAISE EXCEPTION '%', errmm__ USING errcode = 50012;
    END IF;
    IF (coalesce(rob_rec__.command_inner_assigned_id, 0) <> 0) THEN
        errmm__ := 'ERROR постановки команды для робота ' || robot_id_ ||
            ' - уже закреплена но не запущена команда ' || rob_rec__.command_inner_assigned_id;
        CALL obj_robot.log(robot_id_, errmm__);
        RAISE EXCEPTION '%', errmm__ USING errcode = 50012;
    END IF;
    IF (cell_src_sname_ IS NULL) AND (cell_dest_sname_ IS NULL) THEN
        errmm__ := 'ERROR постановки команды для робота ' || robot_id_ || ' - пустые и источник и приемник!';
        CALL obj_robot.log(robot_id_, errmm__);
        RAISE EXCEPTION '%', errmm__ USING errcode = 50012;
    END IF;
    rob_rec__.state := 1;
    ci_rec__.command_type_id := cmd_inner_type_;
    ci_rec__.direction := dir_;
    IF (cell_src_sname_ IS NOT NULL) THEN
        SELECT c.id, t.npp, t.id
            INTO ci_rec__.cell_src_id, ci_rec__.npp_src, ci_rec__.track_src_id
            FROM cell c
            INNER JOIN shelving s
                ON c.shelving_id = s.id
            INNER JOIN track t
                ON s.track_id = t.id
            WHERE c.sname = cell_src_sname_
                AND t.repository_part_id = rob_rec__.repository_part_id;
    ELSE
        ci_rec__.cell_src_id := 0;
        ci_rec__.npp_src := 0;
        ci_rec__.track_src_id := 0;
    END IF;
    IF (cell_dest_sname_ IS NOT NULL) THEN
        SELECT c.id, t.npp, t.id
        INTO ci_rec__.cell_dest_id, ci_rec__.npp_dest, ci_rec__.track_dest_id
        FROM cell c
        INNER JOIN shelving s
            ON c.shelving_id = s.id
        INNER JOIN track t
            ON s.track_id = t.id
        WHERE c.sname = cell_dest_sname_
            AND t.repository_part_id = rob_rec__.repository_part_id;
    ELSE
        ci_rec__.cell_dest_id := 0;
        ci_rec__.npp_dest := 0;
        ci_rec__.track_dest_id := 0;
    END IF;
    -- проверка на занятость плафтормы
    IF (cmd_inner_type_ IN (5)) THEN -- unload
        IF (rob_rec__.platform_busy = 0) THEN
            UPDATE robot SET wait_for_problem_resolve = 1 WHERE id = robot_id_;
            errmm__ := '  ERROR for robot=' || robot_id_ || ' rob_rec.platform_busy=0';
            CALL obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT"(), rp_id__, robot_id_, errmm__);
            CALL obj_robot.log(robot_id_, errmm__);
            RETURN;
            --raise_application_error (-20012, 'Неовзможно дать команду unload при пустой плафторме');
        END IF;
    ELSIF (cmd_inner_type_ IN (4)) THEN -- load
        IF (rob_rec__.platform_busy = 1) THEN
            UPDATE robot SET wait_for_problem_resolve = 1 WHERE id = robot_id_;
            errmm__ := '  ERROR for robot=' || robot_id_ || ' rob_rec.platform_busy=1';
            CALL obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT"(), rp_id__, robot_id_, errmm__);
            CALL obj_robot.log(robot_id_, errmm__);
            RETURN;
        END IF;
    END IF;
    IF (nomr__ > 1) THEN -- проверяем, а заблокирован ли трек до цели в случае > 1-го робота
        IF (cmd_inner_type_ IN (5,6)) THEN
            npp_rd__ := ci_rec__.npp_dest;
        ELSE
            npp_rd__ := ci_rec__.npp_src;
        END IF;
        IF check_point_ IS NOT NULL THEN
            npp_rd__ := check_point_;
        END IF;
        IF (obj_rpart.is_track_locked(robot_id_, npp_rd__, dir_) = 0) THEN
            errmm__ := 'ERROR - Ошибка постановки команды для робота ' || robot_id_
                        || ' - команды ' || cmd_text_
                        || ' - незаблокирован трек до секции ' || npp_rd__ || '!';
            CALL obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT_RP"(), rp_id__, robot_id_, errmm__);
            CALL obj_robot.log(robot_id_, errmm__);
            RAISE EXCEPTION '%', errmm__ USING errcode = 50012;
        END IF;
    END IF;
    -- проверка для LOAD/UNLOAD
    IF (service.is_cell_full_check() = 1) THEN
        IF (cmd_inner_type_ = obj_robot."CMD_LOAD_TYPE_ID"()) THEN
            SELECT exists(
                SELECT * FROM cell
                WHERE id = ci_rec__.cell_src_id AND is_full = 0
            ) INTO cc;
            IF cc THEN
                errmm__ := 'ERROR - Ошибка постановки команды для робота ' || robot_id_
                            || ' - команды ' || cmd_text_
                            || ' - ячейка - источник для LOAD пуста!';
                CALL obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT"(), rp_id__, robot_id_, errmm__);
                CALL obj_robot.log(robot_id_, errmm__);
                RAISE EXCEPTION '%', errmm__ USING errcode = 50012;
            END IF;
        ELSIF (cmd_inner_type_ = obj_robot."CMD_UNLOAD_TYPE_ID"()) THEN
            SELECT exists(
                SELECT * FROM cell
                WHERE id = ci_rec__.cell_dest_id AND is_full >= max_full_size
            ) INTO cc;
            IF cc THEN
                errmm__ := 'ERROR - Ошибка постановки команды для робота ' || robot_id_
                            || ' - команды ' || cmd_text_
                            || ' - ячейка - приемник для UNLOAD переполнена!';
                CALL obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT"(), rp_id__, robot_id_, errmm__);
                CALL obj_robot.log(robot_id_, errmm__);
                RAISE EXCEPTION '%', errmm__ USING errcode = 50012;
            END IF;
        END IF;
    END IF;
    INSERT INTO command_inner (command_type_id, rp_id,
        cell_src_sname, cell_src_id, track_src_id, npp_src,
        cell_dest_sname, cell_dest_id, track_dest_id, npp_dest,
        track_npp_begin,
        state, command_rp_id, robot_id, command_to_run, direction, container_id, check_point)
    VALUES (cmd_inner_type_,rob_rec__.repository_part_id,
        cell_src_sname_, ci_rec__.cell_src_id, ci_rec__.track_src_id, ci_rec__.npp_src,
        cell_dest_sname_, ci_rec__.cell_dest_id, ci_rec__.track_dest_id, ci_rec__.npp_dest,
        rob_rec__.current_track_npp,
        1, crp_id_, robot_id_, cmd_text_, dir_, container_id_, check_point_)
    RETURNING id INTO ciid__;
    UPDATE robot SET command_inner_assigned_id = ciid__ WHERE id = robot_id_;
    CALL obj_robot.log(robot_id_, 'Успешно назначили cmd_inner id=' || ciid__);
END;
$BODY$;
COMMENT ON PROCEDURE obj_robot.set_command_inner(bigint, bigint, bigint, bigint, bigint, text, text, text, bigint, bigint)
    IS 'выдаем роботу простую команду типа load/Unload/Move';


CREATE OR REPLACE PROCEDURE obj_robot.redirect_robot_to_new_cell(
    robot_id_ bigint,
    cmd_rp_id_ bigint,
    container_id_ bigint,
    ci_npp_dest_ bigint,
    ci_cell_dest_id_ bigint)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr robot;
    cellrec cell;
    direction_ BIGINT;
BEGIN
    FOR rr IN (
        SELECT *
            FROM robot
            WHERE id = robot_id_
                AND platform_busy = 1
    ) LOOP
        IF obj_rpart.has_free_cell_by_cnt(container_id_, rr.repository_part_id) > 0 -- есть еще место на складе
            AND ci_npp_dest_ = rr.current_track_npp  -- чтоб точно быть уверенным, что дело именно в этом
            AND obj_rpart.is_poss_ass_new_unload_cell(ci_cell_dest_id_, robot_id_) = 1 -- а можно ли выгрузить в какую-нить другую ячейку  принципе?
        THEN
            CALL obj_rpart.try_assign_new_unload_cell(ci_cell_dest_id_, robot_id_, cellrec, direction_);
            IF (cellrec.track_npp IS NOT null) THEN
                UPDATE robot
                    SET state = 0, command_inner_id = null, cmd_error_descr = null
                    WHERE id = robot_id_;
                --update command_inner set state=2, error_code_id=error_code  where id=cirec.id;
                --update cell set is_error=1 where id=cirec.cell_dest_id;
                CALL obj_rpart.change_cmd_rp_goal(cmd_rp_id_, cellrec.id);
                UPDATE command_rp
                    SET substate = 3, direction_2 = direction_
                    WHERE id = cmd_rp_id_;
                RETURN;
            END IF;
        END IF;
    END LOOP;
    RAISE EXCEPTION 'Невозможно перенаправить робота в другую ячейку!'
        USING errcode = 50003;
END;
$BODY$;
COMMENT ON PROCEDURE obj_robot.redirect_robot_to_new_cell(bigint, bigint, bigint, bigint, bigint)
    IS 'перенаправить робота в новую целевую ячейку (Unload)';


-- vim: ft=pgsql
