SET client_encoding = 'UTF8';

CREATE OR REPLACE FUNCTION obj_rpart.get_log_file_name(
    rp_id_ numeric)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 'rp_ora_' || rp_id_ || '_' || to_char(LOCALTIMESTAMP, 'DDMMYY') || '.log';
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_log_file_name(numeric) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_log_file_name(numeric)
    IS 'Generates log filename based on sub warehouse id.
получить имя файла лога';


CREATE OR REPLACE FUNCTION obj_rpart.log(
    rp_id_ numeric,
    txt_ text)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    filename TEXT;
BEGIN
    filename := obj_rpart.get_log_file_name(rp_id_);
    PERFORM pg_catalog.pg_file_write(
        filename,
        to_char(LOCALTIMESTAMP, 'HH24:MI:SS.MS') || ' ' || txt_ || E'\n',
        true
    );
END;
$BODY$;
ALTER FUNCTION obj_rpart.log(numeric, text) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.log(numeric, text)
    IS 'Logs timestamped entry into file specific to current sub warehouse.
процедура ведения журнала';


CREATE OR REPLACE FUNCTION obj_rpart.get_another_direction(
    direction_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    IF (direction_ = 1) THEN
        RETURN 0;
    ELSE
        RETURN 1;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_another_direction(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_another_direction(bigint)
    IS 'получить иное, чем указанное, направление движения робота';


CREATE OR REPLACE FUNCTION obj_rpart.get_cell_name_by_track_id(
    track_id_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res__ TEXT;
BEGIN
    SELECT cell_sname INTO res__
        FROM track
        WHERE id = track_id_;
    RETURN res__;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cell_name_by_track_id(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cell_name_by_track_id(bigint)
    IS 'получить имя ячейки по ID трека (для команды робота move)';


CREATE OR REPLACE FUNCTION obj_rpart.get_cell_name_by_track_npp(
    track_npp_ bigint,
    rp_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res__ TEXT;
BEGIN
    SELECT cell_sname INTO res__
        FROM track
        WHERE npp = track_npp_
            AND repository_part_id = rp_;
    RETURN res__;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cell_name_by_track_npp(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cell_name_by_track_npp(bigint, bigint)
    IS 'получить имя ячейки по № секции на конкретном огурце (нужно для команды move)';


CREATE OR REPLACE FUNCTION obj_rpart.get_container_cell_sname(
    container_barcode_ text)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cc RECORD;
BEGIN
    FOR cc IN (
        SELECT cl.sname
            FROM cell cl
            INNER JOIN container cn
                ON cell_id = cl.id
            WHERE cn.barcode = container_barcode_
    ) LOOP
        RETURN cc.sname;
    END LOOP;
    RETURN null;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_container_cell_sname(text) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_container_cell_sname(text)
    IS 'получить имя ячейки хранения контейнера по его ШК';


CREATE OR REPLACE FUNCTION obj_rpart.get_cell_track_npp(
    cell_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cc cell;
BEGIN
    FOR cc IN (
        SELECT track_npp
            FROM cell
            WHERE id = cell_id_
    ) LOOP
        RETURN cc.track_npp;
    END LOOP;
    RETURN null;
end;
$BODY$;
ALTER FUNCTION obj_rpart.get_cell_track_npp(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cell_track_npp(bigint)
    IS 'взять номер трека по ID ячейки';


CREATE OR REPLACE FUNCTION obj_rpart.calc_track_free_cell(
    rpid_ bigint,
    track_npp_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cnt_ BIGINT;
BEGIN
    SELECT count(*) INTO cnt_
        FROM cell
        WHERE repository_part_id = rpid_
            AND track_npp = track_npp_
            AND hi_level_type = 1
            AND is_full = 0
            AND NOT exists(
                SELECT *
                    FROM cell_cmd_lock
                    WHERE cell_id = cell.id
            );
    RETURN cnt_;
END;
$BODY$;
ALTER FUNCTION obj_rpart.calc_track_free_cell(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.calc_track_free_cell(bigint, bigint)
    IS 'посчитать сколько в треке соводных ячеек для хранения';


CREATE OR REPLACE FUNCTION obj_rpart.get_cmd_max_priority(
    rp_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cnt BIGINT;
    res BIGINT;
BEGIN
    SELECT count(*) INTO cnt
        FROM command_rp
        WHERE state IN (0,1)
            AND command_type_id = 3
            AND rp_id = rp_id_
            AND date_time_begin IS null;
    IF (cnt = 0) THEN -- нет запущенных команд
        RETURN 0;
    ELSE
        SELECT coalesce(max(priority), 0) INTO res
            FROM command_rp
            WHERE command_type_id = 3
                AND state IN (0,1)
                AND rp_id = rp_id_
                AND date_time_begin IS null;
        RETURN res;
    END IF;
    RETURN 0;
EXCEPTION WHEN others THEN
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cmd_max_priority(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cmd_max_priority(bigint)
    IS 'получить максимальный приоритет активной команды по подскладу';


CREATE OR REPLACE FUNCTION obj_rpart.get_cmd_dir_text(
    dir_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    IF (dir_ = 1) THEN
        RETURN '';
    ELSE
        RETURN 'CCW';
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cmd_dir_text(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cmd_dir_text(bigint)
    IS 'получить по ID направления кусок команды в текстовом виде для отдачи роботу';


CREATE OR REPLACE FUNCTION obj_rpart.get_cmd_rp_min_ns_id(
    rp_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    tt command_rp;
BEGIN
    FOR tt IN (
        SELECT id
            FROM command_rp t
            WHERE rp_id = rp_id_
                AND state IN (0,1,3)
                AND command_type_id = 3
                AND robot_id IS null
            ORDER BY id
    ) LOOP
        RETURN tt.id;
    END LOOP;
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cmd_rp_min_ns_id(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cmd_rp_min_ns_id(bigint)
    IS 'получить минимальный ID активной команды в указанном огурце';


CREATE OR REPLACE FUNCTION obj_rpart.get_cmd_rp_min_ns_id(
    rp_id_ bigint,
    pri_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    tt command_rp;
BEGIN
    FOR tt IN (
        SELECT id
            FROM command_rp t
            WHERE rp_id = rp_id_
                AND state IN (0,1,3)
                AND command_type_id = 3
                AND priority = pri_
                AND robot_id IS null
            ORDER BY id
    ) LOOP
        RETURN tt.id;
    END LOOP;
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cmd_rp_min_ns_id(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cmd_rp_min_ns_id(bigint, bigint)
    IS 'получить минимальный ID активной команды в указанном огурце в указанном приоритете';


CREATE OR REPLACE FUNCTION obj_rpart.get_cmd_rp_order_after_min(
    rpid_ bigint,
    cmdrpid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    min__ BIGINT;
    oo__ BIGINT;
    tt command_rp;
BEGIN
    min__ := obj_rpart.get_cmd_rp_min_ns_id(rpid_);
    IF (min__ = cmdrpid_) THEN
        RETURN 0;
    END IF;
    IF (min__ > 0) THEN
        oo__ := 0;
        FOR tt IN (
            SELECT *
                FROM command_rp t
                WHERE rp_id = rpid_
                    AND command_type_id = 3
                    AND id >= min__
                ORDER BY id
        ) LOOP
            IF (tt.id = cmdrpid_) THEN
                RETURN oo__;
            END IF;
            oo__ := oo__ + 1;
        END LOOP;
    END IF;
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cmd_rp_order_after_min(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cmd_rp_order_after_min(bigint, bigint)
    IS 'получить порядковый № команды перемещения контейнеров в огурце после минимально активной';


CREATE OR REPLACE FUNCTION obj_rpart.get_cmd_rp_order_after_min(
    rpid_ bigint,
    pri_ bigint,
    cmdrpid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    min__ BIGINT;
    oo__ BIGINT;
    tt command_rp;
BEGIN
    min__ := obj_rpart.get_cmd_rp_min_ns_id(rpid_, pri_);
    IF (min__ = cmdrpid_) THEN
        RETURN 0;
    END IF;
    IF (min__ > 0) THEN
        oo__ := 0;
        FOR tt IN (
            SELECT *
                FROM command_rp t
                WHERE rp_id = rpid_
                    AND command_type_id = 3
                    AND priority = pri_
                    AND id >= min__
                ORDER BY id
        ) LOOP
            IF (tt.id = cmdrpid_) THEN
                RETURN oo__;
            END IF;
            oo__ := oo__ + 1;
        END LOOP;
    END IF;
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cmd_rp_order_after_min(bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cmd_rp_order_after_min(bigint, bigint, bigint)
    IS 'получить порядковый № команды перемещения контейнеров в огурце после минимально активной в заданном приоритете';


CREATE OR REPLACE FUNCTION obj_rpart.get_cmd_rp_time_work(
    crpid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    delta__ INTERVAL;
    max_d__ INTERVAL;
    crp__ command_rp;
BEGIN
    max_d__ := INTERVAL '6 minutes';
    FOR crp__ IN (
        SELECT *
            FROM command_rp
            WHERE id = crpid_
    ) LOOP
        delta__ := LOCALTIMESTAMP - coalesce(crp__.date_time_begin, LOCALTIMESTAMP);
        IF delta__ >= max_d__ THEN
            RETURN extract(epoch FROM max_d__);
        ELSE
            RETURN extract(epoch FROM delta__);
        END IF;
    END LOOP;
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cmd_rp_time_work(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cmd_rp_time_work(bigint)
    IS 'сколько уже времени в секундах исполняется команда?';


CREATE OR REPLACE FUNCTION obj_rpart.get_cmd_rp_npp_dir(
    rid_ bigint,
    OUT crp_npp__ bigint,
    OUT crp_dir__ bigint)
    RETURNS record
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    crp_ command_rp;
BEGIN
    crp_npp__ := -1;
    crp_dir__ := -1;
    FOR crp_ IN (
        SELECT crp.*
            FROM robot r
            INNER JOIN command_rp crp
                ON crp.id = command_rp_id
            WHERE r.id = rid_
    ) LOOP
        IF coalesce(crp_.substate, 0) IN (0,1,2) THEN -- только начала выполняться или уже доехали
            crp_npp__ := crp_.npp_src;
            crp_dir__ := crp_.direction_1;
        ELSE
            crp_npp__ := crp_.npp_dest;
            crp_dir__ := crp_.direction_2;
        END IF;
    END LOOP;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cmd_rp_npp_dir(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cmd_rp_npp_dir(bigint)
    IS 'по ID робота получить целевой № секции и направление';


CREATE OR REPLACE FUNCTION obj_rpart.get_next_npp(
    rp_type bigint,
    max_npp bigint,
    cur_npp bigint,
    npp_to bigint,
    dir bigint,
    INOUT next_npp bigint,
    INOUT is_loop_end bigint)
    RETURNS record
    LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    is_loop_end := 0;
    IF (cur_npp = npp_to) THEN
        is_loop_end := 1;
    END IF;
    -- Clockwise
    IF (dir = 1) THEN -- по часовой
        IF (cur_npp < max_npp) THEN
            next_npp:= cur_npp+1;
        ELSIF (cur_npp = max_npp) THEN -- Reached edge
            -- Line
            IF (rp_type = 0) THEN -- линейный
                next_npp := cur_npp;
                is_loop_end := 1;
            -- Cyclic
            ELSE
                next_npp := 0;
            END IF;
        --ELSE
            --if emu_log_level>=1 then emu_log('  gnp: Error cur_npp='||cur_npp); end if;
        END IF;
    -- Counterclockwise
    ELSE
        IF (cur_npp > 0) THEN
            next_npp := cur_npp - 1;
        ELSIF (cur_npp = 0) THEN -- Reached edge
            IF (rp_type = 0) THEN -- Line
                next_npp := cur_npp;
                is_loop_end := 1;
            ELSE
                next_npp:=max_npp;
            END IF;
        --ELSE
            --if emu_log_level>=1 then emu_log('  gnp: Error cur_npp='||cur_npp); end if;
        END IF;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_next_npp(bigint, bigint, bigint, bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_next_npp(bigint, bigint, bigint, bigint, bigint, bigint, bigint)
    IS 'Get next track number in set direction.
взять следующий № трека по направлению (и высчитать, не пришди ли уже куда надо)';


CREATE OR REPLACE FUNCTION obj_rpart.get_real_min_abc_zone(
    rpid bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    res BIGINT;
BEGIN
    SELECT min(zone_id) INTO res
        FROM cell
        WHERE repository_part_id = rpid
            AND is_error = 0
            AND hi_level_type = 1
            AND zone_id > 0;
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_real_min_abc_zone(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_real_min_abc_zone(bigint)
    IS 'получить минимальную зону хранения товара для подсклада';


CREATE OR REPLACE FUNCTION obj_rpart.get_rp_name(
    rpid_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rp RECORD;
BEGIN
    FOR rp IN (
        SELECT name
            FROM repository_part
            WHERE id = rpid_
    ) LOOP
        RETURN rp.name;
    END LOOP;
    RETURN '';
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_rp_name(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_rp_name(bigint)
    IS 'получить имя огурца';


CREATE OR REPLACE FUNCTION obj_rpart.add_track_npp(
    rp_id_ bigint,
    npp_from_ bigint,
    npp_num_ bigint,
    dir_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    k_ BIGINT;
    inc_ BIGINT;
    rp RECORD;
BEGIN
    FOR rp IN (
        SELECT num_of_robots, spacing_of_robots, repository_type, max_npp
             FROM repository_part WHERE id = rp_id_
    ) LOOP
        k_ := npp_from_;
        inc_ := npp_num_;
        -- FIXME: Isn't that trivially solvable with modulus?
        LOOP
            -- Clockwise
            IF (dir_ = 1) THEN -- по часовой стрелке
                IF (k_ = rp.max_npp) THEN -- достигли максимума
                    -- Line, edge reached
                    IF (rp.repository_type = 0) THEN -- склад линейный
                        RETURN rp.max_npp;
                    -- Cyclic, looping over
                    ELSE -- склад кольцевой, начинаем сначала
                        k_:=0;
                        inc_:=inc_-1;
                    END IF;
                ELSE
                    k_:=k_+1;
                    inc_:=inc_-1;
                END IF;
            -- Counterclockwise
            ELSE -- против часовой стрелке
                IF (k_ = 0) THEN -- достигли минимума
                    -- Line, edge reached
                    IF (rp.repository_type = 0) THEN -- склад линейный
                        RETURN 0;
                    -- Cyclic, looping over
                    ELSE -- склад кольцевой, начинаем с конца
                        k_ := rp.max_npp;
                        inc_ := inc_-1;
                    END IF;
                ELSE
                    k_ := k_-1;
                    inc_ := inc_-1;
                END IF;
            END IF;
            EXIT WHEN inc_ = 0;
        END LOOP;
    END LOOP;
    RETURN k_;
END;
$BODY$;
ALTER FUNCTION obj_rpart.add_track_npp(bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.add_track_npp(bigint, bigint, bigint, bigint)
    IS 'Adds section to track.
примитив для добавления к номеру трека столько-то секций';


-- FIXME: Duplicate of obj_ask.calc_distance
CREATE OR REPLACE FUNCTION obj_rpart.calc_min_distance(
    rp_type bigint,
    max_npp bigint,
    n1 bigint,
    n2 bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BIGINT;
    nn1 BIGINT;
    nn2 BIGINT;
BEGIN
    IF (n2 < n1) THEN
        nn1 := n2;
        nn2 := n1;
    ELSE
        nn1 := n1;
        nn2 := n2;
    END IF;
    res := nn2 - nn1;
    IF (rp_type = 1) THEN -- только для кольцевого
        IF (max_npp - nn2 + nn1) < res THEN
            res := max_npp - nn2 + nn1;
        END IF;
    END IF;
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_rpart.calc_min_distance(bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.calc_min_distance(bigint, bigint, bigint, bigint)
    IS 'вычисляет расстояние между двумя треками npp по оптимальному направлению';


CREATE OR REPLACE FUNCTION obj_rpart.calc_min_distance(
    rp_id_ bigint,
    cell1_ text,
    cell2_ text)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    npp1 BIGINT;
    npp2 BIGINT;
    rr RECORD;
BEGIN
    FOR rr IN (
        SELECT repository_type rt, max_npp
            FROM repository_part
            WHERE id = rp_id_
    ) LOOP
        SELECT track_npp INTO npp1
            FROM cell
            WHERE sname = cell1_
                AND repository_part_id = rp_id_;
        SELECT track_npp INTO npp2
            FROM cell
            WHERE sname = cell2_
                AND repository_part_id = rp_id_;
        RETURN obj_rpart.calc_min_distance(rr.rt, rr.max_npp, npp1, npp2);
    END LOOP;
    RETURN -1;
END;
$BODY$;
ALTER FUNCTION obj_rpart.calc_min_distance(bigint, text, text) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.calc_min_distance(bigint, text, text)
    IS 'вычисляет расстояние между двумя ячейками по оптимальному направлению';


CREATE OR REPLACE FUNCTION obj_rpart.calc_robot_nearest(
    rp_id bigint,
    max_npp bigint,
    c_npp bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BIGINT;
    t BIGINT;
    rpt BIGINT;
    rr robot;
BEGIN
    res := 10000;
    FOR rr IN (
        SELECT *
            FROM robot
            WHERE repository_part_id = rp_id
                AND state = 0
    ) LOOP
        SELECT repository_type INTO rpt
            FROM repository_part
            WHERE id = rr.repository_part_id;
        t := obj_ask.calc_distance(rpt, max_npp, rr.current_track_npp, c_npp);
        IF (t < res) THEN
            res := t;
        END IF;
    END LOOP;
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_rpart.calc_robot_nearest(bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.calc_robot_nearest(bigint, bigint, bigint)
    IS 'посчитать расстояние до ближайшего робота от указанного трека';


CREATE OR REPLACE FUNCTION obj_rpart.correct_npp_to_track_order(
    rid_ bigint,
    to_rid_ bigint,
    dir_ bigint,
    npp_to_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    npp_to_ar BIGINT;
    ro_ RECORD;
BEGIN
    FOR ro_ IN (
        SELECT rp.num_of_robots, spacing_of_robots, rp.id rpid
        FROM robot_order ro
        INNER JOIN robot r
            ON ro.robot_id = r.id
        INNER JOIN repository_part rp
            ON r.repository_part_id = rp.id
        WHERE corr_robot_id = to_rid_
        AND dir = dir_
        AND r.id = rid_
    ) LOOP
        IF (ro_.num_of_robots > 0) THEN
            npp_to_ar := obj_rpart.add_track_npp(ro_.rpid, npp_to_, ro_.num_of_robots * (ro_.spacing_of_robots * 2 + 1), dir_);
        ELSE
            npp_to_ar := npp_to_;
        END IF;
        RETURN npp_to_ar;
    END LOOP;
    RETURN npp_to_;
END;
$BODY$;
ALTER FUNCTION obj_rpart.correct_npp_to_track_order(bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.correct_npp_to_track_order(bigint, bigint, bigint, bigint)
    IS 'корректируем заявку на блокировку трека по вновь открывшимся обстоятельствам';


CREATE OR REPLACE FUNCTION obj_rpart.add_check_point(
    rp_id_ bigint,
    sorb_ bigint,
    robot_id_ bigint,
    dir_ bigint,
    track_npp_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    tr_ BIGINT;
    ci RECORD;
BEGIN
    FOR ci IN (
        SELECT * FROM command_inner
        WHERE robot_id = robot_id_
        AND STATE IN (0,1,3,4)
        AND coalesce(check_point, -1) >= 0
    ) LOOP
        tr_ := obj_rpart.add_track_npp(rp_id_, track_npp_, sorb_, obj_rpart.get_another_direction(dir_));
        INSERT INTO command_inner_checkpoint(command_inner_id, npp)
            VALUES(ci.id, tr_);
    END LOOP;
END;
$BODY$;
ALTER FUNCTION obj_rpart.add_check_point(bigint, bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.add_check_point(bigint, bigint, bigint, bigint, bigint)
    IS 'Adds checkpoint for robot if it''s supported
добавить промежуточную точку для робота, если он поддерживает';


CREATE OR REPLACE FUNCTION obj_rpart.get_track_npp_by_id(
    id_ numeric)
    RETURNS numeric
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    npp_ numeric;
BEGIN
    SELECT npp INTO npp_ FROM track WHERE id = id_;
    RETURN npp_;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_track_npp_by_id(numeric) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_track_npp_by_id(numeric)
    IS 'взять ID трека по его номеру на конкретном огурце';


CREATE OR REPLACE FUNCTION obj_rpart.unlock_track(
    robot_id_ bigint,
    rp_id_ bigint,
    npp_from_ bigint,
    npp_to_ bigint,
    dir_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rrp RECORD;
    ord RECORD;
    errmm TEXT;
    npp1_ BIGINT;
    npp2_ BIGINT;
    npp2 BIGINT;
    tr_npp BIGINT;
    tr_id BIGINT;
    tr_locked_by_robot_id BIGINT;
    is_loop_exit BIGINT;
BEGIN
    FOR rrp IN (
        SELECT rp.id rpid_, spacing_of_robots sorb, max_npp, repository_type rpt, num_of_robots
            FROM repository_part rp
            WHERE rp.id = rp_id_
    ) LOOP
        PERFORM obj_rpart.log(rrp.rpid_, 'unlock_track: пришла npp_from_=' || npp_from_ || '; npp_to_=' || npp_to_ || '; direction=' || dir_ || '; robot.id=' || robot_id_);
        IF (npp_from_ = npp_to_) THEN
            PERFORM obj_rpart.log(rrp.rpid_, '  нет смысла сразу npp_from_=' || npp_from_ || '; npp_to_=' || npp_to_ || '; direction=' || dir_ || '; robot.id=' || robot_id_);
            RETURN;
        END IF;
        -- FIXME: confusing naming
        npp2 := obj_rpart.add_track_npp(rrp.rpid_, npp_to_, 1, obj_rpart.get_another_direction(dir_));
        npp1_ := obj_rpart.add_track_npp(rrp.rpid_, npp_from_, rrp.sorb, obj_rpart.get_another_direction(dir_));
        npp2_ := obj_rpart.add_track_npp(rrp.rpid_, npp2, rrp.sorb, obj_rpart.get_another_direction(dir_));
        IF (rrp.rpt = 0) AND (npp_to_ <= rrp.sorb) AND (dir_ = 1) THEN
            null;
        ELSEIF (rrp.rpt = 0) AND (npp_to_ >= rrp.max_npp - rrp.sorb) AND (dir_ = 0) THEN
            null;
        ELSE
            tr_npp := npp1_;
            LOOP
                SELECT id, locked_by_robot_id
                    INTO tr_id, tr_locked_by_robot_id
                    FROM track
                    WHERE npp = tr_npp AND repository_part_id = rrp.rpid_;
                IF coalesce(tr_locked_by_robot_id, 0) NOT IN (robot_id_, 0) THEN
                    errmm := 'ERROR - Ошибка ошибка разблокировки трека ' || tr_npp || '! locked by ' || coalesce(tr_locked_by_robot_id,0);
                    PERFORM obj_rpart.log(rrp.rpid_, errmm);
                    RAISE EXCEPTION '%', errmm USING errcode = 50012;
                END IF;
                UPDATE track SET locked_by_robot_id = 0 WHERE id = tr_id;
                -- Fulfil orders and delete them
                -- освобождаем заявки их удовлетворяя
                FOR ord IN (
                    SELECT * FROM track_order
                        WHERE tr_npp = npp_from
                        AND robot_id <> robot_id_
                        AND repository_part_id = rrp.rpid_
                        ORDER BY id
                ) LOOP
                    PERFORM obj_rpart.log(rrp.rpid_,'  есть заявка =' || ord.id || ' - освобождаем');
                    UPDATE track SET locked_by_robot_id = ord.robot_id WHERE id = tr_id;
                    PERFORM obj_rpart.add_check_point(ord.repository_part_id, rrp.sorb, ord.robot_id, ord.direction, tr_npp);
                    -- Order is fulfilled
                    IF ord.npp_from = ord.npp_to THEN -- нет нужды в этой заявке - удаляем ее
                        DELETE FROM track_order WHERE id = ord.id;
                        PERFORM obj_rpart.log(rrp.rpid_,'  уже все выбрано по заявке - удаляем');
                    -- Still fulfilling
                    ELSE -- еще есть нужда в заявке - уменьшаем ее размер
                        IF ord.npp_from = tr_npp THEN
                            PERFORM obj_rpart.log(rrp.rpid_,'  уменьшаем заявку трек ' || tr_npp);
                            npp1_ := obj_rpart.add_track_npp(rrp.rpid_, tr_npp, 1, ord.direction);
                            UPDATE track_order SET npp_from=npp1_ WHERE id = ord.id;
                        END IF;
                    END IF;
                END LOOP;
                SELECT * INTO tr_npp, is_loop_exit FROM obj_rpart.get_next_npp(rrp.rpt, rrp.max_npp, tr_npp, npp2_, dir_, tr_npp, is_loop_exit);
                EXIT WHEN is_loop_exit = 1;
            END LOOP;
        END IF;
    END LOOP;
END;
$BODY$;
ALTER FUNCTION obj_rpart.unlock_track(bigint, bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.unlock_track(bigint, bigint, bigint, bigint, bigint)
    IS 'Unlocks track by fulfilling track orders.
вызывается из триггера при смене текущего трека; нужно передавать rp_id_, чтобы не было мутации';


CREATE OR REPLACE FUNCTION obj_rpart.unlock_track_after_cmd_error(
    robot_id_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rr robot;
    npp1 BIGINT;
    npp2 BIGINT;
    tr_id BIGINT;
    tr_npp BIGINT;
    tr_locked_by_robot_id BIGINT;
    max_npp_ BIGINT;
    is_loop_exit BIGINT;
    sorb BIGINT;
    rpt BIGINT;
BEGIN
    SELECT * INTO rr
        FROM robot
        WHERE id = robot_id_;
    SELECT spacing_of_robots, max_npp, repository_type
        INTO sorb, max_npp_, rpt
        FROM repository_part
        WHERE id = rr.repository_part_id;
    IF (rpt = 0) THEN
        -- нет смысла замарачиваться с блокировкой на линейный склад
        RETURN;
    END IF;
    PERFORM obj_rpart.log(rr.repository_part_id, 'unlock_track_after_cmf_error: robot.id=' || robot_id_);
    npp1 := obj_rpart.inc_spacing_of_robots(
        rr.current_track_npp,
        1,
        sorb + 1,
        rr.repository_part_id
    );
    npp2 := obj_rpart.inc_spacing_of_robots(
        rr.current_track_npp,
        obj_rpart.get_another_direction(1),
        sorb + 1,
        rr.repository_part_id
    );
    --log_track(rr.repository_part_id);
    tr_npp := npp1;
    LOOP
        SELECT id, locked_by_robot_id
            INTO tr_id, tr_locked_by_robot_id
            FROM track
            WHERE npp = tr_npp
                AND repository_part_id = rr.repository_part_id;
        --log_ut_step(4,'  ttle: tr_npp='||tr_npp);
        IF coalesce(tr_locked_by_robot_id, 0) IN (robot_id_) THEN
            UPDATE track SET locked_by_robot_id = 0 WHERE id = tr_id;
        END IF;
        SELECT * INTO tr_npp, is_loop_exit FROM obj_rpart.get_next_npp(rpt, max_npp_, tr_npp, npp2, 1, tr_npp, is_loop_exit);
        EXIT WHEN is_loop_exit = 1;
    END LOOP;
    --log_track(rr.repository_part_id);
end;
$BODY$;
ALTER FUNCTION obj_rpart.unlock_track_after_cmd_error(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.unlock_track_after_cmd_error(bigint)
    IS 'разблокировать трек после ошибки команды робота';


CREATE OR REPLACE FUNCTION obj_rpart.is_active_command_rp(
    rpid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    crp command_rp;
BEGIN
    FOR crp IN (
        SELECT *
            FROM command_rp
            WHERE rp_id = rpid_
                AND state NOT IN (2,5)
    ) LOOP
        RETURN 1;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_active_command_rp(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_active_command_rp(bigint)
    IS 'есть ли активные команды перемещения контейнеров на огурце?';


CREATE OR REPLACE FUNCTION obj_rpart.is_cell_cmd_track_lock(
    cell_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    tr_id_ BIGINT;
    t RECORD;
    cc command_rp;
BEGIN
    SELECT track_id INTO tr_id_
        FROM cell
        INNER JOIN shelving sh
            ON shelving_id = sh.id
        WHERE cell.id = cell_id_;
    FOR t IN (
        SELECT track_id
            FROM cell_cmd_lock ccl
            INNER JOIN cell cl
                ON ccl.cell_id = cl.id
            INNER JOIN shelving sh
                ON cl.shelving_id = sh.id
            WHERE sh.track_id = tr_id_
    ) LOOP
        RETURN 1; -- трек ячейки заблокирован cell_cmd_lock
    END LOOP;
    -- проверяем на команды
    FOR cc IN (
        SELECT *
            FROM command_rp crp
            WHERE crp.state IN (1,3)
                AND coalesce(track_dest_id, -1) = tr_id_
    ) LOOP
        RETURN 1; -- трек ячейки заблокирован command_rp неявно
    END LOOP;
    RETURN 0; -- трек ячейки незаблокирован cell_cmd_lock
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_cell_cmd_track_lock(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_cell_cmd_track_lock(bigint)
    IS 'заблокирована ли трек ячейки?';


CREATE OR REPLACE FUNCTION obj_rpart.is_idle(
    rp_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rr robot;
    tor track_order;
BEGIN
    FOR rr IN (
        SELECT *
            FROM robot
            WHERE repository_part_id = rp_id_
                AND is_present = 1
                AND (
                    coalesce(command_inner_id, 0) <> 0
                    OR coalesce(command_inner_assigned_id, 0) <> 0
                    OR coalesce(command_rp_id, 0) <> 0
                    OR coalesce(wait_for_problem_resolve, 0) <> 0
                    OR state <> 0
                    OR platform_busy <> 0
                )
    ) LOOP
        RETURN 0;
    END LOOP;
    FOR tor IN (
        SELECT *
            FROM track_order
            WHERE robot_id IN (
                SELECT id
                    FROM robot
                    WHERE repository_part_id = rp_id_
            )
    ) LOOP
        RETURN 0;
    END LOOP;
    RETURN 1;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_idle(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_idle(bigint)
    IS 'простаивает ли АСК без команд?';


CREATE OR REPLACE FUNCTION obj_rpart.is_npp_actual_info(
    rp_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rr RECORD;
BEGIN
    FOR rr IN (
        SELECT r.*, rp.npp_actual_time
            FROM robot r
            INNER JOIN repository_part rp
                ON r.repository_part_id = rp.id
            WHERE rp.id = rp_id_
                AND r.state <> obj_robot."ROBOT_STATE_REPAIR"()
    ) LOOP
        IF LOCALTIMESTAMP - rr.last_npp_info_dt > make_interval(secs := rr.npp_actual_time) THEN
            RETURN 0;
        END IF;
    END LOOP;
    RETURN 1;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_npp_actual_info(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_npp_actual_info(bigint)
    IS 'акутальна ли информация в АСК по расположению роботов?';


CREATE OR REPLACE FUNCTION obj_rpart.is_poss_to_lock(
    robot_id_ bigint,
    track_npp_dest bigint,
    direction_ bigint,
    crp_id_ bigint DEFAULT 0)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    ttl_llevel INTEGER := 0;
    track_id_dest BIGINT;
    rp_id_ BIGINT;
    tr_id BIGINT;
    tr_npp BIGINT;
    tr_locked_by_robot_id BIGINT;
    track_id_dest_pl_sor BIGINT;
    track_npp_dest_pl_sor BIGINT;
    cur_track_id BIGINT;
    track_free BIGINT;
    npp1 BIGINT;
    npp2 BIGINT;
    npp1r BIGINT;
    npp2r BIGINT;
    npplto BIGINT;
    goal_npp BIGINT;
    ret_track_id BIGINT;
    npp_ret BIGINT;
    is_in_dest BIGINT;
    cnt BIGINT;
    is_loop_exit BIGINT;
    is_poputka BIGINT;
    is_always_locked BIGINT;
    prefp TEXT;
    r1 robot;
    r2 robot;
    sorb BIGINT;
    max_npp_ BIGINT;
    rpt BIGINT;
    anroid BIGINT;
    nr BIGINT;
BEGIN
    -- зачитываем нужные значения, инициализируем данные, пишем логи
    SELECT * INTO r1
        FROM robot
        WHERE id = robot_id_;
    SELECT t.id, rp.id, spacing_of_robots,
        max_npp, repository_type, num_of_robots
        INTO track_id_dest, rp_id_, sorb,
            max_npp_, rpt, nr
        FROM track t
        INNER JOIN repository_part rp
            ON repository_part_id = rp.id
        WHERE t.npp = track_npp_dest
            AND rp.id = r1.repository_part_id;
    IF /*rpt=0 */ (nr = 1) THEN
        -- для  склада с одним роботом
        IF (r1.current_track_npp = track_npp_dest) THEN
            RETURN -1; -- уже тама
        ELSE
            RETURN track_id_dest;
        END IF;
    END IF;
    prefp := '';
    anroid := obj_rpart.get_another_robot_id(robot_id_);
    SELECT * INTO r2
        FROM robot
        WHERE id = anroid;
    is_in_dest := 0;
    cur_track_id := r1.current_track_id;
    IF track_id_dest = cur_track_id THEN
        RETURN 1;
    END IF;
    npp1 := r1.current_track_npp;
    npp1r := obj_rpart.inc_spacing_of_robots(npp1, direction_, sorb, rp_id_); -- убрали +1
    npp2 := track_npp_dest;
    npp2r := obj_rpart.inc_spacing_of_robots(npp2, direction_, sorb, rp_id_);
    track_id_dest_pl_sor := obj_rpart.get_track_id_by_robot_and_npp(robot_id_, npp2r);
    track_npp_dest_pl_sor := npp2r;
    tr_npp := npp1r;
    LOOP
        tr_id := obj_rpart.get_track_id_by_robot_and_npp(robot_id_, tr_npp);
        SELECT locked_by_robot_id INTO tr_locked_by_robot_id
            FROM track
            WHERE id = tr_id;
        IF coalesce(tr_locked_by_robot_id, 0) = 0 THEN
            --update track set locked_by_robot_id=r1.id where id=tr_id;
            ret_track_id := tr_id;
            npp_ret := tr_npp;
            -- заблокировано кем то иным
        ELSIF coalesce(tr_locked_by_robot_id, 0) <> r1.id THEN
            RETURN 0;
        ELSE -- этим же роботом и заблокировано
            ret_track_id := tr_id;
            npp_ret := tr_npp;
        END IF;
        SELECT * INTO tr_npp, is_loop_exit FROM obj_rpart.get_next_npp(rpt, max_npp_, tr_npp, npp2r, direction_, tr_npp, is_loop_exit);
        EXIT WHEN is_loop_exit = 1;
    END LOOP;
    IF (ret_track_id = track_id_dest_pl_sor) THEN
        -- добрались до конечного трэка с учетом расстояния между роботами
        RETURN 1;
    ELSE -- не дошли до конечного трэка
        RETURN 0;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_poss_to_lock(bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_poss_to_lock(bigint, bigint, bigint, bigint)
    IS 'определяет, возможно ли заблокировать путь';


CREATE OR REPLACE FUNCTION obj_rpart.is_rp_simple_1_robot(
    rp_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp repository_part;
BEGIN
    FOR rp IN (
        SELECT id
            FROM repository_part
            WHERE id = rp_id_
                AND num_of_robots = 1
    ) LOOP
        RETURN 1;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_rp_simple_1_robot(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_rp_simple_1_robot(bigint)
    IS 'является ли огурец простым с одним роботом?';


CREATE OR REPLACE FUNCTION obj_rpart.is_way_free(
    robot_id_ bigint,
    npp_d bigint,
    dir bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    r RECORD;
    rp RECORD;
    cnpp BIGINT;
    ll BIGINT;
    dnppsorb BIGINT;
    is_dest_npp_reached BOOLEAN;
BEGIN
    is_dest_npp_reached := false;
    FOR r IN (
        SELECT *
            FROM robot
            WHERE id = robot_id_
    ) LOOP
        PERFORM obj_rpart.log(r.repository_part_id, 'is_way_free: robot_id_=' || robot_id_ || ' ' || npp_d || ' ' || dir);
        FOR rp IN (
            SELECT repository_type, id, max_npp, spacing_of_robots sorb, num_of_robots
                FROM repository_part
                WHERE id = r.repository_part_id
        ) LOOP
            IF /*rp.repository_type =0 or */rp.num_of_robots=1 THEN -- один робот - всегда все свободно
                RETURN 1;
            END IF;
            cnpp := r.real_npp; --r.current_track_npp;
            IF (cnpp = npp_d) THEN
                RETURN 1; -- там же и стоим
            END IF;
            -- считаем максимум сколько нужно хапануть
            dnppsorb := obj_rpart.inc_spacing_of_robots(npp_d, dir, rp.sorb, rp.id, 0, rp.max_npp);
            PERFORM obj_rpart.log(r.repository_part_id, 'dnppsorb=' || dnppsorb);
            LOOP
                PERFORM obj_rpart.log(r.repository_part_id, '  cnpp=' || cnpp);
                IF (cnpp = npp_d) THEN
                    is_dest_npp_reached := true;
                    PERFORM obj_rpart.log(r.repository_part_id, '    is_dest_npp_reached:=true');
                END IF;
                EXIT WHEN cnpp = dnppsorb AND is_dest_npp_reached;
                IF (dir = 1) THEN -- по часовой
                    IF (rp.repository_type = 1) THEN -- для кольцевого склада
                        IF (cnpp = rp.max_npp) THEN
                            cnpp := 0;
                        ELSE
                            cnpp := cnpp + 1;
                        END IF;
                    ELSE  -- для линейного
                        IF (cnpp < rp.max_npp) THEN
                            cnpp := cnpp + 1;
                        ELSE
                            EXIT; -- выход из цикла
                        END IF;
                    END IF;
                ELSE -- против
                    IF (rp.repository_type = 1) THEN -- для кольцевого склада
                        IF cnpp=0 THEN
                            cnpp := rp.max_npp;
                        ELSE
                            cnpp := cnpp - 1;
                        END IF;
                    ELSE  -- для линейного
                        IF (cnpp > 0) THEN
                            cnpp := cnpp - 1;
                        ELSE
                            EXIT; -- выход из цикла
                        END IF;
                    END IF;
                END IF;
                -- dbms_output.put_line('cnpp='||cnpp);
                RAISE DEBUG 'cnpp=%', cnpp;
                SELECT locked_by_robot_id INTO ll
                    FROM track
                    WHERE repository_part_id = rp.id
                        AND npp = cnpp;
                IF (ll <> r.id) THEN -- ошибка
                    RETURN 0; -- путь не готов - ОШИБКА!!!
                END IF;
            END LOOP;
        END LOOP;
    END LOOP;
    RETURN 1; -- все проверено, мин нет
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_way_free(bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_way_free(bigint, bigint, bigint)
    IS 'проверка на свободность пути';


-- FIXME: Isn't that just inverted "is_way_free"? If not - confusing naming
CREATE OR REPLACE FUNCTION obj_rpart.is_way_locked(
    rp_id_ bigint,
    robot_id_ bigint,
    goal_npp bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    g1 BIGINT;
    g2 BIGINT;
    cur_npp BIGINT;
    -- dir BIGINT;
    g1_is BIGINT;
    g2_is BIGINT;
    rob_rec robot;
    sorb BIGINT;
    lbrid BIGINT;
BEGIN
    SELECT * INTO rob_rec FROM robot WHERE id = robot_id_;
    SELECT spacing_of_robots INTO sorb FROM repository_part WHERE id = rp_id_;
    --if emu_log_level>=2 then emu_log('  is_locked: id='||r(ro_num).id||'; goal_npp='||goal_npp); end if;
    g1 := obj_rpart.inc_spacing_of_robots(goal_npp, 1, sorb, rp_id_);
    g2 := obj_rpart.inc_spacing_of_robots(
        goal_npp,
        obj_rpart.get_another_direction(1),
        sorb,
        rp_id_
    );
    --if emu_log_level>=4 then emu_log('    il: g1='||g1||'; g2='||g2); end if;
    FOR dir IN 0..1 LOOP
        cur_npp := obj_rpart.inc_spacing_of_robots(
            rob_rec.current_track_npp,
            obj_rpart.get_another_direction(dir),
            sorb,
            rp_id_
        );
        g1_is := 0;
        g2_is := 0;
        LOOP
            --if emu_log_level>=4 then emu_log('    il: loop cur_npp='||cur_npp); end if;
            SELECT locked_by_robot_id INTO lbrid
                FROM track
                WHERE npp = cur_npp
                    AND repository_part_id = rp_id_;
            IF (lbrid <> rob_rec.id) THEN
                EXIT;
            END IF;
            IF (cur_npp = g1) THEN
                g1_is := 1;
            END IF;
            IF (cur_npp = g2) THEN
                g2_is := 1;
            END IF;
            EXIT WHEN g1_is = 1 AND g2_is = 1;
            cur_npp := obj_rpart.inc_npp(cur_npp, dir, rp_id_);
        END LOOP;
        IF (g1_is = 1) AND (g2_is = 1) THEN
            --if emu_log_level>=2 then emu_log('    il: return 1'); end if;
            RETURN 1;
        END IF;
    END LOOP;
    --if emu_log_level>=2 then emu_log('    il: return 0'); end if;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_way_locked(bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_way_locked(bigint, bigint, bigint)
    IS 'заблокирован ли путь для робота до цели?';


CREATE OR REPLACE FUNCTION obj_rpart.is_track_between(
    goal_npp numeric,
    npp_from numeric,
    npp_to numeric,
    dir numeric,
    rp_id_ numeric)
    RETURNS numeric
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp_rec_max_npp NUMERIC;
    rp_rec_min_npp NUMERIC;
BEGIN
    SELECT min(npp), max(npp) INTO rp_rec_min_npp, rp_rec_max_npp
        FROM track WHERE repository_part_id = rp_id_;
    -- Clockwise
    -- по часовой стрелке
    IF (dir = 1) THEN
        FOR i IN npp_from..rp_rec_max_npp LOOP
            IF (i = goal_npp) THEN
                RETURN 1;
            END IF;
            IF (i = npp_to) THEN
                RETURN 0;
            END IF;
        END LOOP;
        -- Looping over
        -- за конец
        FOR i IN rp_rec_min_npp..npp_to LOOP
            IF (i = goal_npp) THEN
                RETURN 1;
            END IF;
            IF (i = npp_to) THEN
                RETURN 0;
            END IF;
        END LOOP;
    -- Counterclockwise
    -- против часовой стрелке
    ELSE
        FOR i IN REVERSE rp_rec_min_npp..npp_from LOOP
            IF (i = goal_npp) THEN
                RETURN 1;
            END IF;
            IF (i = npp_to) THEN
                RETURN 0;
            END IF;
        END LOOP;
        -- Looping over
        -- за конец
        FOR i IN REVERSE npp_to..rp_rec_max_npp LOOP
            IF (i = goal_npp) THEN
                RETURN 1;
            END IF;
            IF (i = npp_to) THEN
                RETURN 0;
            END IF;
        END LOOP;
    END IF;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_track_between(numeric, numeric, numeric, numeric, numeric) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_track_between(numeric, numeric, numeric, numeric, numeric)
    IS 'указанный трек между двумя треками по направлению?';


CREATE OR REPLACE FUNCTION obj_rpart.get_cell_id_by_name(
    rp_id_ bigint,
    sname_ text)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BIGINT;
BEGIN
    SELECT id INTO res
    FROM cell
    WHERE sname = sname_ AND shelving_id IN (
        SELECT id FROM shelving WHERE track_id IN (
            SELECT id FROM track WHERE repository_part_id = rp_id_
        )
    );
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cell_id_by_name(bigint, text) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cell_id_by_name(bigint, text)
    IS 'взять ID ячейки по ее имени на конкретном огурце';


CREATE OR REPLACE FUNCTION obj_rpart.get_cell_shelving_id(
    cell_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    shelving_id_ BIGINT;
begin
    FOR shelving_id_ IN (
        SELECT shelving_id
            FROM cell
            WHERE id = cell_id_
    ) LOOP
        RETURN shelving_id_;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cell_shelving_id(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cell_shelving_id(bigint)
    IS 'получить ID стеллажа по ID ячейки';


CREATE OR REPLACE FUNCTION obj_rpart.get_track_id_by_cell_and_robot(
    sname_ text,
    robot_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp_id_ BIGINT;
    res BIGINT;
BEGIN
    SELECT repository_part_id INTO rp_id_
        FROM robot r
        WHERE r.id = robot_id_;
    SELECT t.id INTO res
        FROM shelving s
        INNER JOIN track t
            ON t.id = s.track_id
        INNER JOIN cell c
            ON c.shelving_id = s.id
        WHERE c.sname = sname_
            AND t.repository_part_id = rp_id_;
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_track_id_by_cell_and_robot(text, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_track_id_by_cell_and_robot(text, bigint)
    IS 'получить ID трека по названию ячейка и ID робота';


CREATE OR REPLACE FUNCTION obj_rpart.get_track_npp_not_baned(
    rp_id_ bigint,
    npp_ bigint,
    dir_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    new_npp__ BIGINT;
    tt track;
BEGIN
    FOR tt IN (
        SELECT *
            FROM track
            WHERE npp = npp_
                AND repository_part_id = rp_id_
                AND ban_move_to = 1
    ) LOOP
        -- нельзя сюда ехать
        new_npp__ := obj_rpart.add_track_npp(rp_id_, npp_, 1, obj_rpart.get_another_direction(dir_));
        RETURN new_npp__;
    END LOOP;
    RETURN npp_; -- сюда можно ехать
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_track_npp_not_baned(bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_track_npp_not_baned(bigint, bigint, bigint)
    IS 'получить ближайший трек по заданному направлению, в который можно делать move';


CREATE OR REPLACE FUNCTION obj_rpart.get_track_id_by_cell_and_rp(
    rp_id_ bigint,
    sname_ text)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BIGINT;
BEGIN
    SELECT t.id INTO res
    FROM cell c
    INNER JOIN shelving s
        ON c.shelving_id = s.id
    INNER JOIN track t
        ON s.track_id = t.id
    WHERE c.sname = sname_ AND t.repository_part_id = rp_id_;
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_track_id_by_cell_and_rp(bigint, text) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_track_id_by_cell_and_rp(bigint, text)
    IS 'получить ID трека по огурцу и названию ячейки';


CREATE OR REPLACE FUNCTION obj_rpart.get_track_id_by_npp(
    npp_ bigint,
    rp_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BIGINT;
BEGIN
    SELECT id INTO res
        FROM track
        WHERE npp = npp_
            AND repository_part_id = rp_id_;
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_track_id_by_npp(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_track_id_by_npp(bigint, bigint)
    IS 'взять ID трека по его номеру на конкретном огурце';


CREATE OR REPLACE FUNCTION obj_rpart.get_track_npp_by_cell_and_rp(
    rp_id_ bigint,
    sname_ text)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BIGINT;
BEGIN
    SELECT t.npp INTO res
    FROM cell c
    INNER JOIN shelving s
        ON c.shelving_id = s.id
    INNER JOIN track t
        ON s.track_id = t.id
    WHERE c.sname = sname_ AND t.repository_part_id = rp_id_;
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_track_npp_by_cell_and_rp(bigint, text) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_track_npp_by_cell_and_rp(bigint, text)
    IS 'взять № трека по огурцу и названию ячейки';


CREATE OR REPLACE FUNCTION obj_rpart.get_track_npp_by_npp(
    npp_ bigint,
    rp_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BIGINT;
BEGIN
    SELECT npp INTO res
        FROM track
        WHERE npp = npp_
            AND repository_part_id = rp_id_;
    RETURN res;
EXCEPTION WHEN others THEN
    SELECT npp INTO res
        FROM track
        WHERE name = npp_::TEXT
            AND repository_part_id = rp_id_;
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_track_npp_by_npp(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_track_npp_by_npp(bigint, bigint)
    IS 'проверить, есть ли возвращенный номер трека в базе. Если нет, попытаться найти № трека по имени';


CREATE OR REPLACE FUNCTION obj_rpart.calc_repair_robots(
    rpid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cnt_ BIGINT;
BEGIN
    SELECT count(*) INTO cnt_ FROM robot
        WHERE repository_part_id = rpid_
        AND state = obj_robot."ROBOT_STATE_REPAIR"();
    RETURN cnt_;
END;
$BODY$;
ALTER FUNCTION obj_rpart.calc_repair_robots(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.calc_repair_robots(bigint)
    IS 'сколько роботов на огурце находится в режиме починки?';


CREATE OR REPLACE FUNCTION obj_rpart.calc_distance_by_dir(
    rpid_ bigint,
    n1 bigint,
    n2 bigint,
    dir_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp RECORD;
    res BIGINT;
    nn BIGINT;
BEGIN
    IF (n1 = n2) THEN
        RETURN 0;
    END IF;
    FOR rp IN (
        SELECT repository_type, max_npp
        FROM repository_part
        WHERE id = rpid_
    ) LOOP
        -- Linear track
        IF (rp.repository_type = 0) THEN -- линейный
            IF (n2 < n1) AND (dir_ = 1)
                OR (n2 > n1) AND (dir_ = 0)
            THEN
                res := rp.max_npp * 100;
            ELSE
                res := abs(n2 - n1);
            END IF;
        -- Cyclic track
        ELSE -- кольцевой
            nn := n1;
            res := 0;
            LOOP
                res := res + 1;
                -- Clockwise
                IF (dir_ = 1) THEN -- по часовой
                    IF (nn = rp.max_npp) THEN
                        nn := 0;
                    ELSE
                        nn := nn+1;
                    END IF;
                -- Counterclockwise
                ELSE -- против
                    IF (nn = 0) THEN
                        nn := rp.max_npp;
                    ELSE
                        nn := nn - 1;
                    END IF;
                END IF;
                EXIT WHEN nn = n2;
            END LOOP;
        END IF;
    END LOOP;
    RETURN res;
end;
$BODY$;
ALTER FUNCTION obj_rpart.calc_distance_by_dir(bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.calc_distance_by_dir(bigint, bigint, bigint, bigint)
    IS 'вычисляет расстояние между двумя треками npp по указанному направлению';


CREATE OR REPLACE FUNCTION obj_rpart.get_rp_spacing_of_robots(
    rpid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp RECORD;
BEGIN
    FOR rp IN (
        SELECT spacing_of_robots FROM repository_part WHERE id = rpid_
    ) LOOP
        RETURN rp.spacing_of_robots;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_rp_spacing_of_robots(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_rp_spacing_of_robots(bigint)
    IS 'получить минимальное расстояние между роботами в огурце';


CREATE OR REPLACE FUNCTION obj_rpart.get_rp_command_state(
    rpid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rr robot;
BEGIN
    FOR rr IN (
        SELECT *
            FROM robot
            WHERE repository_part_id = rpid_
    ) LOOP
        IF obj_robot.is_robot_ready_for_cmd(rr.id, true) = 0 THEN
            RETURN 1;
        END IF;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_rp_command_state(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_rp_command_state(bigint)
    IS 'есть ли на подскладе какие-то назначенные на роботов команды перемещения контейнеров
= 0 -нет ни одной команды ни на одного робота
= 1 -есть какие-то команды';


CREATE OR REPLACE FUNCTION obj_rpart.get_rp_robots_state(
    rp_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rr robot;
BEGIN
    FOR rr IN (
        SELECT *
            FROM robot
            WHERE repository_part_id = rp_id_
    ) LOOP
        IF rr.state NOT iN (0,6) THEN
            RETURN 1;
        END IF;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_rp_robots_state(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_rp_robots_state(bigint)
    IS 'есть ли какие-то роботы в огурце активные (не готовы и не в починке)?
= 0 -все роботы свободны или в ремонте
= 1 -есть какие-то работающие роботы';


CREATE OR REPLACE FUNCTION obj_rpart.get_rp_cia_state(
    rp_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rr robot;
BEGIN
    FOR rr IN (
        SELECT *
            FROM robot
            WHERE repository_part_id = rp_id_
    ) LOOP
        IF coalesce(rr.command_inner_assigned_id, 0) <> 0 THEN
            RETURN 1;
        END IF;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_rp_cia_state(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_rp_cia_state(bigint)
    IS 'есть ли какие-то роботы в огурце с командами?
= 0 -все роботы свободные без команд
= 1 -есть какие-то  роботы с командами';


CREATE OR REPLACE FUNCTION obj_rpart.get_track_id_by_robot_and_npp(
    robot_id_ bigint,
    track_no bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    ctid BIGINT;
BEGIN
    SELECT id INTO ctid
        FROM track
        WHERE npp=track_no
        AND repository_part_id = (
            SELECT repository_part_id FROM robot WHERE id = robot_id_
        );
    RETURN ctid;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_track_id_by_robot_and_npp(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_track_id_by_robot_and_npp(bigint, bigint)
    IS 'получить ID трека по ID роботу и № трека';


CREATE OR REPLACE FUNCTION obj_rpart.inc_spacing_of_robots(
    npp_ bigint,
    direction bigint,
    spr bigint,
    rp_id_ bigint,
    minnppr bigint default -1,
    maxnppr bigint default -1)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    maxnpp BIGINT;
    minnpp BIGINT;
    rpt BIGINT;
BEGIN
    SELECT repository_type INTO rpt FROM repository_part WHERE id = rp_id_;
    IF (maxnppr <> -1) THEN
        maxnpp := maxnppr;
    ELSE
        SELECT max(npp) INTO maxnpp FROM track WHERE repository_part_id = rp_id_;
    END IF;
    IF (minnppr <> -1) THEN
        minnpp := minnppr;
    ELSE
        SELECT min(npp) INTO minnpp FROM track WHERE repository_part_id = rp_id_;
    END IF;
    IF (direction = 1) THEN -- по часовой стрелке
        IF (npp_ + spr <= maxnpp) THEN
            RETURN npp_ + spr;
        ELSE
            IF (rpt = 1) THEN  -- для кольцевого
                -- например, есть 0 1 2 3 4, мы стоим на 3, нужно увеличить на 2, 3+2-4-1
                RETURN npp_ + spr - maxnpp - 1;
            ELSE -- для линейного при перехлесте
                RETURN maxnpp;
            END IF;
        END IF;
    ELSE -- против часовой стрелке
        IF (npp_ - spr >= minnpp) THEN
            RETURN (npp_ - spr);
        ELSE
            IF (rpt = 1) THEN  -- для кольцевого
                -- например, есть 0 1 2 3 4, мы стоим на 1, нужно уменьшить на 2, 1-2+4+1
                RETURN npp_ - spr + maxnpp + 1;
            ELSE -- для линейного при самом начале
                RETURN minnpp;
            END IF;
        END IF;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.inc_spacing_of_robots(bigint, bigint, bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.inc_spacing_of_robots(bigint, bigint, bigint, bigint, bigint, bigint)
    IS 'возвращает номер участка пути увеличенное на spr секций';


CREATE OR REPLACE FUNCTION obj_rpart.get_rp_num_of_robots(
    rpid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp RECORD;
BEGIN
    FOR rp IN (
        SELECT num_of_robots FROM repository_part WHERE id = rpid_
    ) LOOP
        RETURN rp.num_of_robots;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_rp_num_of_robots(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_rp_num_of_robots(bigint)
    IS 'сколько в огурце роботов?';


CREATE OR REPLACE FUNCTION obj_rpart.is_track_near_repair_robot(
    rp_id_ bigint,
    npp_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rr RECORD;
    d1 BIGINT;
    d2 BIGINT;
    md BIGINT;
BEGIN
    FOR rr IN (
        SELECT * FROM robot
        WHERE state = obj_robot."ROBOT_STATE_REPAIR"()
        AND repository_part_id = rp_id_
    ) LOOP
        d1 := obj_rpart.calc_distance_by_dir(rp_id_, npp_, rr.current_track_npp, 0);
        d2 := obj_rpart.calc_distance_by_dir(rp_id_ , npp_, rr.current_track_npp, 1);
        md := obj_rpart.get_rp_spacing_of_robots(rp_id_) * (obj_rpart.get_rp_num_of_robots(rp_id_) - 1) * 2 +(obj_rpart.get_rp_num_of_robots(rp_id_) - 1);
        IF (d1 <= md) OR (d2 <= md) THEN
            RETURN 1;
        END IF;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_track_near_repair_robot(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_track_near_repair_robot(bigint, bigint)
    IS 'находится ли трек в шлейфе поломанного робота?';


CREATE OR REPLACE FUNCTION obj_rpart.get_another_robot_id(
    r_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BIGINT;
BEGIN
    SELECT id INTO res
        FROM robot
        WHERE id <> r_id_
        AND repository_part_id = (
            SELECT repository_part_id FROM robot WHERE id = r_id_
        );
    RETURN res;
EXCEPTION WHEN OTHERS THEN
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_another_robot_id(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_another_robot_id(bigint)
    IS 'получить id второго робота';


CREATE OR REPLACE FUNCTION obj_rpart.crash_test_linear_tact(
    )
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    c1_ BIGINT;
    c2_ BIGINT;
    cs cell;
    cd cell;
BEGIN
    SELECT count(*) INTO c1_
        FROM command
        WHERE npp_src BETWEEN 20 AND 25
            AND npp_dest BETWEEN 90 AND 95
            AND state NOT IN (5,2);
    SELECT count(*) INTO c2_
        FROM command
        WHERE npp_dest BETWEEN 20 AND 25
            AND npp_src BETWEEN 90 AND 95
            AND state NOT IN (5,2);
    IF (c1_ < 2) THEN
        FOR cs IN (
            SELECT *
                FROM cell
                WHERE is_full = 1
                    AND track_npp BETWEEN 20 AND 25
                    AND NOT exists(
                        SELECT *
                            FROM cell_cmd_lock
                            WHERE cell_id = cell.id
                    )
                ORDER BY random()
        ) LOOP
            FOR cd IN (
                SELECT *
                    FROM cell
                    WHERE is_full = 0
                        AND hi_level_type = 1
                        AND track_npp BETWEEN 90 AND 95
                        AND cell_size = cs.cell_size
                        AND NOT exists(
                            SELECT *
                                FROM cell_cmd_lock
                                WHERE cell_id = cell.id
                        )
                    ORDER BY random()
            ) LOOP
                INSERT INTO command (
                    cell_src_sname, cell_dest_sname
                ) VALUES (
                    cs.sname, cd.sname
                );
                -- COMMIT;
                RETURN;
            END LOOP;
            EXIT;
        END LOOP;
    END IF;
    IF (c2_ < 2) THEN
        FOR cs IN (
            SELECT *
                FROM cell
                WHERE is_full = 1
                    AND track_npp BETWEEN 90 AND 95
                    AND NOT exists(
                        SELECT *
                            FROM cell_cmd_lock
                            WHERE cell_id = cell.id
                    )
                ORDER BY random()
        ) LOOP
            FOR cd IN (
                SELECT *
                    FROM cell
                    WHERE is_full = 0
                        AND hi_level_type = 1
                        AND track_npp BETWEEN 20 AND 25
                        AND NOT exists(
                            SELECT *
                                FROM cell_cmd_lock
                                WHERE cell_id = cell.id
                        )
                        AND cell_size = cs.cell_size
                    ORDER BY random()
            ) LOOP
                INSERT INTO command (
                    cell_src_sname, cell_dest_sname
                ) VALUES (
                    cs.sname, cd.sname
                );
                -- COMMIT;
                RETURN;
            END LOOP;
            EXIT;
        END LOOP;
    END IF;
    SELECT count(*) INTO c1_
        FROM command
        WHERE npp_src BETWEEN 130 AND 135
            AND npp_dest BETWEEN 200 AND 210
            AND state NOT IN (5,2);
    SELECT count(*) INTO c2_
        FROM command
        WHERE npp_dest BETWEEN 130 AND 135
            AND npp_src BETWEEN 200 AND 210
            AND state NOT IN (5,2);
    IF (c1_ < 2) THEN
        FOR cs IN (
            SELECT *
                FROM cell
                WHERE is_full = 1
                    AND track_npp BETWEEN 130 AND 135
                    AND NOT exists(
                        SELECT *
                            FROM cell_cmd_lock
                            WHERE cell_id = cell.id
                    )
                ORDER BY random()
        ) LOOP
            FOR cd IN (
                SELECT *
                    FROM cell
                    WHERE is_full = 0
                        AND hi_level_type = 1
                        AND track_npp BETWEEN 200 AND 210
                        AND NOT exists(
                            SELECT *
                                FROM cell_cmd_lock
                                WHERE cell_id = cell.id
                        )
                        AND cell_size = cs.cell_size
                    ORDER BY random()
            ) LOOP
                INSERT INTO command (
                    cell_src_sname, cell_dest_sname
                ) VALUES (
                    cs.sname, cd.sname
                );
                -- COMMIT;
                RETURN;
            END LOOP;
            EXIT;
        END LOOP;
    END IF;
    IF (c2_ < 2) THEN
        FOR cs IN (
            SELECT *
                FROM cell
                WHERE is_full = 1
                    AND track_npp BETWEEN 200 AND 210
                    AND NOT exists(
                        SELECT *
                            FROM cell_cmd_lock
                            WHERE cell_id = cell.id
                    )
                ORDER BY random()
        ) LOOP
            FOR cd IN (
                SELECT *
                    FROM cell
                    WHERE is_full = 0
                        AND hi_level_type = 1
                        AND track_npp BETWEEN 130 AND 135
                        AND NOT exists(
                            SELECT *
                                FROM cell_cmd_lock
                                WHERE cell_id = cell.id
                        )
                        AND cell_size = cs.cell_size
                    ORDER BY random()
            ) LOOP
                INSERT INTO command (
                    cell_src_sname, cell_dest_sname
                ) VALUES (
                    cs.sname, cd.sname
                );
                -- COMMIT;
                RETURN;
            END LOOP;
            EXIT;
        END LOOP;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.crash_test_linear_tact() OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.crash_test_linear_tact()
    IS 'линейный такт креш-теста';


CREATE OR REPLACE FUNCTION obj_rpart.crash_test_tact(
    rpid_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cnt BIGINT;
    ci cell;
    cco cell;
BEGIN
    SELECT count(*) INTO cnt
        FROM command
        WHERE command_type_id = 1
            AND rp_src_id = rpid_
            AND rp_dest_id = rpid_
            AND state NOT IN (5,2);
    IF cnt <= 5 THEN -- есть куда напхать команд
        -- сколько свободных ячеек универсальных
        SELECT count(*) INTO cnt
            FROM cell
            WHERE hi_level_type = 1
                AND is_full = 0
                AND repository_part_id = rpid_
                AND NOT exists(
                    SELECT *
                        FROM cell_cmd_lock
                        WHERE cell_id = cell.id
                );
        IF (cnt >= 1) THEN
            FOR ci IN (
                SELECT *
                    FROM cell
                    WHERE hi_level_type = 1
                        AND is_full = 0
                        AND repository_part_id = rpid_
                        AND NOT exists(
                            SELECT *
                                FROM cell_cmd_lock
                                WHERE cell_id = cell.id
                        )
                    ORDER BY random()
            ) LOOP
                FOR cco IN (
                    SELECT *
                        FROM cell
                        WHERE hi_level_type = 1
                            AND is_full >= 1
                            AND repository_part_id = rpid_
                            AND NOT exists(
                                SELECT *
                                    FROM cell_cmd_lock
                                    WHERE cell_id = cell.id
                            )
                        ORDER BY /*abs(track_npp-ci.track_npp) desc,*/ random()
                ) LOOP
                    INSERT INTO command (
                        command_type_id, rp_src_id, cell_src_sname,
                        rp_dest_id, cell_dest_sname, priority, container_id
                    ) VALUES (
                        1, rpid_, cco.sname,
                        rpid_, ci.sname, 1, 0
                    );
                    EXIT;
                END LOOP;
                EXIT;
            END LOOP;
        END IF;
    END IF;
    -- COMMIT;
END;
$BODY$;
ALTER FUNCTION obj_rpart.crash_test_tact(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.crash_test_tact(bigint)
    IS 'креш-тест робота по огурцу - такт';


CREATE OR REPLACE FUNCTION obj_rpart.crash_test_rzn(
    )
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cnt BIGINT;
    rpid_ BIGINT;
    ci cell;
    cco cell;
BEGIN
    rpid_ := 1;
    SELECT count(*) INTO cnt
        FROM command
        WHERE command_type_id = 1
            AND state NOT IN (5,2);
    IF (cnt <= 5) THEN -- есть куда напхать команд
        cnt := random();
        IF (cnt < 0.3) THEN -- приход
            -- сколько свободных ячеек приема
            SELECT count(*) INTO cnt
                FROM cell
                WHERE hi_level_type = 9
                    AND repository_part_id = rpid_
                    AND NOT exists(
                        SELECT *
                            FROM cell_cmd_lock
                            WHERE cell_id = cell.id
                    );
            IF (cnt >= 1) THEN
                FOR ci IN (
                    SELECT *
                        FROM cell
                        WHERE hi_level_type = 9
                            AND repository_part_id = rpid_
                            AND NOT exists(
                                SELECT *
                                    FROM cell_cmd_lock
                                    WHERE cell_id = cell.id
                            )
                        ORDER BY random()
                ) LOOP
                    FOR cco IN (
                        SELECT *
                            FROM cell
                            WHERE hi_level_type = 1
                                AND is_full <= 0
                                AND repository_part_id = rpid_
                                AND NOT exists(
                                    SELECT *
                                        FROM cell_cmd_lock
                                        WHERE cell_id = cell.id
                                )
                            ORDER BY /*abs(track_npp-ci.track_npp) desc,*/ random()
                    ) LOOP
                        INSERT INTO command (
                            command_type_id, rp_src_id, cell_src_sname,
                            rp_dest_id, cell_dest_sname, priority, container_id
                        ) VALUES (
                            1, rpid_, ci.sname,
                            rpid_, cco.sname, 1, 0
                        );
                        EXIT;
                    END LOOP;
                    EXIT;
                END LOOP;
            END IF;
        ELSIF (cnt >= 0.6) THEN -- расход
            SELECT count(*) INTO cnt
                FROM cell
                WHERE hi_level_type = 15
                    AND is_full <= 0
                    AND repository_part_id = rpid_
                    AND NOT exists(
                        SELECT *
                            FROM cell_cmd_lock
                            WHERE cell_id = cell.id
                    );
            IF (cnt >= 1) THEN
                FOR ci IN (
                    SELECT *
                        FROM cell
                        WHERE hi_level_type = 15
                            AND is_full <= 0
                            AND repository_part_id = rpid_
                            AND NOT exists(
                                SELECT *
                                    FROM cell_cmd_lock
                                    WHERE cell_id = cell.id
                            )
                        ORDER BY random()
                ) LOOP
                    FOR cco IN (
                        SELECT *
                            FROM cell
                            WHERE hi_level_type = 1
                                AND is_full > 0
                                AND repository_part_id = rpid_
                                AND NOT exists(
                                    SELECT *
                                        FROM cell_cmd_lock
                                        WHERE cell_id = cell.id
                                )
                            ORDER BY /*abs(track_npp-ci.track_npp) desc,*/ random()
                    ) LOOP
                        INSERT INTO command (
                            command_type_id, rp_src_id, cell_src_sname,
                            rp_dest_id, cell_dest_sname, priority, container_id
                        ) VALUES (
                            1, rpid_, cco.sname,
                            rpid_, ci.sname, 1, 0
                        );
                        EXIT;
                    END LOOP;
                    EXIT;
                END LOOP;
            END IF;
        ELSE -- возврат
            -- сколько свободных ячеек универсальных
            SELECT count(*) INTO cnt
                FROM cell
                WHERE hi_level_type = 15
                    AND is_full > 0
                    AND repository_part_id = rpid_
                    AND NOT exists(
                        SELECT *
                            FROM cell_cmd_lock
                            WHERE cell_id = cell.id
                    );
            IF (cnt >= 1) THEN
                FOR ci IN (
                    SELECT *
                        FROM cell
                        WHERE hi_level_type = 15
                            AND is_full > 0
                            AND repository_part_id = rpid_
                            AND NOT exists(
                                SELECT *
                                    FROM cell_cmd_lock
                                    WHERE cell_id = cell.id
                            )
                        ORDER BY random()
                ) LOOP
                    FOR cco IN (
                        SELECT *
                            FROM cell
                            WHERE hi_level_type = 1
                                AND is_full <= 0
                                AND repository_part_id = rpid_
                                AND NOT exists(
                                    SELECT *
                                        FROM cell_cmd_lock
                                        WHERE cell_id = cell.id
                                )
                            ORDER BY /*abs(track_npp-ci.track_npp) desc,*/ random()
                    ) LOOP
                        INSERT INTO command (
                            command_type_id, rp_src_id, cell_src_sname,
                            rp_dest_id, cell_dest_sname, priority, container_id
                        ) VALUES (
                            1, rpid_, ci.sname,
                            rpid_, cco.sname, 1, 0
                        );
                        EXIT;
                    END LOOP;
                    EXIT;
                END LOOP;
            END IF;
        END IF;
        -- COMMIT;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.crash_test_rzn() OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.crash_test_rzn()
    IS 'креш-тест Рязани';


CREATE OR REPLACE FUNCTION obj_rpart.robot_cmd_rp_change_dir(
    rid_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rr robot;
    crp command_rp;
BEGIN
    FOR rr IN (
        SELECT *
            FROM robot
            WHERE id = rid_
    ) LOOP
        IF coalesce(rr.command_rp_id, 0) <> 0 THEN
            FOR crp IN (
                SELECT *
                    FROM command_rp
                    WHERE id = rr.command_rp_id
            ) LOOP
                IF coalesce(crp.substate, 0) IN (0,1,2) THEN
                    UPDATE command_rp
                        SET direction_1 = obj_rpart.get_another_direction(direction_1)
                        WHERE id = crp.id;
                ELSIF coalesce(crp.substate, 0) IN (3,4) THEN
                    UPDATE command_rp
                        SET direction_2 = obj_rpart.get_another_direction(direction_2)
                        WHERE id = crp.id;
                ELSE
                    PERFORM obj_robot.log(rid_, 'ERROR - пришла смена направления, а substate команды ' || crp.substate);
                END IF;
                RETURN;
            END LOOP;
            PERFORM obj_robot.log(rid_, 'ERROR - пришла смена направления, а команда не найдена');
            RETURN;
        END IF;
        PERFORM obj_robot.log(rid_,'ERROR - пришла смена направления, а команда за роботом незакреплена ');
        RETURN;
    END LOOP;
    PERFORM obj_robot.log(rid_, 'ERROR - пришла смена направления, а робот ' || rid_ || ' не найден!');
END;
$BODY$;
ALTER FUNCTION obj_rpart.robot_cmd_rp_change_dir(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.robot_cmd_rp_change_dir(bigint)
    IS 'сменить направление команды перемещения контейнера для конкретного робота';


CREATE OR REPLACE FUNCTION obj_rpart.check_new_robot_npp_correct(
    rid_ bigint,
    npp_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp_id__ BIGINT;
    rpcs__ BIGINT;
    errm__ TEXT;
    cnt__ BIGINT;
    sor__ BIGINT;
    rp repository_part;
    rr robot;
    nchp command_inner;
BEGIN
    PERFORM obj_robot.log(rid_, 'Check_New_Robot_Npp_Correct - начало npp_=' || npp_);
    rp_id__ := obj_robot.get_robot_rp_id(rid_);
    --log(rp_id__,'Check_New_Robot_Npp_Correct - начало ');
    rpcs__ := obj_rpart.get_rp_command_state(rp_id__);
    IF (rpcs__ = 0) THEN  -- вариант, когда команд нет
        PERFORM obj_robot.log(rid_, '    RPCS__=0 - команд нет');
        --obj_robot.log(rid_,'  RPCS__=0 - команд нет');
        SELECT count(*) INTO cnt__
            FROM track
            WHERE locked_by_robot_id = rid_;
        --obj_robot.log(rid_,'  cnt__='||cnt__);
        IF (cnt__ = 0) THEN -- новый робот встает на путь
            PERFORM obj_rpart.log(rp_id__,'Ставим нового робота ' || rid_ || ' на путь!');
            IF obj_rpart.try_track_lock_robot_around(rid_, npp_) = 1 then
                PERFORM obj_rpart.log(rp_id__,'  успешно заблокировали вокруг нового робота ' || rid_);
            ELSE
                errm__ := '  ERROR - не могу заблокировать путь для нового робота ' || rid_;
                PERFORM obj_rpart.log(rp_id__, errm__);
                RAISE EXCEPTION '%', errm__
                    USING errcode = 50012;
            END IF;
        ELSE -- уже есть что-то заблокированное этим роботом
            FOR rp IN (
                SELECT *
                    FROM repository_part
                    WHERE id = rp_id__
            ) LOOP
                IF (cnt__ > (rp.spacing_of_robots * 2 + 1)) THEN -- слишком много заблокировано
                    PERFORM obj_rpart.log(rp_id__, '  ERROR - слишком много заблокировано роботом ' || rid_ || '. Поэтому сбрасываем блокировку от этого робота');
                    PERFORM obj_rpart.relock_robot_around(rid_, npp_);
                ELSE -- заблокировано не больше, чем надо. Но там ли?
                    --log(rp_id__,'    спрашиваем Is_Track_Locked_Around ');
                    IF obj_rpart.is_track_locked_around(rid_, npp_) = 0 THEN -- не заблокировано там где надо
                        PERFORM obj_rpart.log(rp_id__,'  ERROR - не заблокировано роботом ' || rid_ || ' вокруг ' || npp_ || '. Поэтому сбрасываем старую блокировку и переблокируем по-новому!');
                        PERFORM obj_rpart.relock_robot_around(rid_, npp_);
                    END IF;
                END IF;
            END LOOP;
        END IF;
    ELSE  -- вариант, когда есть реальные команды
        PERFORM obj_robot.log(rid_,'    Есть реальные команды');
        IF obj_rpart.get_rp_robots_state(rp_id__) = 0 THEN -- все роботы по подскладу простаивают
            PERFORM obj_robot.log(rid_,'    все роботы по подскладу простаивают');
            IF obj_rpart.get_rp_cia_state(rp_id__) = 0 THEN -- нет назначенных команд
                FOR rr IN (
                    SELECT *
                        FROM robot
                        WHERE id = rid_
                            AND state = 0
                            AND obj_rpart.is_robot_lock_bad(id) = 1
                ) LOOP
                    IF obj_rpart.is_track_locked_around(rr.id, npp_, 1) = 1 THEN -- теоретически можно заблокировать
                        errm__ := 'ERROR - для робота ' || rr.id || ' плохая блокировка, но можно попытаться восстановить';
                        PERFORM obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT_RP"(), rp_id__, rr.id, errm__);
                        PERFORM obj_rpart.log(rp_id__, errm__);
                        PERFORM obj_rpart.relock_robot_around(rr.id, npp_);
                    ELSE
                        errm__ := 'ERROR - для робота ' || rr.id || ' плохая блокировка, восстановить нельзя, т.к. заблокировано иным роботом ' || npp_;
                        PERFORM obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT_RP"(), rp_id__, rr.id, errm__);
                        PERFORM obj_rpart.log(rp_id__, errm__);
                    END IF;
                END LOOP;
            ELSE -- есть назначенные команды, действуем аккуратней!
                -- роботы без cmd_inner стоящие
                FOR rr IN (
                    SELECT *
                        FROM robot
                        WHERE id = rid_
                            AND state = 0
                            AND obj_rpart.is_robot_lock_bad(id) = 1
                            AND coalesce(command_inner_assigned_id, 0) = 0
                ) LOOP
                    IF obj_rpart.is_track_locked_around(rr.id, npp_) = 0  THEN
                        IF obj_rpart.is_track_locked_around(rr.id, npp_, 1) = 1 THEN
                            errm__ := 'ERROR - для робота ' || rr.id || ' плохая блокировка и есть команды RP, но можно попытаться восстановить';
                            PERFORM obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT_RP"(), rp_id__, rr.id, errm__);
                            PERFORM obj_rpart.log(rp_id__, errm__);
                            PERFORM obj_rpart.relock_robot_around(rr.id, npp_);
                            DELETE FROM track_order
                                WHERE robot_id = rr.id;
                        ELSE
                            errm__ := 'ERROR - для робота ' || rr.id || ' плохая блокировка, восстановить нельзя, т.к. заблокировано иным роботом ' || npp_;
                            PERFORM obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT_RP"(), rp_id__, rr.id, errm__);
                            PERFORM obj_rpart.log(rp_id__, errm__);
                        END IF;
                    END IF;
                END LOOP;
                -- роботы в режиме решения проблемы стоящие, и без промежуточных точек
                FOR rr IN (
                    SELECT *
                        FROM robot
                        WHERE id = rid_
                            AND state = 0
                            /*and is_robot_lock_bad(id)=1*/
                            AND coalesce(command_inner_id, 0) <> 0
                            AND coalesce(wait_for_problem_resolve, 0) = 1
                ) LOOP
                    IF obj_rpart.is_track_locked_around(rr.id, npp_) = 0 THEN
                        IF obj_rpart.is_track_locked_around(rr.id, npp_, 1) = 1 THEN
                            errm__ := 'ERROR - для робота в режиме решения проблемы ' || rr.id || ' плохая блокировка, но можно попытаться восстановить';
                            PERFORM obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT_RP"(), rp_id__, rr.id, errm__);
                            PERFORM obj_rpart.log(rp_id__, errm__);
                            PERFORM obj_rpart.relock_robot_around(rr.id, npp_);
                            -- если команда не использует промежуточные точки
                            FOR nchp IN (
                                SELECT *
                                    FROM command_inner
                                    WHERE id = rr.command_inner_id
                                        AND check_point IS null
                            ) LOOP
                                DELETE FROM track_order
                                    WHERE robot_id = rr.id;
                            END LOOP;
                        -- а теперь блокировки до цели
                        ELSE
                            errm__ := 'ERROR - для робота ' || rr.id || ' плохая блокировка, восстановить нельзя, т.к. заблокировано иным роботом ' || npp_;
                            PERFORM obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT_RP"(), rp_id__, rr.id, errm__);
                            PERFORM obj_rpart.log(rp_id__, errm__);
                        END IF;
                    END IF;
                END LOOP;
            END IF;
        ELSE  -- не все роботы проставимвают
            FOR rr IN (
                SELECT *
                    FROM robot
                    WHERE id = rid_
                        AND coalesce(command_inner_id, 0) = 0
                        AND coalesce(command_inner_assigned_id, 0) = 0
                        AND state = 0
                        AND obj_rpart.is_robot_lock_bad(id) = 1
            ) LOOP
                PERFORM obj_robot.log(rid_,'    Робот стоит без команд и с плохой блокировкой, переблокируем!');
                PERFORM obj_rpart.relock_robot_around(rid_, npp_);
            END LOOP;
        END IF;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.check_new_robot_npp_correct(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.check_new_robot_npp_correct(bigint, bigint)
    IS 'проверяем корректность нахождения робота в треке, если что не так, то raise';


CREATE OR REPLACE FUNCTION obj_rpart.check_wpr_lock(
    rpid_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    ci_npp_dest_ BIGINT;
    lt_ BIGINT;
    brr_ BIGINT;
    errm_ TEXT;
    new_dir_ BIGINT;
    rr robot;
    ci command_inner;
BEGIN
    --return;
    FOR rr IN (
        SELECT *
            FROM robot
            WHERE coalesce(wait_for_problem_resolve, 0) = 1
                AND repository_part_id = rpid_
    ) LOOP
        FOR ci IN (
            SELECT *
                FROM command_inner
                WHERE id = rr.command_inner_id
        ) LOOP
            ci_npp_dest_ := obj_robot.get_cmd_inner_npp_dest(ci.id, 1);
            IF obj_rpart.is_track_locked(rr.id, ci_npp_dest_, ci.direction) = 0 THEN
                PERFORM obj_robot.log(rr.id, 'Ошибка проверки блокировки робота, находящегося в режиме ожидания решения проблемы is_track_locked(' || rr.id
                        || ', ' || ci_npp_dest_
                        || ', ' || ci.direction
                        || ')=0');
                IF obj_rpart.is_track_locked(rr.id, ci_npp_dest_, ci.direction, 1) = 1 THEN
                    PERFORM obj_robot.log(rr.id, '  но можно заблокировать до куда надо');
                    SELECT *
                        INTO brr_, lt_
                        FROM obj_rpart.try_track_lock(rr.id, ci_npp_dest_, ci.direction, true);
                    IF lt_ <> ci_npp_dest_ THEN
                        errm_ := '  ERROR - говорит, что можно заблокировать, а не блокирует, пытается только до ' || lt_;
                        PERFORM obj_robot.log(rr.id, errm_);
                        RAISE EXCEPTION '%', errm_
                            USING errcode = 50012;
                    END IF;
                ELSE
                    PERFORM obj_robot.log(rr.id, '  и нельзя заблокировать куда надо, меняем');
                    new_dir_ := obj_rpart.get_another_direction(ci.direction);
                    IF obj_rpart.is_track_locked(rr.id, ci_npp_dest_, new_dir_) = 1 THEN
                        PERFORM obj_robot.log(rr.id, '  в другом направлении и так заблокировано, просто меняем направление команды, которая в ожидании решении проблемы');
                        PERFORM obj_robot.change_wpr_dir(ci.id, new_dir_);
                    ELSE
                        IF obj_rpart.is_track_locked(rr.id, ci_npp_dest_, new_dir_, 1) = 1 THEN
                            PERFORM obj_robot.log(rr.id,'  но можно заблокировать до куда надо c другой стороны');
                            SELECT *
                                INTO brr_, lt_
                                FROM obj_rpart.try_track_lock(rr.id, ci_npp_dest_, new_dir_, true);
                            IF lt_ <> ci_npp_dest_ THEN
                                errm_ := '  ERROR - говорит, что можно заблокировать с другой стороны, а не блокирует, пытается только до ' || lt_;
                                PERFORM obj_robot.log(rr.id, errm_);
                                RAISE EXCEPTION '%', errm_
                                    USING errcode = 50012;
                            END IF;
                            PERFORM obj_robot.change_wpr_dir(ci.id, new_dir_);
                        ELSE
                            errm_ := '  ERROR - нельзя заблокировать ни с какой из сторон для робота, находящегося в режиме решения проблемы';
                            PERFORM obj_robot.log(rr.id, errm_);
                            RAISE EXCEPTION '%', errm_
                                USING errcode = 50012;
                        END IF;
                    END IF;
                END IF; -- maybe_locked_ number default 0, check_ask_1_robot number default 0) return number is
            END IF;
        END LOOP;
    END LOOP;
    -- COMMIT;
END;
$BODY$;
ALTER FUNCTION obj_rpart.check_wpr_lock(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.check_wpr_lock(bigint)
    IS 'проверяем на корректность блокировки для команд роботов, которые находятся в ожидании решения проблемы';


CREATE OR REPLACE FUNCTION obj_rpart.is_track_npp_ban_move_to(
    rp_id_ bigint,
    npp_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res_ BIGINT;
BEGIN
    SELECT coalesce(ban_move_to, 0) INTO res_ FROM track WHERE repository_part_id = rp_id_ AND npp = npp_;
    RETURN res_;
EXCEPTION WHEN OTHERS THEN
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_track_npp_ban_move_to(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_track_npp_ban_move_to(bigint, bigint)
    IS 'является ли трек запрещенным для команд Move туда?';


CREATE OR REPLACE FUNCTION obj_rpart.is_track_part_between(
    to_id_ bigint,
    npp_from bigint,
    npp_to bigint,
    dir bigint)
    RETURNS boolean
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    to_ RECORD;
BEGIN
    FOR to_ IN (SELECT * FROM track_order WHERE to_id_ = id) LOOP
        -- ->->
        IF ((to_.direction = 1) AND (dir = 1)) THEN -- заявка по часовой стеклки и часть трека по часовой стрелки
            IF (to_.npp_to < to_.npp_from) THEN -- заявка с перехлестом через 0
                IF (npp_to < npp_from) THEN -- участок с перехлестом через 0
                    RETURN true; -- оба перехлеста
                ELSE -- участок без перехлеста через 0
                    RETURN (npp_to >= to_.Npp_From) -- участок вначале попадает
                        OR (npp_from <= to_.Npp_To); -- участок вконце попадает
                END IF;
            ELSE -- без перехлеста через 0
                IF (npp_to < npp_from) THEN -- с перехлестом через 0
                    RETURN (npp_from <= to_.npp_to) -- участок сначала задевает заявку
                        OR (npp_to >= to_.npp_from); -- участок в конце задевает заявку
                ELSE -- без перехлеста через 0
                    RETURN (npp_to >= to_.npp_from AND npp_from <= to_.npp_from) -- участок вначале попадает
                        OR (npp_from >= to_.npp_from AND npp_to <= to_.npp_to) -- участок целиком попадает
                        OR (npp_from <= to_.npp_to AND npp_to >= to_.npp_to); -- участок справа попадает
                END IF;
            END IF;
        -- <-<-
        ELSIF ((to_.direction = 0) AND (dir = 0)) THEN -- заявка против часовой стрелки и часть трека против часовой стрелки
            IF (to_.npp_to < to_.npp_from) THEN -- заявка без перехлеста через 0
                IF (npp_to < npp_from) THEN -- участок без перехлеста через 0
                    RETURN (npp_from >= to_.npp_to AND npp_to <= to_.npp_to) -- участок слева попадает
                        OR (npp_from <= to_.npp_from AND npp_to >= to_.npp_to) -- участок целиком попадает
                        OR (npp_from >= to_.npp_from AND npp_to <= to_.npp_from); -- участок справа попадает
                ELSE -- с перехлестом участок через 0
                    RETURN (npp_from >= to_.npp_to) -- участок сначала задевает заявку
                        OR (npp_to <= to_.npp_from); -- участок в конце задевает заявку
                END IF;
            ELSE -- заявка с перехлестом через 0
                IF (npp_to < npp_from) THEN -- участок без перехлеста через 0
                    RETURN (npp_to <= to_.npp_from) -- участок вначале попадает
                        OR (npp_from >= to_.npp_to); -- участок вконце попадает
                ELSE -- с перехлестом участок через 0
                    RETURN true;
                END IF;
            END IF;
        -- -><-
        ELSIF ((to_.direction = 1) AND (dir = 0)) THEN -- заявка по часовой стрелки , а часть трека против часовой стрелки
            IF (to_.npp_to < to_.npp_from) THEN -- заявка с перехлестом через 0
                IF (npp_to < npp_from) THEN -- участок без перехлеста через 0
                    RETURN (npp_from >= to_.npp_from) -- участок слева попадает
                        OR (npp_to <= to_.npp_to); -- участок справа попадает
                ELSE -- участок с перехлестом через 0
                    RETURN true;
                END IF;
            ELSE -- заявка без перехлеста через 0
                IF (npp_to < npp_from) THEN -- участок без перехлеста через 0
                    RETURN (npp_from >= to_.npp_from AND npp_to <= to_.npp_to); -- участок попадает
                ELSE -- участок с перехлестом через 0
                    RETURN (npp_from >= to_.npp_from) -- участок слева попадает
                        OR (npp_to <= to_.npp_to); -- участок справа попадает
                END IF;
            END IF;
        -- <-->
        ELSIF ((to_.direction = 0) AND (dir = 1)) THEN -- заявка против часовой стрелки , а часть трека по часовой стрелки
            IF (to_.npp_to < to_.npp_from) THEN -- заявка без перехлеста через 0
                IF (npp_to < npp_from) THEN -- участок c перехлестом через 0
                    RETURN (npp_to >= to_.npp_to) -- участок слева попадает
                        OR (npp_from <= to_.npp_from); -- участок справа попадает
                ELSE -- участок без перехлеста через 0
                    RETURN (npp_from <= to_.npp_from AND npp_to >= to_.npp_from) -- участок справа попадает
                        OR (npp_from >= to_.npp_to AND npp_to <= to_.npp_from) -- участок целиком попадает
                        OR (npp_to >= to_.npp_to AND npp_from <= to_.npp_to); -- участок справа попадает
                END IF;
            ELSE -- заявка c перехлестом через 0
                IF (npp_to < npp_from) THEN -- участок c перехлестом через 0
                    RETURN true;
                ELSE -- участок без перехлеста через 0
                    RETURN (npp_from <= to_.npp_from) -- участок слева попадает
                        OR (npp_to >= to_.npp_to); -- участок справа попадает
                END IF;
            END IF;
        END IF;
    END LOOP;
    RETURN false; -- сюда дойти не должно вроде как
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_track_part_between(bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_track_part_between(bigint, bigint, bigint, bigint)
    IS 'является ли указанная заявка на блокировку между указанными треками по заданному направлению?';


CREATE OR REPLACE FUNCTION obj_rpart.is_track_locked(
    robot_id_ in bigint,
    npp_d bigint,
    dir bigint,
    maybe_locked_ bigint default 0,
    check_ask_1_robot bigint default 0)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    r RECORD;
    rp RECORD;
    cnpp BIGINT;
    ll BIGINT;
    dnppsorb BIGINT;
    is_dest_npp_reached BOOLEAN;
BEGIN
    is_dest_npp_reached := false;
    FOR r IN (SELECT * FROM robot WHERE id = robot_id_) LOOP
        PERFORM obj_rpart.log(r.repository_part_id, ' is_track_locked robot_id_=' || robot_id_ || ' npp_d=' || npp_d || ' dir=' || dir);
        FOR rp IN (
            SELECT repository_type, id, max_npp, spacing_of_robots sorb, num_of_robots
                FROM repository_part rp
                WHERE id=r.repository_part_id
        ) LOOP
            IF (check_ask_1_robot = 0) AND (rp.num_of_robots = 1) THEN -- один робот - всегда все свободно
                RETURN 1;
            END IF;
            cnpp := r.current_track_npp;
            RAISE NOTICE '  cnpp=%', cnpp;
            SELECT locked_by_robot_id INTO ll FROM track WHERE repository_part_id = rp.id AND npp = cnpp;
            IF (cnpp = npp_d) AND (ll = robot_id_) /*or maybe_locked_=1 and ll=0)*/ THEN
                RETURN 1; -- там же и стоим
            END IF;
            -- считаем максимум сколько нужно хапануть
            dnppsorb := obj_rpart.add_track_npp(rp.id, npp_d,rp.sorb, dir);
            IF (obj_rpart.is_track_npp_ban_move_to(rp.id, npp_d) = 1) THEN
                dnppsorb := obj_rpart.add_track_npp(rp.id, dnppsorb, 1, dir);
            END IF;
            LOOP
                IF cnpp=npp_d THEN
                    is_dest_npp_reached:=true;
                END IF;
                EXIT WHEN cnpp=dnppsorb AND is_dest_npp_reached;
                IF (dir = 1) THEN -- по часовой
                    IF (rp.repository_type = 1) THEN -- для кольцевого склада
                        IF (cnpp = rp.max_npp) THEN
                            cnpp := 0;
                        ELSE
                            cnpp := cnpp + 1;
                        END IF;
                    ELSE -- для линейного
                        IF (cnpp < rp.max_npp) THEN
                            cnpp := cnpp + 1;
                        ELSE
                            EXIT; -- выход из цикла
                        END IF;
                    END IF;
                ELSE -- против
                    IF (rp.repository_type = 1) THEN -- для кольцевого склада
                        IF (cnpp = 0) THEN
                            cnpp := rp.max_npp;
                        ELSE
                            cnpp := cnpp - 1;
                        END IF;
                    ELSE -- для линейного
                        IF (cnpp > 0) THEN
                            cnpp := cnpp - 1;
                        ELSE
                            EXIT; -- выход из цикла
                        END IF;
                    END IF;
                END IF;
                SELECT locked_by_robot_id INTO ll FROM track WHERE repository_part_id = rp.id AND npp = cnpp;
                IF (ll <> r.id) AND (maybe_locked_ = 0) THEN -- ошибка
                    RETURN 0; -- путь не готов - ОШИБКА!!!
                ELSIF (ll NOT IN (r.id, 0)) AND (maybe_locked_ = 1) THEN
                    RETURN 0; -- путь не готов - ОШИБКА!!!
                END IF;
            END LOOP;
        END LOOP;
    END LOOP;
    RETURN 1; -- все проверено, мин нет
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_track_locked(bigint, bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_track_locked(bigint, bigint, bigint, bigint, bigint)
    IS 'интеллектуальная функция определения - заблокирован ли трек? (учитывает шлейф робота)';


CREATE OR REPLACE FUNCTION obj_rpart.form_track_order(
    rid_ bigint,
    npp_from_ bigint,
    npp_to_ bigint,
    dir_ bigint,
    robot_stop_id_ bigint)
    RETURNS boolean
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    r RECORD;
    tt RECORD;
    cnt BIGINT;
    nor_ BIGINT;
BEGIN
    FOR r IN (SELECT * FROM robot WHERE id = rid_) LOOP
        PERFORM obj_rpart.log(r.repository_part_id, 'Пришла заявка на трек от робота ' || rid_
            || ' NPP_FROM=' || NPP_FROM_
            || ' NPP_TO=' || NPP_TO_
            || ' dir=' || dir_
            || ' robot_stop_id_=' || robot_stop_id_);
        -- первым делом проверяем, а нет ли уже заявки от этого же робота
        FOR tt IN (SELECT * FROM track_order WHERE repository_part_id = r.repository_part_id AND rid_ = robot_id) LOOP
            PERFORM obj_rpart.log(r.repository_part_id, 'ERROR - попытка заявки, когда уже есть заявка от робота ' || rid_
                || ' NPP_FROM=' || tt.NPP_FROM
                || ' NPP_TO=' || tt.NPP_TO
                || ' DIRECTION=' || tt.DIRECTION
                || ' robot_stop_id=' || tt.robot_stop_id);
            RETURN true;
        END LOOP;
        SELECT count(*) INTO cnt FROM track_order WHERE repository_part_id = r.repository_part_id;
        SELECT num_of_robots INTO nor_ FROM repository_part WHERE id = r.repository_part_id;
        IF (cnt >= nor_ - 1) THEN
            PERFORM obj_rpart.log(r.repository_part_id, 'ERROR - слишком много заявок по подскладу, отбой!');
            RETURN false;
        END IF;
        FOR tt IN (SELECT * FROM track_order WHERE repository_part_id = r.repository_part_id) LOOP
            IF (robot_stop_id_ = tt.robot_stop_id) THEN
                PERFORM obj_rpart.log(r.repository_part_id, 'ERROR - попытка второй заявки на одного мешающего робота');
                RETURN false;
            END IF;
            IF (robot_stop_id_ = tt.robot_id) THEN
                PERFORM obj_rpart.log(r.repository_part_id, 'ERROR - попытка ранее инициировавшего заявку робота выставить мешающим');
                RETURN false;
            END IF;
            IF (tt.direction <> dir_) AND obj_rpart.is_track_part_between(tt.id, npp_from_, npp_to_, dir_) THEN
                PERFORM obj_rpart.log(r.repository_part_id, 'ERROR - попытка добавить встречную мешающую заявку');
                RETURN false;
            END IF;
        END LOOP;
        INSERT INTO track_order(robot_id, repository_part_id, npp_from, npp_to, direction, robot_stop_id)
            VALUES (rid_, r.repository_part_id, npp_from_, npp_to_, dir_, robot_stop_id_);
    END LOOP;
    RETURN true;
END;
$BODY$;
ALTER FUNCTION obj_rpart.form_track_order(bigint, bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.form_track_order(bigint, bigint, bigint, bigint, bigint)
    IS 'неинтеллектуальный запрос формирования заявки на блокировку трека';


CREATE OR REPLACE FUNCTION obj_rpart.is_poss_ass_new_unload_cell(
    old_cell_id bigint,
    robot_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res RECORD;
    cellrec cell;
    dir BIGINT;
BEGIN
    res := obj_rpart.try_assign_new_unload_cell(old_cell_id, robot_id_, cellrec, dir);
    cellrec := res.cellrec;
    IF cellrec.id IS null THEN
        RETURN 0;
    ELSE
        RETURN 1;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_poss_ass_new_unload_cell(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_poss_ass_new_unload_cell(bigint, bigint)
    IS 'можно ли назначить новую ячейку для выгрузки контейнера?';


CREATE OR REPLACE FUNCTION obj_rpart.try_assign_new_unload_cell(
    old_cell_id bigint,
    robot_id_ bigint,
    INOUT cellrec cell,
    INOUT dir bigint)
    RETURNS record
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    old_cell cell;
    appr_cell cell;
    cnt BIGINT;
    rpt BIGINT;
    cnpp BIGINT;
    cnpp_sorb BIGINT;
    max_npp_ BIGINT;
    delta1 BIGINT;
    delta0 BIGINT;
    sorb BIGINT;
    rp_id_ BIGINT;
    was_found BIGINT;
BEGIN
    SELECT * INTO old_cell FROM cell WHERE id = old_cell_id;
    -- если ничего не нашли - Null возвращаем
    cellrec.id := null;
    cellrec.sname := null;
    dir := -1;
    -- а вдруг в той же секции есть местечко
    FOR appr_cell IN (
        SELECT *
            FROM cell
            WHERE repository_part_id = old_cell.repository_part_id
                AND cell_size = old_cell.cell_size
                AND is_full = 0
                AND (
                    (hi_level_type = 1 AND zone_id <> 0) OR hi_level_type = 10
                )
                AND is_error = 0
                AND service.is_cell_cmd_locked(id) = 0
                AND id <> old_cell_id
                AND track_npp = old_cell.track_npp
    ) LOOP
        PERFORM obj_rpart.log(
            appr_cell.repository_part_id,
            'try_assign_new_unload_cell - нашли в текущей секции ' || appr_cell.sname
        );
        cellrec := appr_cell;
        dir := 1;
        RETURN;
    END LOOP;
    -- раз дошли до сюда, значит нет свободного места в текущей секции
    PERFORM obj_rpart.log(
        old_cell.repository_part_id,
        'try_assign_new_unload_cell - нет свободного места в текущей секции'
    );
    SELECT max_npp, spacing_of_robots, id, repository_type
        INTO max_npp_, sorb, rp_id_, rpt
        FROM repository_part
        WHERE id = (
            SELECT repository_part_id
                FROM robot
                WHERE id = robot_id_
        );
    delta1 := 0;
    delta0 := 0;
    FOR dir_f IN 0..1 LOOP
        was_found := 0;
        cnpp := old_cell.track_npp;
        cnpp_sorb := obj_rpart.inc_spacing_of_robots(cnpp, dir_f, sorb, rp_id_, 0, max_npp_);
        LOOP -- цикл по направлению
            IF (dir_f = 0) THEN -- против часовой
                IF (rpt = 0) THEN -- линейный
                    EXIT WHEN cnpp = 0;
                END IF;
                delta0 := delta0 + 1;
            ELSE -- по часовой
                IF (rpt = 0) THEN -- линейный
                    EXIT WHEN cnpp = max_npp_;
                END IF;
                delta1 := delta1 + 1;
            END IF;
            cnpp_sorb := obj_rpart.inc_spacing_of_robots(cnpp_sorb, dir_f, 1, rp_id_, 0, max_npp_);
            cnpp      := obj_rpart.inc_spacing_of_robots(cnpp,      dir_f, 1, rp_id_, 0, max_npp_);
            SELECT count(*) INTO cnt
                FROM track
                WHERE repository_part_id = rp_id_
                    AND npp = cnpp_sorb
                    AND locked_by_robot_id IN (0,robot_id_);
            IF (cnt > 0) THEN -- трэк свободен
                FOR appr_cell IN (
                    SELECT *
                        FROM cell
                        WHERE repository_part_id = rp_id_
                            AND track_npp = cnpp
                            AND is_full = 0
                            AND cell_size <= old_cell.cell_size
                            AND (
                                (hi_level_type = 1 AND zone_id <> 0) OR hi_level_type = 10
                            )
                            AND id <> old_cell_id
                            AND is_error = 0
                            AND service.is_cell_cmd_locked(id) = 0
                        ORDER BY abs(old_cell.cell_size - cell_size)
                ) LOOP
                    -- ура, есть ячейка
                    PERFORM obj_rpart.log(
                        old_cell.repository_part_id,
                        'try_assign_new_unload_cell - нашли подходящую ячейку ' || appr_cell.sname || ' dir=' || dir_f
                    );
                    was_found := 1;
                    IF (cellrec.id IS null) THEN -- раньше не было - пишем
                        cellrec := appr_cell;
                        dir := dir_f;
                    ELSE --уже было - на 0-вом шаге
                        IF (delta1 < delta0) AND (delta1 <> 0) AND (delta0 <> 0) THEN
                            cellrec := appr_cell;
                            dir := dir_f;
                        END IF;
                    END IF;
                    EXIT;
                END LOOP;
                EXIT WHEN was_found = 1;
            ELSE
                EXIT; -- дальше блокировано - вываливаемся
            END IF;
        END LOOP; -- по направлению одному
    END LOOP; -- по направлениям
END;
$BODY$;
ALTER FUNCTION obj_rpart.try_assign_new_unload_cell(bigint, bigint, cell, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.try_assign_new_unload_cell(bigint, bigint, cell, bigint)
    IS 'пытаемся назначить новую ячейку выгрузки вместо старой';


CREATE OR REPLACE FUNCTION obj_rpart.is_exists_cell_type(
    rp_id_ bigint,
    ct_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BOOLEAN;
BEGIN
    SELECT exists(
        SELECT * FROM cell
        WHERE repository_part_id = rp_id_
        AND hi_level_type = ct_
        AND is_error = 0
    ) INTO res;
    IF res THEN
        RETURN 1;
    END IF;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_exists_cell_type(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_exists_cell_type(bigint, bigint)
    IS 'Checks if there are any cells of specified type that have no erorrs.
есть ли неошибочные ячейки указанного подтипа на складе?';


CREATE OR REPLACE FUNCTION obj_rpart.is_cell_locked_by_repaire(
    cell_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    onp BIGINT;
    cnp BIGINT;
    cc cell;
    rr robot;
    tla track;
    rp RECORD;
BEGIN
    FOR cc IN (
        SELECT *
            FROM cell
            WHERE id = cell_id_
    ) LOOP
        FOR rr IN (
            SELECT *
                FROM robot
                WHERE repository_part_id = cc.repository_part_id
                    AND state = 6
        ) LOOP
            FOR tla IN (
                SELECT *
                    FROM track
                    WHERE repository_part_id = rr.repository_part_id
                        AND locked_by_robot_id = rr.id
                        AND npp = cc.track_npp
            ) LOOP
                RETURN 1;
            END LOOP;
            FOR rp IN (
                SELECT id, spacing_of_robots sor, max_npp
                    FROM repository_part
                    WHERE id = cc.repository_part_id
            ) LOOP
                --cnp:=rr.current_track_npp;
                -- по часовой стрелке
                onp := rr.current_track_npp;
                FOR dir IN 0..1 LOOP
                    FOR delt IN 1..rp.sor*2 LOOP
                        cnp := obj_rpart.inc_spacing_of_robots(rr.current_track_npp, dir,delt, rp.id, 0, rp.max_npp);
                        IF (cnp <> onp) THEN -- чтоб не застряли на туда, куда нельзя пройти
                            IF (cnp = cc.track_npp) THEN
                                RETURN 1;
                            END IF;
                        END IF;
                        onp := cnp;
                    END LOOP;
                END LOOP;
            END LOOP;
        END LOOP;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_cell_locked_by_repaire(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_cell_locked_by_repaire(bigint)
    IS 'заблокирована ли ячейка роботом в состоянии починки?';


CREATE OR REPLACE FUNCTION obj_rpart.change_work_status(
    rpid_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    UPDATE repository_part
        SET is_work = (CASE is_work WHEN 0 THEN 1 ELSE 0 END)
        WHERE id = rpid_;
    -- COMMIT;
END;
$BODY$;
ALTER FUNCTION obj_rpart.change_work_status(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.change_work_status(bigint)
    IS 'меняет статус работа/пауза указанного огурца';


CREATE OR REPLACE FUNCTION obj_rpart.change_cmd_rp_goal(
    cmd_rp_id_ bigint,
    new_cell_dest_id bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    old_rp command_rp;
    cc RECORD;
    crp command_rp;
    cmd command;
    crprec command_rp;
BEGIN
    SELECT * INTO old_rp FROM command_rp WHERE id = cmd_rp_id_;
    FOR cc IN (
        SELECT c.sname, s.track_id, t.npp, hi_level_type
            FROM cell c
            INNER JOIN shelving s
                ON c.shelving_id = s.id
            INNER JOIN track t
                ON s.track_id = t.id
            WHERE c.id = new_cell_dest_id
    ) LOOP
        UPDATE cell_cmd_lock
            SET cell_id = new_cell_dest_id, sname = cc.sname
            WHERE cell_id = old_rp.cell_dest_id
                AND cmd_id = old_rp.command_id;
        UPDATE command_rp
            SET cell_dest_id = new_cell_dest_id,
                cell_dest_sname = cc.sname,
                track_dest_id = cc.track_id,
                npp_dest = cc.npp
            WHERE id = cmd_rp_id_;
        IF (cc.hi_level_type = 1) THEN -- выгружаем на хранение
            FOR crp IN (
                SELECT * FROM command_rp WHERE id = cmd_rp_id_
            ) LOOP
                UPDATE command
                    SET cell_dest_sname=cc.sname,
                        cell_dest_id=new_cell_dest_id,
                        npp_dest=cc.npp,
                        track_dest_id=cc.track_id
                    WHERE id=crp.command_id;
                -- а теперь command_gas правим
                FOR cmd IN (
                    SELECT * FROM command WHERE id = crp.command_id
                ) LOOP
                    UPDATE command_gas
                        SET cell_out_name = cc.sname
                        WHERE command_type_id IN (11,18)
                            AND id = cmd.command_gas_id;
                END LOOP;
            END LOOP;
        ELSE -- особые действия при выгрузке на временное хранение в транзитный склад
            FOR crprec IN (
                SELECT * FROM command_rp WHERE id = cmd_rp_id_
            ) LOOP
                UPDATE command_rp
                    SET cell_src_id = new_cell_dest_id,
                        cell_src_sname = cc.sname,
                        track_src_id = cc.track_id,
                        npp_src = cc.npp
                    WHERE id <> cmd_rp_id_
                        AND command_id = crprec.command_id
                        AND rp_id = crprec.rp_id
                        AND state = 1;
            END LOOP;
        END IF;
    END LOOP;
END;
$BODY$;
ALTER FUNCTION obj_rpart.change_cmd_rp_goal(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.change_cmd_rp_goal(bigint, bigint)
    IS 'назначаем новую целевую ячейки команде перемещения контейнера';


CREATE OR REPLACE FUNCTION obj_rpart.get_transit_1rp_cell(
    rpid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    ncl RECORD;
BEGIN
    FOR ncl IN (
        SELECT * FROM cell
            WHERE repository_part_id = rpid_
            AND is_full = 0
            AND coalesce(blocked_by_ci_id, 0) = 0
            AND service.is_cell_over_locked(id) = 0
            AND coalesce(is_error, 0) = 0
            AND hi_level_type = obj_ask."CELL_TYPE_TRANSIT_1RP"()
    ) LOOP
        RETURN ncl.id;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_transit_1rp_cell(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_transit_1rp_cell(bigint)
    IS 'Returns available transit cell inside specified track
получить id свободной транзитной ячейки для передач внутри одного огурца';


CREATE OR REPLACE FUNCTION obj_rpart.track_lock_prim(
    rpid_ bigint,
    rid_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    UPDATE track
        SET locked_by_robot_id = rid_
        WHERE repository_part_id = rpid_
        AND npp IN (
            SELECT npp FROM tmp_track_lock WHERE rp_id = rpid_
        );
    DELETE FROM tmp_track_lock WHERE rp_id = rpid_;
END;
$BODY$;
ALTER FUNCTION obj_rpart.track_lock_prim(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.track_lock_prim(bigint, bigint)
    IS 'функция примитивной блокировки трека';


CREATE OR REPLACE FUNCTION obj_rpart.move_robot_away_if_ness(
    rpid_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    npp_new__ BIGINT;
    --npp_lock_to__ BIGINT;
    cmd_cell__ TEXT;
    dir__ BIGINT;
    ttl__ BIGINT;
    br_id_ BIGINT;
    rr RECORD;
    ci command_inner;
    cc cell;
BEGIN
    FOR rr IN (
        SELECT r.*, rp.spacing_of_robots sorb
            FROM robot r
            INNER JOIN repository_part rp
                ON r.repository_part_id = rp.id
            WHERE rp.id = rpid_
                AND obj_robot.is_robot_ready_for_cmd(r.id) = 1
                AND obj_rpart.is_active_command_rp(rp.id) = 0
    ) LOOP -- робот свободен и на него не закреплена команда общая
        FOR ci IN (
            SELECT *
                FROM command_inner
                WHERE robot_id = rr.id
                    AND LOCALTIMESTAMP - date_time_create > INTERVAL '3 days'
                ORDER BY id DESC
        ) LOOP -- ищем последнюю команду на этого робота
            IF (ci.command_type_id = 5) THEN -- UNLOAD
                FOR cc IN (
                    SELECT *
                        FROM cell
                        WHERE ci.cell_dest_id = cell.id
                            AND coalesce(move_after_cmd_on_npp, 0) > 0
                ) LOOP
                    PERFORM obj_rpart.log(rpid_, 'Move_Robot_Away_If_Ness - нужно двигать робота ' || rr.id || ' чтоб не мешал отборщику после UNLOAD');
                    npp_new__ := cc.track_npp + cc.move_after_cmd_on_npp;
                    cmd_cell__ := obj_rpart.get_cell_name_by_track_npp(npp_new__, rpid_);
                    IF (cc.move_after_cmd_on_npp > 0) THEN
                        dir__ := 1;
                    ELSE
                        dir__ := 0;
                    END IF;
                    --npp_lock_to__:=add_track_npp(rpid_, npp_new__,rr.sorb, dir__);
                    PERFORM obj_rpart.log(rpid_, '  пытаемся заблокировать до секции ' || npp_new__ || ' роботом ' || rr.id);
                    SELECT *
                        INTO br_id_, ttl__
                        FROM obj_rpart.try_track_lock(rr.id, npp_new__, dir__, false);
                    PERFORM obj_robot.set_command_inner(
                        rr.id, 0, 1, 6,
                        dir__, null, cmd_cell__,
                        obj_robot."CMD_MOVE"() || ' ' || cmd_cell__ || ';' || obj_rpart.get_cmd_dir_text(dir__),
                        0
                    );
                END LOOP;
            END IF;
            EXIT;
        END LOOP;
    END LOOP;
END;
$BODY$;
ALTER FUNCTION obj_rpart.move_robot_away_if_ness(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.move_robot_away_if_ness(bigint)
    IS 'перемещаем робота прочь, если в настройках АСК указано премещать робота после unload';


CREATE OR REPLACE FUNCTION obj_rpart.inity_if_ness(
    rpid_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rr robot;
BEGIN
    FOR rr IN (
        SELECT *
            FROM robot
            WHERE repository_part_id = rpid_
                AND is_present = 1
    ) LOOP
        PERFORM obj_robot.inity_if_ness(rr.id);
    END LOOP;
END;
$BODY$;
ALTER FUNCTION obj_rpart.inity_if_ness(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.inity_if_ness(bigint)
    IS 'дать команду InitY, если нужно';


CREATE OR REPLACE FUNCTION obj_rpart.assign_tmp_cell_any_size(
    rpl_id bigint,
    cmrp_npp_src bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cnt BIGINT;
    cnn RECORD;
BEGIN
    SELECT min(abs((t.npp-cmrp_npp_src))) INTO cnt
        FROM cell c
        INNER JOIN shelving s
            ON c.shelving_id = s.id
        INNER JOIN track t
            ON s.track_id = t.id
        WHERE c.is_full = 0
            AND coalesce(c.blocked_by_ci_id, 0) = 0
            AND hi_level_type = 10
            AND is_error = 0
            AND NOT exists(
                SELECT *
                    FROM cell_cmd_lock
                    WHERE cell_id=c.id
            )
            AND cell_size = 0
            AND t.repository_part_id = rpl_id;
    FOR cnn IN (
        SELECT sname
            FROM cell c
            INNER JOIN shelving s
                ON c.shelving_id = s.id
            INNER JOIN track t
                ON s.track_id = t.id
            WHERE c.is_full = 0
                AND NOT exists(
                    SELECT *
                        FROM cell_cmd_lock
                        WHERE cell_id = c.id
                )
                AND coalesce(c.blocked_by_ci_id, 0) = 0
                AND is_error = 0
                AND cell_size = 0
                AND hi_level_type = 10
                AND t.repository_part_id = rpl_id
                AND abs(t.npp - cmrp_npp_src) = cnt
            ORDER BY orientaition DESC
    ) LOOP
        RETURN cnn.sname;
    END LOOP;
    RETURN '';
END;
$BODY$;
ALTER FUNCTION obj_rpart.assign_tmp_cell_any_size(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.assign_tmp_cell_any_size(bigint, bigint)
    IS 'для транзитного склада взять ячейку большого размера если нет малой.';


CREATE OR REPLACE FUNCTION obj_rpart.group_op_to_simple_crp(
    rp_id_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cnt__ BIGINT;
    cell_to__ TEXT;
    track_id_to__ BIGINT;
    npp_dest_new__ BIGINT;
    cell_id_new_ BIGINT;
    cnt_type__ BIGINT;
    msg_ TEXT;
    otf_ BIGINT;
    cmrp command_rp;
    rowcount__ BIGINT;
    ncell RECORD;
    sqlerrm__ TEXT;
BEGIN
    FOR cmrp IN (
        SELECT /*+RULE*/ cr.*
            FROM command_rp cr
            INNER JOIN cell c
                ON cr.cell_src_id = c.id
            INNER JOIN cell_type ct
                ON c.hi_level_type = ct.id
            WHERE rp_id = rp_id_
                AND state = 1
                AND cr.command_type_id = 7
            ORDER BY priority DESC,
                ct.obligotary_to_free DESC,
                cr.id
    ) LOOP
        PERFORM obj_rpart.log(rp_id_, 'Group_Op_To_Simple_CRP - есть команда для преобразования ' || cmrp.id);
        -- вначале смотрим, есть ли свободная ячейка из группы-приемника
        SELECT obligotary_to_free INTO otf_
            FROM cell_type
            WHERE id = (
                SELECT hi_level_type
                    FROM cell
                    WHERE id = cmrp.cell_src_id
            );
        EXECUTE 'select count(*) ' || cmrp.sql_text_for_group
            INTO cnt__;
        IF (cnt__ <> 0) THEN -- есть подходящие ячейки
            IF (otf_ = 0) THEN -- не обязательно резко освобождать, смотрим, а не заблокировано ли
                EXECUTE 'SELECT count(*)  ' || cmrp.sql_text_for_group || ' AND obj_rpart.is_cell_cmd_track_lock(id) = 0'
                    INTO cnt__;
                IF (cnt__ = 0) THEN
                    PERFORM obj_rpart.log(rp_id_, 'Group_Op_To_Simple_CRP - все заблокировано командами для транзитной передачи для cmd_rp.id=' || cmrp.id);
                    CONTINUE; -- переходим к следующей команде
                END IF;
            END IF;
            EXECUTE 'SELECT sname  ' || cmrp.sql_text_for_group || ' LIMIT 1'
                INTO cell_to__;
            PERFORM obj_rpart.log(rp_id_, '   есть подходящая ячейка ' || cell_to__);
            track_id_to__ := obj_rpart.get_track_id_by_cell_and_rp(cmrp.rp_id, cell_to__);
            npp_dest_new__ := obj_rpart.get_track_npp_by_cell_and_rp(cmrp.rp_id, cell_to__);
            PERFORM obj_rpart.log(rp_id_, '   track_id_to__=' || track_id_to__ || ' npp_dest_new__=' || npp_dest_new__);
            cell_id_new_ := obj_rpart.get_cell_id_by_name(cmrp.rp_id, cell_to__);
            PERFORM obj_rpart.log(rp_id_, '   cell_id_new_=' || cell_id_new_);
            UPDATE command_rp
                SET cell_dest_sname = cell_to__,
                    track_dest_id = track_id_to__,
                    cell_dest_id = cell_id_new_,
                    npp_dest = npp_dest_new__,
                    ideal_cost = coalesce(
                        service.calc_ideal_crp_cost(rp_id, cell_src_id, cell_id_new_),
                        0
                    ),
                    command_type_id = 3
            WHERE id = cmrp.id;
            GET DIAGNOSTICS rowcount__ := ROW_COUNT;
            PERFORM obj_rpart.log(rp_id_,'   успешно закоммитили ' || rowcount__ || ' записей');
            -- COMMIT;
        ELSE
            PERFORM obj_rpart.log(rp_id_, '  fc: все транзитные ячейки заняты ');
            IF (otf_ = 1) THEN
                -- обязательно надо освободить, освобождаем
                -- но вначале определяем тип контейнера на платформе
                PERFORM obj_rpart.log(rp_id_, '  fc: а освобождать надо ');
                BEGIN
                    SELECT coalesce(type, 0) INTO cnt_type__
                        FROM container
                        WHERE id = (
                            SELECT container_id
                                FROM command
                                WHERE id = cmrp.command_id
                        );
                EXCEPTION WHEN others THEN
                    cnt_type__ := 0; -- не знаем какой, считаем, что большой
                END;
                BEGIN
                    cell_to__ := '';
                    SELECT min(abs((t.npp - cmrp.npp_src))) INTO cnt__
                        FROM cell c
                        INNER JOIN shelving s
                            ON c.shelving_id = s.id
                        INNER JOIN track t
                            ON s.track_id = t.id
                        WHERE c.is_full=0
                            AND coalesce(c.blocked_by_ci_id, 0) = 0
                            AND NOT exists(
                                SELECT *
                                    FROM cell_cmd_lock
                                    WHERE cell_id = c.id
                            )
                            AND hi_level_type = 10
                            AND cell_size = cnt_type__
                            AND is_error = 0
                            AND t.repository_part_id = rp_id_;
                    FOR ncell IN (
                        SELECT sname
                            FROM cell c
                            INNER JOIN shelving s
                                ON c.shelving_id = s.id
                            INNER JOIN track t
                                ON s.track_id = t.id
                            WHERE c.is_full = 0
                                AND coalesce(c.blocked_by_ci_id, 0) = 0
                                AND cell_size = cnt_type__
                                AND NOT exists(
                                    SELECT *
                                        FROM cell_cmd_lock
                                        WHERE cell_id = c.id
                                )
                                AND hi_level_type = 10
                                AND NOT exists(
                                    SELECT *
                                        FROM command_rp
                                        WHERE rp_id = rp_id_
                                            AND cell_src_sname = c.sname
                                            AND state IN (0,1,3)
                                )
                                AND t.repository_part_id = rp_id_
                                AND abs(t.npp - cmrp.npp_src) = cnt__
                                AND is_error = 0
                            ORDER BY orientaition DESC
                    ) LOOP
                        cell_to__ := ncell.sname;
                        EXIT;
                    END LOOP;
                EXCEPTION WHEN others THEN
                    cell_to__ := obj_rpart.assign_tmp_cell_any_size(rp_id_, cmrp.npp_src);
                END;
                IF extend.is_null_str(cell_to__) THEN
                    cell_to__ := obj_rpart.assign_tmp_cell_any_size(rp_id_, cmrp.npp_src);
                END IF;
                IF extend.is_null_str(cell_to__) THEN
                    msg_ := '  Error - Нет места в транзитном складе!';
                    PERFORM obj_rpart.log(rp_id_, msg_);
                    PERFORM obj_ask.global_error_log(obj_ask."ERROR_TYPE_RP"(), rp_id_, null, msg_);
                ELSE
                    PERFORM obj_rpart.log(rp_id_, '  fc: временно перемещаем в ' || cell_to__);
                    track_id_to__ := obj_rpart.get_track_id_by_cell_and_rp(cmrp.rp_id, cell_to__);
                    npp_dest_new__ := obj_rpart.get_track_npp_by_cell_and_rp(cmrp.rp_id, cell_to__);
                    BEGIN
                        -- добавляем новую команду
                        --log(rp_id_,'  fc: '||cmrp.command_type_id||','|| cmrp.rp_id||','|| cell_to__||','||
                            --  cmrp.cell_dest_sname||','|| cmrp.priority||','|| cmrp.state||','|| cmrp.command_id||','|| track_id_to__||','||
                            --  cmrp.track_dest_id||','|| cmrp.sql_text_for_group||','|| get_cell_id_by_name(cmrp.rp_id, cell_to__)||','|| cmrp.cell_dest_id||','||
                            --  npp_dest_new__||','|| cmrp.npp_dest||','|| cmrp.container_id);
                        INSERT INTO command_rp (
                            command_type_id, rp_id, cell_src_sname,
                            cell_dest_sname, priority, state,
                            command_id, track_src_id, track_dest_id,
                            sql_text_for_group, cell_src_id, cell_dest_id,
                            npp_src, npp_dest, container_id
                        ) VALUES (
                            cmrp.command_type_id, cmrp.rp_id, cell_to__,
                            cmrp.cell_dest_sname, cmrp.priority, cmrp.state,
                            cmrp.command_id, track_id_to__, cmrp.track_dest_id,
                            cmrp.sql_text_for_group, obj_rpart.get_cell_id_by_name(cmrp.rp_id, cell_to__), cmrp.cell_dest_id,
                            npp_dest_new__, cmrp.npp_dest, cmrp.container_id
                        );
                        --log(rp_id_,'  fc: успешно добавили command_rp');
                        -- изменяем старую
                        UPDATE command_rp
                            SET cell_dest_sname = cell_to__,
                                is_to_free = 1,
                                track_dest_id = track_id_to__,
                                cell_dest_id = obj_rpart.get_cell_id_by_name(cmrp.rp_id, cell_to__),
                                npp_dest = npp_dest_new__,
                                command_type_id = 3
                            WHERE id = cmrp.id;
                        -- COMMIT;
                    EXCEPTION WHEN others THEN
                        GET STACKED DIAGNOSTICS sqlerrm__ = MESSAGE_TEXT;
                        msg_ := '  ERROR временного перемещения fc: ' || sqlerrm__;
                        -- ROLLBACK;
                        PERFORM obj_ask.global_error_log(obj_ask."ERROR_TYPE_RP"(), rp_id_, null, msg_);
                        PERFORM obj_rpart.log(rp_id_,msg_);
                    END;
                END IF;
            ELSE
                --msg_:='  ERROR временного перемещения fc: странно, освобождать не надо ';
                --obj_ask.global_error_log(obj_ask.error_type_rp,rp_id_,null,msg_);
                --log(rp_id_,msg_);
                cell_to__ := '';
                --exit;
            END IF;
        END IF;
    END LOOP;  -- для cmrp
END;
$BODY$;
ALTER FUNCTION obj_rpart.group_op_to_simple_crp(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.group_op_to_simple_crp(bigint)
    IS 'преобразование групповых операций перемещения в обычные';


CREATE OR REPLACE FUNCTION obj_rpart.get_robot_by_rp(
    rpid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    errmm__ TEXT;
    rp RECORD;
    rr robot;
BEGIN
    FOR rp IN (
        SELECT num_of_robots nor
            FROM repository_part
            WHERE id = rpid_
    ) LOOP
        IF (rp.nor > 1) THEN
            errmm__ := 'get_robot_by_rp - ERROR - запрос робота по складу, на котором более 1-го робота';
            PERFORM obj_rpart.log(rpid_, errmm__);
            RAISE EXCEPTION '%', errmm__
                USING errcode = 50012;
        ELSE
            FOR rr IN (
                SELECT *
                    FROM robot
                    WHERE repository_part_id = rpid_
            ) LOOP
                RETURN rr.id;
            END LOOP;
        END IF;
    END LOOP;
    RETURN -1; -- Should be unreachable
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_robot_by_rp(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_robot_by_rp(bigint)
    IS 'получить ID робота по ID подсклада (только для огурцов с одним роботом)';


CREATE OR REPLACE FUNCTION obj_rpart.optimizer_emu_1_robot(
    crp_id_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    dirl1__ BIGINT;
    dirl2__ BIGINT;
    dist0__ BIGINT;
    dist1__ BIGINT;
    fd__ BIGINT;
    ri RECORD;
BEGIN
    FOR ri IN (
        SELECT rp.repository_type, r.current_track_npp,
            crp.npp_dest, crp.npp_src,
            r.id robot_id, rp.id rp_id_
            FROM command_rp crp
            INNER JOIN repository_part rp
                ON crp.rp_id = rp.id
            INNER JOIN robot r
                ON r.repository_part_id = rp.id
            WHERE crp.id = crp_id_
    ) LOOP
        fd__ := service.get_rp_param_number('force_dir', -1);
        IF (fd__ >= 0) THEN
            dirl1__ := fd__;
            dirl2__ := fd__;
        ELSE
            IF (ri.repository_type = 0) THEN -- линейный
                IF (ri.current_track_npp > ri.npp_src) THEN
                    dirl1__ := 0;
                ELSE
                    dirl1__ := 1;
                END IF;
                IF (ri.npp_dest > ri.npp_src) THEN
                    dirl2__ := 1;
                ELSE
                    dirl2__ := 0;
                END IF;
            ELSE -- кольцевой
                dist0__ := obj_rpart.calc_distance_by_dir(ri.rp_id_, ri.current_track_npp, ri.npp_src, 0);
                dist1__ := obj_rpart.calc_distance_by_dir(ri.rp_id_, ri.current_track_npp, ri.npp_src, 1);
                IF (dist0__ < dist1__) THEN
                    dirl1__ := 0;
                ELSE
                    dirl1__ := 1;
                END IF;
                dist0__ := obj_rpart.calc_distance_by_dir(ri.rp_id_, ri.npp_src, ri.npp_dest, 0);
                dist1__ := obj_rpart.calc_distance_by_dir(ri.rp_id_, ri.npp_src, ri.npp_dest, 1);
                IF (dist0__ < dist1__) THEN
                    dirl2__ := 0;
                ELSE
                    dirl2__ := 1;
                END IF;
            END IF;
        END IF;
        UPDATE command_rp
            SET direction_1 = dirl1__,
                direction_2 = dirl2__,
                robot_id = ri.robot_id
            WHERE id = crp_id_;
    END LOOP;
END;
$BODY$;
ALTER FUNCTION obj_rpart.optimizer_emu_1_robot(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.optimizer_emu_1_robot(bigint)
    IS 'эмулирует проставление параметров для command_rp в случае, когда на подскладе 1 робот';


CREATE OR REPLACE FUNCTION obj_rpart.set_new_cmd_rps(
    rpid_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cnt__ BIGINT;
    cirecord__ command_inner;
    crprecord__ command_rp;
    robot_to_crp__ BIGINT;
    cmrp command_rp;
    rr command_rp;
BEGIN
    -- еще нет команды, назначаем
    FOR cmrp IN (
        SELECT /*+RULE*/ cr.*
            FROM command_rp cr
            INNER JOIN cell c
                ON cr.cell_src_id = c.id
            INNER JOIN cell_type ct
                ON c.hi_level_type = ct.id
            INNER JOIN robot r
                ON (
                    r.id = cr.robot_id
                    OR
                    obj_rpart.is_rp_simple_1_robot(rpid_) = 1
                )
            WHERE cr.rp_id = rpid_
                AND cr.state = 1
                AND command_type_id IN (3)
                AND obj_robot.is_robot_ready_for_cmd(r.id) = 1
                AND r.repository_part_id = rpid_
            ORDER BY priority desc,
                priority_inner,
                ct.obligotary_to_free desc,
                abs(r.current_track_npp - cr.npp_src),
                cr.id
    ) LOOP
        PERFORM obj_rpart.log(rpid_, 'Set_New_Cmd_RPs - есть command_rp - кандидат на назначение ' || cmrp.id);
        IF coalesce(cmrp.robot_id, 0) > 0 THEN
            robot_to_crp__ := cmrp.robot_id;
        ELSE -- для подсклада с одним роботом
            robot_to_crp__ := obj_rpart.get_robot_by_rp(rpid_);
        END IF;
        IF obj_robot.is_robot_ready_for_cmd(robot_to_crp__) = 1 THEN -- могло и поменяться
            SELECT count(*) INTO cnt__
                FROM command_inner
                WHERE robot_id = cmrp.robot_id
                    AND state = 3;
            PERFORM obj_rpart.log(rpid_, '  активных по роботу команд CI=!' || cnt__);
            IF (cnt__ <> 0) THEN -- ошибка, робот свободен, а задачи невыполнены
                SELECT * INTO cirecord__
                    FROM command_inner
                    WHERE robot_id = cmrp.robot_id
                        AND state = 3
                    LIMIT 1;
                PERFORM obj_rpart.log(rpid_, 'ERROR - На подскладе есть работающие команды ci.id=' || cirecord__.id || '. Выходим из такта!');
                CONTINUE;
            END IF;
            SELECT count(*) INTO cnt__
                FROM command_rp
                WHERE robot_id = cmrp.robot_id
                    AND state = 3;
            PERFORM obj_rpart.log(rpid_, '  активных по роботу команд RP=!' || cnt__);
            IF (cnt__ <> 0) THEN -- ошибка, хотим назначить command_rp, а есть еще невыполненные
                SELECT * INTO crprecord__
                    FROM command_rp
                    WHERE robot_id = cmrp.robot_id
                        AND state = 3
                    LIMIT 1;
                PERFORM obj_rpart.log(rpid_, 'ERROR - На подскладе есть работающие команды cmrp.id=' || crprecord__.id || '. Выходим из такта!');
                CONTINUE;
            END IF;
            PERFORM obj_rpart.log(rpid_, 'Найдена команда для назначения ' || cmrp.id || ' для робота ' || cmrp.robot_id);
            IF cmrp.command_type_id IN (3) THEN -- перемещение простое контейнера
                PERFORM obj_rpart.log(rpid_, 'Это команда простого перемещения контейнера ');
                IF obj_rpart.is_rp_simple_1_robot(rpid_) = 1 THEN -- простой АСК с одним роботом
                    PERFORM obj_rpart.optimizer_emu_1_robot(cmrp.id);
                END IF;
                UPDATE command_rp
                    SET state = 3,
                        date_time_begin = LOCALTIMESTAMP,
                        substate = 1
                    WHERE id = cmrp.id;
                PERFORM obj_rpart.log(rpid_, 'Проставили направления, робота, состояние, дату, подсостояние');
                FOR rr IN (
                    SELECT *
                        FROM command_rp
                        WHERE id = cmrp.id
                ) LOOP
                    UPDATE robot
                        SET command_rp_id = cmrp.id
                        WHERE id = rr.robot_id;
                    --Run_Cmd_RP_Parts_Prim(rr.robot_id, cmrp.id);
                END LOOP;
            END IF; -- если команда та что надо
        END IF;
    END LOOP;  -- для cmrp
END;
$BODY$;
ALTER FUNCTION obj_rpart.set_new_cmd_rps(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.set_new_cmd_rps(bigint)
    IS 'назначаем новые comand_rp';


CREATE OR REPLACE FUNCTION obj_rpart.actione_from_pause(
    rp_id_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rr robot;
BEGIN
    PERFORM obj_rpart.log(rp_id_, 'Actione_From_Pause');
    IF obj_rpart.is_idle(rp_id_) = 1 THEN
        PERFORM obj_rpart.log(rp_id_, 'АСК простаивает, его сняли с паузы, обнуляем занятость треков');
        UPDATE track
            SET locked_by_robot_id = 0
            WHERE repository_part_id = rp_id_
                AND locked_by_robot_id <> 0
                AND locked_by_robot_id NOT IN (
                    SELECT id
                        FROM robot
                        WHERE state = obj_robot."ROBOT_STATE_REPAIR"()
                );
        -- COMMIT;
    ELSE -- не все роботы подсклада стоят
        -- обнуляем блокировки робота, на которого нет команд и который READY
        FOR rr IN (
            SELECT *
                FROM robot
                WHERE repository_part_id = rp_id_
                    AND coalesce(command_inner_id, 0) = 0
                    AND coalesce(command_inner_assigned_id, 0) = 0
                    AND coalesce(wait_for_problem_resolve, 0) = 0
                    AND state = obj_robot."ROBOT_STATE_READY"()
        ) LOOP
            PERFORM obj_rpart.log(rp_id_, 'Робот ' || rr.id || ' АСК простаивает, АСК сняли с паузы, обнуляем занятость треков по роботу');
            UPDATE track
                SET locked_by_robot_id = 0
                WHERE repository_part_id = rp_id_
                    AND locked_by_robot_id = rr.id;
            IF coalesce(rr.command_rp_id, 0) = 0 THEN -- и команд сверху на него нету
                PERFORM obj_rpart.log(rp_id_, '  и команд сверху на него нету, удаляем заявки');
                DELETE FROM track_order
                    WHERE robot_id = rr.id;
            END IF;
            -- COMMIT;
        END LOOP;
        -- обнуляем блокировки робота, который находится в режиме решения проблемы
        FOR rr IN (
            SELECT *
                FROM robot
                WHERE repository_part_id = rp_id_
                    AND coalesce(command_inner_id, 0) <> 0
                    AND coalesce(wait_for_problem_resolve, 0) = 1
                    AND state = obj_robot."ROBOT_STATE_READY"()
        ) LOOP
            PERFORM obj_rpart.log(rp_id_, 'Робот ' || rr.id || ' АСК стоит в решении проблемы, АСК сняли с паузы, обнуляем занятость треков по роботу');
            UPDATE track
                SET locked_by_robot_id = 0
                WHERE repository_part_id = rp_id_
                    AND locked_by_robot_id = rr.id;
            -- COMMIT;
        END LOOP;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.actione_from_pause(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.actione_from_pause(bigint)
    IS 'действия, необходимые при снятии подсклада с паузы';


CREATE OR REPLACE FUNCTION obj_rpart.cancel_active_cmd(
    rp_id_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp repository_part;
    rr robot;
BEGIN
    FOR rp IN (
        SELECT *
            FROM repository_part
            WHERE rp_id_ = id
                AND is_work = 0
    ) LOOP
        -- удаляем требования прогонов
        DELETE FROM track_order
            WHERE repository_part_id = rp_id_;
        -- удаляем неначившиеся cmd_gas
        DELETE FROM command_gas
            WHERE state = 0
                AND rp_id = rp_id_;
        -- контейнеры с роботов за АСК
        FOR rr IN (
            SELECT *
                FROM robot
                WHERE repository_part_id = rp_id_
                    AND coalesce(container_id, 0) <> 0
        ) LOOP
            UPDATE container
                SET location = 0
                WHERE id = rr.container_id;
        END LOOP;
        DELETE FROM command_gas
            WHERE state IN (1,3)
                AND rp_id = rp_id_;
        UPDATE robot
            SET command_rp_id = 0,
                command_inner_id = 0,
                container_id = 0,
                command_inner_assigned_id = 0,
                wait_for_problem_resolve = 0,
                platform_busy = 0
            WHERE repository_part_id = rp_id_;
        -- COMMIT;
        RETURN;
    END LOOP;
    RAISE EXCEPTION 'Подсклад % не найден, или он не находится в режиме паузы!', rp_id_
        USING errcode = 50012;
END;
$BODY$;
ALTER FUNCTION obj_rpart.cancel_active_cmd(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.cancel_active_cmd(bigint)
    IS 'отменяем все команды по огурцу (аккуратно!)';


CREATE OR REPLACE FUNCTION obj_rpart.change_cmd_rp_dir(
    crp_id_ bigint,
    robot_id_ bigint,
    part_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    DELETE FROM track_order
        WHERE robot_id = robot_id_;
    IF (part_ = 1) THEN
        UPDATE command_rp
            SET direction_1 = obj_rpart.get_another_direction(direction_1)
            WHERE id = crp_id_;
    ELSIF (part_ = 2) THEN
        UPDATE command_rp
            SET direction_2 = obj_rpart.get_another_direction(direction_2)
            WHERE id = crp_id_;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.change_cmd_rp_dir(bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.change_cmd_rp_dir(bigint, bigint, bigint)
    IS 'изменить направление движения команды перемещения контейнера на огурце';


CREATE OR REPLACE FUNCTION obj_rpart.run_cmd_rp_parts_prim(
    robot_id_ bigint,
    crp_id_ bigint,
    is_ignore_buf_track_order_ boolean)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    new_ss BIGINT;
    ttl__ BIGINT;
    ttl_nb__ BIGINT;
    cell_sname__ TEXT;
    errm__ TEXT;
    br_id_ BIGINT;
    robot RECORD;
    crp command_rp;
    rowcount__ BIGINT;
BEGIN
    FOR robot IN (
        SELECT r.*, small_delta
            FROM robot r
            INNER JOIN repository_part rp
                ON r.repository_part_id = rp.id
            WHERE r.id = robot_id_
    ) LOOP
        PERFORM obj_rpart.log(robot.repository_part_id, 'Начало run_transfer_part ' || crp_id_ || ' робота ' || robot_id_);
        FOR crp IN (
            SELECT *
                FROM command_rp
                WHERE id = crp_id_
        ) LOOP
            UPDATE robot
                SET command_rp_id = crp_id_
                WHERE id = robot_id_
                    AND coalesce(command_rp_id, 0) <> crp_id_;
            GET DIAGNOSTICS rowcount__ := ROW_COUNT;
            IF (rowcount__ > 0) THEN
                PERFORM obj_robot.log(robot_id_,'У робота назначили command_rp ' || crp_id_);
            END IF;
            IF coalesce(crp.substate, 0) IN (0,1,2) THEN -- только начала выполняться или уже доехали
                SELECT *
                    INTO br_id_, ttl__
                    FROM obj_rpart.try_track_lock(robot_id_, crp.npp_src, crp.direction_1, is_ignore_buf_track_order_);
                IF (ttl__ = crp.npp_src) THEN
                    PERFORM obj_rpart.log(robot.repository_part_id, '  удалось заблокировать до цели, шлем CMD_LOAD ');
                    PERFORM obj_robot.set_command_inner(
                        robot_id_, crp_id_, 1, 4,
                        crp.direction_1,  crp.cell_src_sname, '',
                        obj_robot."CMD_LOAD"() || ' ' || crp.cell_src_sname || ';' || obj_rpart.get_cmd_dir_text(crp.direction_1),
                        crp.container_id
                    );
                ELSIF (ttl__ < 0) THEN
                    PERFORM obj_rpart.log(robot.repository_part_id, '  не можем сдвинуться с места, ждем');
                    IF obj_robot.get_robot_state(br_id_) = obj_robot."ROBOT_STATE_REPAIR"() THEN -- не ремонт ли мешает?
                        errm__ := '  мешает ремонтный робот ' || br_id_ || ', меняем направление LOAD';
                        PERFORM obj_rpart.log(robot.repository_part_id, errm__);
                        PERFORM obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT_RP"(), robot.repository_part_id, robot.id, errm__);
                        PERFORM obj_rpart.change_cmd_rp_dir(robot.command_rp_id, robot.id, 1);
                    END IF;
                ELSIF (
                    ttl__ <> robot.current_track_npp
                    AND
                    obj_rpart.calc_distance_by_dir(
                        robot.repository_part_id,
                        robot.current_track_npp,
                        ttl__,
                        crp.direction_1
                    ) >robot.small_delta
                ) THEN -- можем сдвинуться
                    PERFORM obj_rpart.log(robot.repository_part_id, '  не удалось заблокировать до цели, шлем MOVE до ' || ttl__);
                    ttl_nb__ := obj_rpart.get_track_npp_not_baned(robot.repository_part_id, ttl__, crp.direction_1);
                    IF (ttl_nb__ <> robot.current_track_npp) THEN
                        PERFORM obj_rpart.log(robot.repository_part_id, '  ttl_nb__=' || ttl_nb__);
                        IF (robot.is_use_checkpoint = 1) THEN -- использовать промежуточные точки
                            PERFORM obj_robot.set_command_inner(
                                robot_id_, crp_id_, 1, 4,
                                crp.direction_1, crp.cell_src_sname, null,
                                obj_robot."CMD_LOAD"() || ' ' || crp.cell_src_sname
                                    || ' cp=' || ttl_nb__ || ';'
                                    || obj_rpart.get_cmd_dir_text(crp.direction_1),
                                crp.container_id,ttl_nb__
                            );
                        ELSE -- не использовать промежуточные точки
                            cell_sname__ := obj_rpart.get_cell_name_by_track_npp(ttl_nb__, robot.repository_part_id);
                            PERFORM obj_robot.set_command_inner(
                                robot_id_, crp_id_, 1, 6,
                                crp.direction_1, null, cell_sname__,
                                obj_robot."CMD_MOVE"() || ' ' || cell_sname__
                                    || ';' || obj_rpart.get_cmd_dir_text(crp.direction_1),
                                crp.container_id
                            );
                        END IF;
                    ELSE
                        PERFORM obj_rpart.log(robot.repository_part_id, '  не можем послать, т.к. трек запрещен к MOVE и он один');
                    END IF;
                END IF;
                UPDATE command_rp
                    SET substate = 1
                    WHERE id = crp_id_
                        AND coalesce(substate, 0) < 1;
                GET DIAGNOSTICS rowcount__ := ROW_COUNT;
                IF (rowcount__ > 0) THEN
                    PERFORM obj_rpart.log(robot.repository_part_id, 'У команды ' || crp_id_ || ' назначили новое подостояние 1');
                END IF;
            ELSIF crp.substate IN (3,4) THEN -- все еще едем куда надо
                SELECT *
                    INTO br_id_, ttl__
                    FROM obj_rpart.try_track_lock(robot_id_, crp.npp_dest, crp.direction_2, is_ignore_buf_track_order_);
                IF (ttl__ = crp.npp_dest) THEN
                    PERFORM obj_rpart.log(robot.repository_part_id, '  удалось заблокировать до цели, шлем CMD_UNLOAD ');
                    PERFORM obj_robot.set_command_inner(
                        robot_id_, crp_id_, 1, 5,
                        crp.direction_2, '', crp.cell_dest_sname,
                        obj_robot."CMD_UNLOAD"() || ' ' || crp.cell_dest_sname
                            || ';' || obj_rpart.get_cmd_dir_text(crp.direction_2),
                        crp.container_id
                    );
                ELSIF (ttl__ < 0) THEN
                    PERFORM obj_rpart.log(robot.repository_part_id,'  не можем сдвинуться с места, ждем');
                    IF obj_robot.get_robot_state(br_id_) = obj_robot."ROBOT_STATE_REPAIR"() THEN -- не ремонт ли мешает?
                        errm__ := '  мешает ремонтный робот ' || br_id_ || ', меняем направление UNLOAD ';
                        PERFORM obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT_RP"(), robot.repository_part_id, robot.id, errm__);
                        PERFORM obj_rpart.log(robot.repository_part_id, errm__);
                        PERFORM obj_rpart.change_cmd_rp_dir(robot.command_rp_id, robot.id, 2);
                    END IF;
                ELSIF (
                    ttl__ <> robot.current_track_npp
                    AND
                    obj_rpart.calc_distance_by_dir(
                        robot.repository_part_id,
                        robot.current_track_npp,
                        ttl__,
                        crp.direction_2
                    ) > robot.small_delta
                ) THEN -- можем сдвинуться
                    PERFORM obj_rpart.log(robot.repository_part_id, '  не удалось заблокировать до цели, шлем MOVE до ' || ttl__);
                    ttl_nb__ := obj_rpart.get_track_npp_not_baned(robot.repository_part_id, ttl__, crp.direction_2);
                    IF (ttl_nb__ <> robot.current_track_npp) THEN
                        PERFORM obj_rpart.log(robot.repository_part_id, '  ttl_nb__=' || ttl_nb__);
                        IF (robot.is_use_checkpoint = 1) THEN -- использовать промежуточные точки
                            PERFORM obj_robot.set_command_inner(
                                robot_id_, crp_id_, 1, 5,
                                crp.direction_2, null, crp.cell_dest_sname,
                                obj_robot."CMD_UNLOAD"() || ' ' || crp.cell_dest_sname
                                    || ' cp=' || ttl_nb__
                                    || ';' || obj_rpart.get_cmd_dir_text(crp.direction_2),
                                crp.container_id, ttl_nb__
                            );
                        ELSE -- не использовать промежуточные точки
                            cell_sname__ := obj_rpart.get_cell_name_by_track_npp(ttl_nb__, robot.repository_part_id);
                            PERFORM obj_robot.set_command_inner(
                                robot_id_, crp_id_, 1, 6,
                                crp.direction_2, null, cell_sname__,
                                obj_robot."CMD_MOVE"() || ' ' || cell_sname__
                                    || ';' || obj_rpart.get_cmd_dir_text(crp.direction_2),
                                crp.container_id
                            );
                        END IF;
                    ELSE
                        PERFORM obj_rpart.log(robot.repository_part_id, '  не можем послать, т.к. трек запрещен к MOVE и он один');
                    END IF;
                END IF;
            ELSE
                PERFORM obj_rpart.log(robot.repository_part_id, 'ERROR - crp.substate=' || crp.substate || ', а в Run_Transfer_Part все равно пришли!');
            END IF;
        END LOOP;
    END LOOP;
END;
$BODY$;
ALTER FUNCTION obj_rpart.run_cmd_rp_parts_prim(bigint, bigint, boolean) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.run_cmd_rp_parts_prim(bigint, bigint, boolean)
    IS 'выполняет часть команды перемещения контейнера между ячейками';


CREATE OR REPLACE FUNCTION obj_rpart.run_cmd_parts(
    rid_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    awaypar__ BIGINT;
    s_must_real_cmd BOOLEAN;
    rrp robot;
    toi track_order;
    rr robot;
    crp command_rp;
BEGIN
    s_must_real_cmd := false;
    FOR rrp IN (
        SELECT *
            FROM robot
            WHERE id = rid_
    ) LOOP
        -- если  остались свободные роботы, то пытаемся дозавершить команды
        FOR toi IN (
            SELECT *
                FROM track_order tor
                WHERE rid_ = robot_stop_id
                    --and obj_robot.Is_Robot_Ready_For_Cmd_Inner(r.id)=1
        ) LOOP
            PERFORM obj_rpart.log(rrp.repository_part_id, 'На робота ' || rid_
                || ' уже есть заявка ' || toi.id || ', прогоняем ');
            awaypar__ := obj_rpart.robot_stop_drive_away_try(rid_, toi.id);
            IF (awaypar__ = 3) THEN -- есть команда которую можно присунуть не мешая отгону
                s_must_real_cmd := true;
            ELSE
                RETURN; -- во всех остальных случаях вываливаемся
            END IF;
        END LOOP;
        -- отмены всякие если нужно
        FOR rr IN (
            SELECT *
                FROM robot
                WHERE id = rid_
        ) LOOP
            IF (
                coalesce(rr.command_rp_id, 0) = 0
                OR
                coalesce(rr.command_inner_assigned_id, 0) <> 0
            ) THEN
                PERFORM obj_rpart.log(rr.repository_part_id, 'нет назначенной команды CRP, или делаются какие-то CMD_INNER');
                RETURN;
            END IF;
        END LOOP;
        FOR crp IN (
            SELECT *
                FROM command_rp
                WHERE id = rrp.command_rp_id
        ) LOOP
            IF crp.command_type_id IN (3,7) THEN
                -- перемещение простое контейнера
                IF crp.substate IN (0,1,2,3,4) THEN
                    PERFORM obj_rpart.run_cmd_rp_parts_prim(crp.robot_id, crp.id, s_must_real_cmd);
                ELSE
                    -- че сюда дошли, странно
                    PERFORM obj_rpart.log(rrp.repository_part_id,'ERROR - такого подстатуса команды быть не должно - не то поставил ручками?');
                END IF;
            END IF;
        END LOOP;
    END LOOP;
END;
$BODY$;
ALTER FUNCTION obj_rpart.run_cmd_parts(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.run_cmd_parts(bigint)
    IS 'формируем доделки comand_rp или прогоняем робота мешающего по заявке';


CREATE OR REPLACE FUNCTION obj_rpart.form_cmds(
    rpid_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rpl RECORD;
    rep repository;
    rr robot;
BEGIN
    PERFORM obj_rpart.log(rpid_, '');
    PERFORM obj_rpart.log(rpid_, '*****************************************');
    PERFORM obj_rpart.log(rpid_, 'Начало FormCmds для склада');
    IF obj_rpart.is_npp_actual_info(rpid_) = 0 THEN
        PERFORM obj_rpart.log(rpid_, 'ERROR - устаревание информации о местоположении роботов!');
        RETURN;
    END IF;
    FOR rpl IN (
        SELECT DISTINCT rp.id,
            rp.repository_type rt,
            is_cell_move_after_cmd,
            is_robot_need_inity,
            rp.spacing_of_robots sorb,
            rp.cmd_transfer_enabled,
            rp.max_npp,
            rp.num_of_robots
            FROM repository_part rp
            INNER JOIN robot r
                ON r.repository_part_id = rp.id
            WHERE obj_robot.is_robot_ready_for_cmd_inner(r.id) = 1
                AND (rpid_ = 0 OR rp.id = rpid_)
    ) LOOP
        PERFORM obj_rpart.log(rpid_, '   Вошли в цикл');
        IF (rpl.is_cell_move_after_cmd = 1) THEN
            PERFORM obj_rpart.move_robot_away_if_ness(rpl.id); -- двигаем роботов от рабочего стола после UNLOAD, если указано в настройках АСК
            PERFORM obj_rpart.log(rpl.id, '  Move_Robot_Away_If_Ness прошло');
        END IF;
        IF (rpl.is_robot_need_inity = 1) THEN
            PERFORM obj_rpart.inity_if_ness(rpl.id);
            PERFORM obj_rpart.log(rpl.id, '  InitY_If_Ness прошло');
        END IF;
        FOR rep IN (
            SELECT id
                FROM repository
                WHERE is_group_cmd = 1
        ) LOOP
            PERFORM obj_rpart.group_op_to_simple_crp(rpl.id);
            PERFORM obj_rpart.log(rpl.id, '  Group_Op_To_Simple_CRP прошло');
        END LOOP;
        PERFORM obj_rpart.set_new_cmd_rps(rpl.id);
        PERFORM obj_rpart.log(rpl.id, '  Set_New_Cmd_RPs прошло');
        FOR rr IN (
            SELECT id
                FROM robot
                WHERE repository_part_id = rpid_
        ) LOOP
            IF obj_robot.is_robot_ready_for_cmd_inner(rr.id) = 1 THEN
                PERFORM obj_rpart.run_cmd_parts(rr.id); -- до
            END IF;
        END LOOP;
        PERFORM obj_rpart.log(rpl.id, '  Run_Cmd_Parts прошло');
        -- COMMIT;
    END LOOP;
END;
$BODY$;
ALTER FUNCTION obj_rpart.form_cmds(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.form_cmds(bigint)
    IS 'основная функция, которая вызывается из фоновой процедуры C# бесконечного цикла';


CREATE OR REPLACE FUNCTION obj_rpart.has_free_cell(
    csize bigint,
    rp_id_ bigint DEFAULT 0)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BOOLEAN;
BEGIN
    SELECT exists(
        SELECT * FROM cell
            WHERE is_full=0
                AND coalesce(blocked_by_ci_id, 0) = 0
                AND service.is_cell_over_locked(cell.id) = 0
                AND coalesce(is_error, 0) = 0
                AND hi_level_type = 1
                AND zone_id <> 0
                AND (repository_part_id = rp_id_ or coalesce(rp_id_, 0) = 0)
                AND cell_size <= csize
    ) INTO res;
    RETURN res::INT::BIGINT;
END;
$BODY$;
ALTER FUNCTION obj_rpart.has_free_cell(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.has_free_cell(bigint, bigint)
    IS 'есть ли свободное место?';


CREATE OR REPLACE FUNCTION obj_rpart.has_free_cell_by_cnt(
    cntid bigint,
    rp_id_ bigint DEFAULT 0)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    ct BIGINT;
BEGIN
    SELECT type INTO ct
        FROM container
        WHERE id = cntid;
    IF ct IS null THEN
        RETURN 0;
    END IF;
    RETURN obj_rpart.has_free_cell(ct, rp_id_);
END;
$BODY$;
ALTER FUNCTION obj_rpart.has_free_cell_by_cnt(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.has_free_cell_by_cnt(bigint, bigint)
    IS 'есть ли свободное место для контейнера заданного размера?';


CREATE OR REPLACE FUNCTION obj_rpart.try_track_lock(
    rid_ bigint,
    npp_to_ bigint,
    dir_ bigint,
    ignore_buf_track_order boolean,
    OUT barrier_robot_id bigint,
    OUT result bigint)
    RETURNS record
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp_ RECORD;
    to_ RECORD;
    tr RECORD;
    tor RECORD;
    tt RECORD;
    npp_from_sorb__ BIGINT;
    npp_to_sorb__ BIGINT;
    npp_cur__ BIGINT;
    npp_to_was_locked__ BOOLEAN;
    npp_old__ BIGINT;
    npp_tmp__ BIGINT;
    distance__ BIGINT;
    cnt_ BIGINT;
    npp_to_ar BIGINT;
    ft BOOLEAN;
BEGIN
    -- Assume there are no barriers
    barrier_robot_id := 0; -- типа ничего не мешает
    FOR rp_ IN (
        SELECT rp.id, num_of_robots, spacing_of_robots, repository_type, max_npp, r.current_track_npp
            FROM robot r
            INNER JOIN repository_part rp
                ON r.repository_part_id = rp.id
            WHERE r.id = rid_
    ) LOOP
        DELETE FROM tmp_track_lock WHERE rp_id = rp_.id;
        PERFORM obj_rpart.log(rp_.id, 'Try_Track_Lock robot=' || rid_
            || ' робот находится c_npp=' || rp_.current_track_npp
            || ' npp_to_=' || npp_to_
            || ' dir_=' || dir_);
        IF (obj_rpart.is_track_locked(rid_, npp_to_, dir_, 0, 1) = 1) THEN
            PERFORM obj_rpart.log(rp_.id,'  уже заблокировано, нет смысла блокировать');
            result := npp_to_;
            RETURN;
        END IF;
        IF (rp_.current_track_npp = npp_to_) THEN
            PERFORM obj_rpart.log(rp_.id,'  находится робот там же, куда нужно дойти. Бред какой-то');
            result := npp_to_;
            RETURN;
        END IF;
        npp_from_sorb__ := obj_rpart.add_track_npp(rp_.id, rp_.current_track_npp, rp_.spacing_of_robots + 1, dir_);
        npp_to_sorb__ := obj_rpart.add_track_npp(rp_.id, npp_to_, rp_.spacing_of_robots, dir_);
        IF (obj_rpart.is_track_npp_ban_move_to(rp_.id, npp_to_) = 1) THEN
            PERFORM obj_rpart.log(rp_.id, '  попали на BAN_MOVE_TO, увеличиваем npp_to_sorb__ на 1 в сторону ' || dir_);
            npp_to_sorb__ := obj_rpart.add_track_npp(rp_.id, npp_to_sorb__, 1, dir_);
        END IF;
        npp_cur__ := npp_from_sorb__;
        -- для блокировки around или на 1 секцию
        distance__ := obj_rpart.calc_distance_by_dir(rp_.id, rp_.current_track_npp, npp_to_, dir_);
        npp_to_was_locked__ := (npp_to_ = rp_.current_track_npp) OR (distance__ <= rp_.spacing_of_robots);
        npp_old__ := -1;
        PERFORM obj_rpart.log(rp_.id, '  npp_from_sorb__=' || npp_from_sorb__ || ' npp_to_sorb__=' || npp_to_sorb__);
        -- а теперь проверяем заявки, если нужно
        IF (NOT ignore_buf_track_order) THEN
            cnt_ := 0;
            FOR to_ IN (SELECT * FROM track_order WHERE repository_part_id = rp_.id ORDER BY id) LOOP
                EXIT WHEN (cnt_ = 0) AND (to_.robot_id = rid_); -- если самая свежая заявка от текущего робота, то ему все пофиг
                IF (to_.robot_id <> rid_) AND (to_.robot_stop_id <> rid_) THEN
                    npp_to_ar := obj_rpart.correct_npp_to_track_order(rid_, to_.robot_id, dir_, npp_to_sorb__);
                    IF (obj_rpart.is_track_locked(rid_, npp_to_, dir_, 0) = 0)
                        AND (
                            obj_rpart.is_track_part_between(rp_.id, npp_from_sorb__, npp_to_ar, dir_)
                            OR obj_rpart.is_track_part_between(rp_.id, npp_from_sorb__, npp_to_, dir_) -- это нужно чтобы избежать перехлеста при блокировки с 44 по 42 по часовой
                        )
                    THEN
                        PERFORM obj_rpart.log(rp_.id, '  отмена запроса на блокировку трека, т.к. требуемый участок уже в заявке по цепочке');
                        result := npp_old__;
                        RETURN;
                    END IF;
                END IF;
                cnt_ := cnt_ + 1;
            END LOOP;
        END IF;
        LOOP
            --Log(rp.id,'  loop npp_cur__='||npp_cur__);
            FOR tr IN (SELECT * FROM track WHERE repository_part_id = rp_.id AND npp = npp_cur__) LOOP
                IF (tr.locked_by_robot_id = 0) THEN
                    --update track set locked_by_robot_id=rid_ where id=tr.id;
                    INSERT INTO tmp_track_lock(npp, rp_id) VALUES (npp_cur__, rp_.id);
                    -- освобождаем заявку с трека
                    FOR tor IN (
                        SELECT * FROM track_order
                        WHERE robot_id = rid_
                        AND npp_from = npp_cur__
                        AND npp_from <> npp_to
                    ) LOOP
                        npp_tmp__ := obj_rpart.add_track_npp(rp_.id, npp_cur__, 1, obj_rpart.get_another_direction(dir_));
                        PERFORM obj_rpart.log(rp_.id,'  освободили кусок заявки track_order ' || tor.id
                            || ' робота ' || tor.robot_id
                            || ' на трек с ' || tor.npp_from
                            || ' на трек с  ' || npp_tmp__);
                        UPDATE track_order SET npp_from = npp_tmp__ WHERE robot_id = rid_;
                    END LOOP;
                    -- удаляем всю заявку
                    FOR tor IN (
                        SELECT * FROM track_order
                        WHERE robot_id = rid_
                            AND npp_from = npp_cur__
                            AND npp_from = npp_to
                    ) LOOP
                        PERFORM obj_rpart.log(rp_.id, '  удалили заявку track_order ' || tor.id
                            || ' робота ' || tor.robot_id
                            || ' на трек с ' || tor.npp_from
                            || ' по ' || tor.npp_to
                            || ' робот мешал ' || tor.robot_stop_id);
                        DELETE FROM track_order WHERE robot_id = rid_;
                    END LOOP;
                ELSIF (tr.locked_by_robot_id <> rid_) THEN
                    barrier_robot_id := tr.locked_by_robot_id;
                    IF (npp_old__ < 0) THEN
                        PERFORM obj_rpart.log(rp_.id, '  ERROR - заблокировано другим роботом');
                        ft := obj_rpart.form_track_order(rid_, npp_from_sorb__, npp_to_sorb__, dir_, tr.locked_by_robot_id);
                        IF (NOT ft) AND (NOT ignore_buf_track_order) THEN
                            result := -1;
                            RETURN;
                        END IF;
                        PERFORM obj_rpart.track_lock_prim(rp_.id, rid_);
                        result := npp_old__;
                        RETURN;
                    ELSE
                        ft := obj_rpart.form_track_order(rid_, tr.npp, npp_to_sorb__, dir_, tr.locked_by_robot_id);
                        IF (NOT ft) AND (NOT ignore_buf_track_order) THEN
                            result := -1;
                            RETURN;
                        END IF;
                        PERFORM obj_rpart.track_lock_prim(rp_.id, rid_);
                        npp_old__ := obj_rpart.add_track_npp(rp_.id, npp_old__, rp_.spacing_of_robots, obj_rpart.get_another_direction(dir_));
                        result := npp_old__;
                        RETURN;
                    END IF;
                END IF;
            END LOOP;
            IF (NOT npp_to_was_locked__) AND (npp_cur__ = npp_to_) THEN
                npp_to_was_locked__ := true;
            END IF;
            npp_old__ := npp_cur__;
            EXIT WHEN npp_cur__ = npp_to_sorb__ AND npp_to_was_locked__;
            npp_cur__ := obj_rpart.add_track_npp(rp_.id, npp_cur__, 1, dir_);
            PERFORM obj_rpart.log(rp_.id, '  tr.npp_cur__=' || npp_cur__);
        END LOOP;
        PERFORM obj_rpart.track_lock_prim(rp_.id, rid_);
        -- удаляем заявки на трек, если были, раз сюда дошли, то
        FOR tt IN (SELECT * FROM track_order WHERE robot_id = rid_) LOOP
            DELETE FROM track_order WHERE robot_id = rid_;
            PERFORM obj_rpart.log(rp_.id, '  удалили заявку track_order ' || tt.id
                || ' робота ' || tt.robot_id
                || ' на трек с ' || tt.npp_from
                || ' по ' || tt.npp_to
                || ' робот мешал ' || tt.robot_stop_id);
        END LOOP;
        result := npp_to_;
        RETURN;
    END LOOP;
END;
$BODY$;
ALTER FUNCTION obj_rpart.try_track_lock(bigint, bigint, bigint, boolean) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.try_track_lock(bigint, bigint, bigint, boolean)
    IS 'возврщает track_npp, до которого удалось дойти
если не может сдвинуться с места, шлет -1
если не удалось дойти, то шлет заявку на участок пути
здесь задаем № трека без учета ореола (интеллектуальное)';


CREATE OR REPLACE FUNCTION obj_rpart.is_track_locked_around(
    rid_ bigint,
    npp_ bigint,
    maybe_locked_ bigint DEFAULT 0)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    ll BIGINT;
    npp_from_sorb__ BIGINT;
    npp_to_sorb__ BIGINT;
    npp_cur__ BIGINT;
    r robot;
    rp RECORD;
BEGIN
    FOR r IN (SELECT * FROM robot WHERE id = rid_) LOOP
        FOR rp IN (
            SELECT repository_type, id, max_npp, spacing_of_robots sorb, num_of_robots
                FROM repository_part
                WHERE id = r.repository_part_id
        ) LOOP
            npp_from_sorb__ := obj_rpart.add_track_npp(r.repository_part_id, npp_, rp.sorb, 0);
            npp_to_sorb__ := obj_rpart.add_track_npp(r.repository_part_id, npp_, rp.sorb, 1);
            --dbms_output.put_line(npp_from_sorb__||' '||npp_to_sorb__);
            npp_cur__ := npp_from_sorb__;
            LOOP
                --dbms_output.put_line(' npp_cur__='||npp_cur__);
                SELECT locked_by_robot_id INTO ll
                    FROM track
                    WHERE repository_part_id = rp.id
                        AND npp = npp_cur__;
                IF (ll <> r.id) THEN -- ошибка
                    IF (maybe_locked_ = 0) THEN
                        RETURN 0; -- путь не готов - ОШИБКА!!!
                    ELSE -- параметр ф-ии с возможностью блокировки
                        IF (ll <> 0) THEN
                            RETURN 0; -- блокирован иным роботом
                        END IF;
                    END IF;
                END IF;
                EXIT WHEN npp_cur__ = npp_to_sorb__;
                IF (rp.repository_type = 1) THEN -- для кольцевого склада
                    IF (npp_cur__ = rp.max_npp) THEN
                        npp_cur__ := 0;
                    ELSE
                        npp_cur__ := npp_cur__ + 1;
                    END IF;
                ELSE  -- для линейного
                    IF (npp_cur__ < rp.max_npp) THEN
                        npp_cur__ := npp_cur__ + 1;
                    ELSE
                        EXIT; -- выход из цикла
                    END IF;
                END IF;
            END LOOP;
        END LOOP;
    END LOOP;
    RETURN 1; -- все проверено, мин нет
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_track_locked_around(bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_track_locked_around(bigint, bigint, bigint)
    IS 'заблокировано ли вокруг? (если maybe_locked_==1, то еще и нет ли помех для блокировки если нужно?)';


CREATE OR REPLACE FUNCTION obj_rpart.try_track_lock_robot_around(
    rid_ bigint,
    npp_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    errm__ TEXT;
    ttl__ BIGINT;
    npp_from_sorb__ BIGINT;
    npp_to_sorb__ BIGINT;
    npp_cur__ BIGINT;
    rr RECORD;
    tr track;
begin
    FOR rr IN (
        SELECT r.*, num_of_robots nor, rp.id rp_id, spacing_of_robots
            FROM robot r
            INNER JOIN repository_part rp
                ON r.repository_part_id = rp.id
            WHERE r.id = rid_
    ) LOOP
        PERFORM obj_rpart.log(rr.rp_id, 'Try_Track_Lock_Robot_Around - Блокируем вокруг трека ' || npp_ || ' робота ' || rid_);
        npp_from_sorb__ := obj_rpart.add_track_npp(rr.rp_id, npp_, rr.spacing_of_robots, 0);
        npp_to_sorb__ := obj_rpart.add_track_npp(rr.rp_id, npp_, rr.spacing_of_robots, 1);
        npp_cur__ := npp_from_sorb__;
        LOOP
            FOR tr IN (
                SELECT *
                    FROM track
                    WHERE repository_part_id = rr.rp_id
                        AND npp = npp_cur__
            ) LOOP
                IF (tr.locked_by_robot_id = 0) THEN
                    UPDATE track
                        SET locked_by_robot_id = rid_
                        WHERE id = tr.id;
                ELSIF (tr.locked_by_robot_id <> rid_) THEN
                    PERFORM obj_rpart.log(rr.rp_id, '  ERROR - заблокировано другим роботом');
                    RETURN 0;
                END IF;
            END LOOP;
            EXIT WHEN npp_cur__ = npp_to_sorb__;
            npp_cur__ := obj_rpart.add_track_npp(rr.rp_id, npp_cur__, 1, 1);
        END LOOP;
    END LOOP;
    RETURN 1;
END;
$BODY$;
ALTER FUNCTION obj_rpart.try_track_lock_robot_around(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.try_track_lock_robot_around(bigint, bigint)
    IS 'пытаемся заблокировать трек в указанном месте + ореол вокруг робота';


CREATE OR REPLACE FUNCTION obj_rpart.relock_robot_around(
    rid_ bigint,
    npp_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp_id__ BIGINT;
    errm__ TEXT;
BEGIN
    rp_id__ := obj_robot.get_robot_rp_id(rid_);
    UPDATE track
        SET locked_by_robot_id = 0
        WHERE locked_by_robot_id = rid_;
    IF obj_rpart.try_track_lock_robot_around(rid_, npp_) = 1 THEN
        PERFORM obj_rpart.log(rp_id__, '  успешно заблокировали вокруг нового робота ' || rid_ || ' npp=' || npp_);
        -- COMMIT;
    ELSE
        errm__ := '  ERROR - не могу заблокировать путь для нового робота ' || rid_ || ' npp=' || npp_;
        PERFORM obj_rpart.log(rp_id__, errm__);
        RAISE EXCEPTION '%', errm__
            USING errcode = 50012;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.relock_robot_around(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.relock_robot_around(bigint, bigint)
    IS 'переблкоируем вокруг робота';


CREATE OR REPLACE FUNCTION obj_rpart.check_lock_robot_around(
    rid_ bigint,
    npp_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    ttl__ BIGINT;
    errm__ TEXT;
    rr RECORD;
BEGIN
    FOR rr IN (
        SELECT r.*, num_of_robots nor
            FROM robot r
            INNER JOIN repository_part rp
                ON r.repository_part_id = rp.id
            WHERE r.id = rid_
    ) LOOP
        --Log(rr.repository_part_id,'Check_Lock_Robot_Around -  вокруг трека '||npp_||' робота '||rid_);
        IF (rr.nor = 1) THEN  -- склад с одним роботом
            IF obj_rpart.is_track_locked_around(rid_, npp_) = 0 THEN
                PERFORM obj_rpart.log(rr.repository_part_id, '  вокруг трека не заблокировано, блокируем!');
                ttl__ := obj_rpart.try_track_lock_robot_around(rid_, npp_);
            ELSE
                --Log(rr.repository_part_id,'  вокруг трека уже заблокировано');
                null;
            END IF;
            RETURN 1;
        ELSE  -- склад с несколькими роботами
            IF obj_rpart.is_track_locked_around(rid_, npp_) = 0 THEN
                errm__ := '  ERROR - не получилось заблокировать вокруг трека ' || npp_ || ' робота ' || rid_;
                PERFORM obj_ask.global_error_log(obj_ask."ERROR_TYPE_ROBOT_RP"(), rr.repository_part_id, rid_, errm__);
                PERFORM obj_rpart.log(rr.repository_part_id,errm__);
                RAISE EXCEPTION '%', errm__
                    USING errcode = 50012;
                RETURN 0;
            ELSE
                --Log(rr.repository_part_id,'  успешно заблокировали');
                RETURN 1;
            END IF;
        END IF;
    END LOOP;
    RETURN 0; -- unreachable in normal conditions
END;
$BODY$;
ALTER FUNCTION obj_rpart.check_lock_robot_around(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.check_lock_robot_around(bigint, bigint)
    IS 'проверяем - заблокирован ли ореол вокруг робота?';


CREATE OR REPLACE FUNCTION obj_rpart.is_poss_to_lock(
    robot_id_ bigint,
    track_npp_dest bigint,
    direction_ bigint,
    crp_id_ bigint default 0)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    r1 RECORD;
    -- r2 RECORD;
    track_id_dest BIGINT;
    rp_id_ BIGINT;
    sorb BIGINT;
    max_npp_ BIGINT;
    rpt BIGINT;
    nr BIGINT;
    -- anroid BIGINT;
    -- is_in_dest BIGINT;
    cur_track_id BIGINT;
    npp1 BIGINT;
    npp1r BIGINT;
    npp2 BIGINT;
    npp2r BIGINT;
    track_id_dest_pl_sor BIGINT;
    -- track_npp_dest_pl_sor BIGINT;
    tr_npp BIGINT;
    tr_id BIGINT;
    is_loop_exit BIGINT;
    tr_locked_by_robot_id BIGINT;
    ret_track_id BIGINT;
    -- npp_ret BIGINT;
BEGIN
    -- зачитываем нужные значения, инициализируем данные, пишем логи
    SELECT * INTO r1 FROM robot WHERE id = robot_id_;
    SELECT t.id, rp.id, spacing_of_robots, max_npp, repository_type, num_of_robots
        INTO track_id_dest, rp_id_, sorb, max_npp_, rpt, nr
        FROM track t, repository_part rp
        WHERE t.npp = track_npp_dest AND repository_part_id = rp.id AND rp.id = r1.repository_part_id;
    IF (/*rpt=0*/ nr = 1) THEN
        -- для склада с одним роботом
        IF (r1.current_track_npp = track_npp_dest) THEN
            RETURN -1; -- уже тама
        ELSE
            RETURN track_id_dest;
        END IF;
    END IF;
    -- anroid := obj_rpart.get_another_robot_id(robot_id_);
    -- SELECT * INTO r2 FROM robot WHERE id = anroid;
    -- is_in_dest := 0;
    cur_track_id := r1.current_track_id;
    IF (track_id_dest = cur_track_id) THEN
        RETURN 1;
    END IF;

    npp1 := r1.current_track_npp;
    npp1r := obj_rpart.inc_spacing_of_robots(npp1, direction_, sorb, rp_id_); -- убрали +1
    npp2 := track_npp_dest;
    npp2r := obj_rpart.inc_spacing_of_robots(npp2, direction_, sorb, rp_id_);

    track_id_dest_pl_sor := obj_rpart.get_track_id_by_robot_and_npp(robot_id_, npp2r);
    -- track_npp_dest_pl_sor := npp2r;

    tr_npp := npp1r;
    LOOP
        tr_id := obj_rpart.get_track_id_by_robot_and_npp(robot_id_, tr_npp);
        SELECT locked_by_robot_id INTO tr_locked_by_robot_id FROM track WHERE id=tr_id;
        IF (coalesce(tr_locked_by_robot_id, 0) = 0) then
            --update track set locked_by_robot_id=r1.id where id=tr_id;
            ret_track_id := tr_id;
            -- npp_ret := tr_npp;
        -- заблокировано кем то иным
        ELSIF (coalesce(tr_locked_by_robot_id, 0) <> r1.id) THEN
            RETURN 0;
        ELSE -- этим же роботом и заблокировано
            ret_track_id := tr_id;
            -- npp_ret := tr_npp;
        END IF;
        SELECT * INTO tr_npp, is_loop_exit FROM obj_rpart.get_next_npp(rpt, max_npp_, tr_npp, npp2r, direction_, tr_npp, is_loop_exit);
        EXIT WHEN is_loop_exit = 1;
    END LOOP;

    IF (ret_track_id = track_id_dest_pl_sor) THEN
        -- добрались до конечного трека с учетом расстояния между роботами
        RETURN 1;
    ELSE -- не дошли до конечного трека
        RETURN 0;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_poss_to_lock(bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_poss_to_lock(bigint, bigint, bigint, bigint)
    IS 'определяет, возможно ли заблокировать путь';


CREATE OR REPLACE FUNCTION obj_rpart.is_robot_lock_bad(
    rid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cnpp__ BIGINT;
    cnt1 BIGINT;
    cnt2 BIGINT;
    rr RECORD;
    tt track;
BEGIN
    SELECT count(*) INTO cnt1
        FROM track
        WHERE locked_by_robot_id = rid_;
    IF cnt1 = 0 THEN -- ничего не заблокировано, неправильно!
        RETURN 1;
    END IF;
    FOR rr IN (
        SELECT r.*, max_npp, spacing_of_robots sor
            FROM robot r
            INNER JOIN repository_part rp
                ON r.repository_part_id = rp.id
            WHERE r.id = rid_
    ) LOOP
        FOR dir IN 0..1 LOOP -- в оба направления
            IF (dir = 0) THEN -- против часовой
                cnt1 := 0;
                FOR tt IN (
                    SELECT *
                        FROM track
                        WHERE repository_part_id = rr.repository_part_id
                            AND npp < rr.current_track_npp
                        ORDER BY npp DESC
                ) LOOP
                    cnpp__ := tt.npp;
                    IF (tt.locked_by_robot_id = rid_) THEN
                        cnt1 := cnt1 + 1;
                    ELSE
                        EXIT;
                    END IF;
                END LOOP;
                IF (cnpp__ = 0) THEN -- дошли до нуля
                    FOR tt IN (
                        SELECT *
                            FROM track
                            WHERE repository_part_id = rr.repository_part_id
                            ORDER BY npp DESC
                    ) LOOP
                        cnpp__ := tt.npp;
                        IF (tt.locked_by_robot_id = rid_) THEN
                            cnt1 := cnt1 + 1;
                        ELSE
                            EXIT;
                        END IF;
                        EXIT WHEN cnt1 >= rr.max_npp;
                    END LOOP;
                END IF;
            ELSE -- по часовой
                cnt2 := 0;
                FOR tt IN (
                    SELECT *
                        FROM track
                        WHERE repository_part_id = rr.repository_part_id
                            AND npp > rr.current_track_npp
                        ORDER BY npp
                ) LOOP
                    cnpp__ := tt.npp;
                    IF (tt.locked_by_robot_id = rid_) THEN
                        cnt2 := cnt2 + 1;
                    ELSE
                        EXIT;
                    END IF;
                END LOOP;
                IF (cnpp__ = rr.max_npp) THEN -- дошли до MAX
                    FOR tt IN (
                        SELECT *
                            FROM track
                            WHERE repository_part_id = rr.repository_part_id
                            ORDER BY npp
                    ) LOOP
                        cnpp__ := tt.npp;
                        IF (tt.locked_by_robot_id = rid_) THEN
                            cnt2 := cnt2 + 1;
                        ELSE
                            EXIT;
                        END IF;
                        EXIT WHEN cnt2 >= rr.max_npp;
                    END LOOP;
                END IF;
            END IF;
        END LOOP;
        IF (cnt1 > rr.sor) AND (cnt2 > rr.sor) THEN
            RETURN 1;
        END IF;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_robot_lock_bad(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_robot_lock_bad(bigint)
    IS 'плохая блокировка робота?';


CREATE OR REPLACE FUNCTION obj_rpart.track_order_lock(
    rid_ bigint,
    to_id_ bigint,
    OUT npp_to_sorb__ bigint,
    OUT crp_npp__ bigint,
    OUT crp_dir__ bigint,
    OUT res bigint)
    RETURNS record
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    ttl__ BIGINT;
    br_id_ BIGINT;
    rr RECORD;
    tor track_order;
    to_ track_order;
BEGIN
    FOR rr IN (
        SELECT r.*, spacing_of_robots
            FROM robot r
            INNER JOIN repository_part rp
                ON r.repository_part_id = rp.id
            WHERE r.id = rid_
    ) LOOP
        -- проверяем, что заявка не самая свежая
        FOR tor IN (
            SELECT *
                FROM track_order
                WHERE repository_part_id = rr.repository_part_id
                ORDER BY id
        ) LOOP
            IF (tor.robot_id = rid_) THEN
                PERFORM obj_robot.log(rid_,'  отбой прогона, самая свежая заявка от этого робота');
                res := -1;
                RETURN;
            END IF;
            EXIT;
        END LOOP;
        FOR to_ IN (
            SELECT *
                FROM track_order
                WHERE id = to_id_
        ) LOOP
            crp_npp__ := -1;
            SELECT * INTO crp_npp__, crp_dir__
                FROM obj_rpart.get_cmd_rp_npp_dir(rid_);
            IF coalesce(rr.command_rp_id, 0) > 0 AND crp_npp__ >= 0 THEN
                IF crp_dir__ = to_.direction
                    AND obj_rpart.is_track_locked(rid_, crp_npp__, crp_dir__, 1) = 1
                THEN
                    PERFORM obj_robot.log(rid_, '  отбой прогона, можно тиснуть команду ' || rr.command_rp_id
                        || ' до трека ' || crp_npp__
                        || ' dir=' || crp_dir__);
                    res := -2;
                    RETURN;
                END IF;
                IF obj_rpart.is_track_locked(rid_, crp_npp__, crp_dir__, 0) = 1 THEN
                    PERFORM obj_robot.log(rid_, '  отбой прогона, целевой трек и так заблокирован');
                    res := -2;
                    RETURN;
                END IF;
            END IF;
            npp_to_sorb__ := obj_rpart.add_track_npp(
                rr.repository_part_id, to_.npp_to,
                rr.spacing_of_robots + 1, to_.direction
            );
            SELECT *
                INTO br_id_, ttl__
                FROM obj_rpart.try_track_lock(rid_, npp_to_sorb__, to_.direction, true);
            res := ttl__;
            RETURN;
        END LOOP;
    END LOOP;
END;
$BODY$;
ALTER FUNCTION obj_rpart.track_order_lock(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.track_order_lock(bigint, bigint)
    IS 'заявка на блокировку трека';


CREATE OR REPLACE FUNCTION obj_rpart.robot_track_lock_only_around(
    rid_ bigint)
    RETURNS boolean
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    sr__ BIGINT;
    l__ BIGINT;
    r__ BIGINT;
    lrb__ BIGINT;
    rrb__ BIGINT;
    rr RECORD;
BEGIN
    FOR rr IN (
        SELECT r.repository_part_id , rp.spacing_of_robots, current_track_npp
            FROM robot r
            INNER JOIN repository_part rp
                ON r.repository_part_id = rp.id
            WHERE r.id = rid_
    ) LOOP
        sr__ := rr.spacing_of_robots + 1;
        l__ := obj_rpart.add_track_npp(rr.repository_part_id, rr.current_track_npp, sr__, 0);
        r__ := obj_rpart.add_track_npp(rr.repository_part_id, rr.current_track_npp, sr__, 1);
        SELECT locked_by_robot_id INTO lrb__
            FROM track
            WHERE repository_part_id = rr.repository_part_id
                AND npp = l__;
        SELECT locked_by_robot_id INTO rrb__
            FROM track
            WHERE repository_part_id = rr.repository_part_id
                AND npp = r__;
        RETURN (lrb__ <> rid_ AND rrb__ <> rid_);
    END LOOP;
    RETURN false; -- Should be unreachable
END;
$BODY$;
ALTER FUNCTION obj_rpart.robot_track_lock_only_around(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.robot_track_lock_only_around(bigint)
    IS 'заблокировано ли крайние треки в шлейфе робота?';


CREATE OR REPLACE FUNCTION obj_rpart.robot_stop_drive_away_try(
    rid_ bigint,
    tor_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    npp_to_sorb__ BIGINT;
    ttl__ BIGINT;
    ttl_nb__ BIGINT;
    m_cell_sname__ TEXT;
    crp_npp__ BIGINT;
    crp_dir__ BIGINT;
    rr RECORD;
    to__ track_order;
    toa__ track_order;
BEGIN
    IF obj_robot.is_robot_ready_for_cmd_inner(rid_) = 1 THEN
        FOR rr IN (
            SELECT r.repository_part_id, spacing_of_robots, r.current_track_npp, current_track_id
                FROM robot r
                INNER JOIN repository_part rp
                    ON r.repository_part_id = rp.id
                WHERE r.id = rid_
        ) LOOP
            PERFORM obj_robot.log(rid_, 'Робот готов для команд новых, прогоняем его нафиг');
            FOR to__ IN (
                SELECT *
                    FROM track_order
                    WHERE id = tor_id_
            ) LOOP
                SELECT * INTO npp_to_sorb__, crp_npp__, crp_dir__, ttl__
                    FROM obj_rpart.track_order_lock(rid_, to__.id);
                IF (ttl__ >= 0) THEN -- можно двинуться хоть чутка
                    -- анализируем, может нужно менять направление команды?
                    IF obj_rpart.is_track_locked(rid_, crp_npp__, obj_rpart.get_another_direction(crp_dir__), 0) = 1 THEN
                        PERFORM obj_robot.log(rid_, '  отбой прогона, меняем направление команды');
                        PERFORM obj_rpart.robot_cmd_rp_change_dir(rid_);
                        RETURN 3;
                    END IF;
                    ttl_nb__ := obj_rpart.get_track_npp_not_baned(
                        rr.repository_part_id,
                        ttl__,
                        obj_rpart.get_another_direction(to__.direction)
                    ); -- crp_dir__
                    IF (ttl_nb__ <> rr.current_track_npp) THEN
                        PERFORM obj_robot.log(rid_, '  ttl__=' || ttl__ || ' ttl_nb__=' || ttl_nb__);
                        m_cell_sname__ := obj_rpart.get_cell_name_by_track_npp(ttl_nb__, rr.repository_part_id);
                        IF obj_rpart.is_track_locked(rid_, ttl_nb__, to__.direction) = 1 THEN
                            PERFORM obj_robot.set_command_inner(
                                rid_, 0, 1, 6, to__.direction,
                                obj_rpart.get_cell_name_by_track_id(rr.current_track_id),
                                m_cell_sname__,
                                'MOVE ' || m_cell_sname__ || ';' || obj_rpart.get_cmd_dir_text(to__.direction)
                            );
                            RETURN 1;
                        ELSE
                            PERFORM obj_robot.log(rid_, '  движение к забаненной точке невозможно! Ждем освобождения! ');
                            RETURN 0;
                        END IF;
                    ELSE
                        PERFORM obj_robot.log(rid_, '  не можем двинуться - трек среди запрещенных к MOVE и он один');
                        RETURN 0;
                    END IF;
                ELSE -- проблема при блокировке по треку
                    IF (ttl__ = -1) THEN -- тупо не можем сдвинуться
                        FOR toa__ IN (
                            SELECT *
                                FROM track_order
                                WHERE repository_part_id = rr.repository_part_id
                                    AND robot_id <> rid_
                                    AND robot_stop_id <> rid_
                        ) LOOP
                            IF (
                                obj_rpart.is_track_part_between(
                                    toa__.id,
                                    obj_rpart.add_track_npp(
                                        rr.repository_part_id, rr.current_track_npp,
                                        rr.spacing_of_robots, 0
                                    ),
                                    obj_rpart.add_track_npp(
                                        rr.repository_part_id, rr.current_track_npp,
                                        rr.spacing_of_robots, 1
                                    ),
                                    1
                                ) AND (
                                    obj_rpart.robot_track_lock_only_around(rid_)
                                ) -- что типа тупо стоим ждем
                            ) THEN
                                RETURN 4; -- нужно ждать
                            END IF;
                        END LOOP;
                        RETURN 0; -- нужно двигаться, но не можем
                    ELSE -- и не надо двигаться
                        RETURN 3; -- и не нужно двигаться, есть тут еще дела
                    END IF;
                END IF;
            END LOOP;
            /*
            -- проверяем, а нет ли более свежей заявки
            for tor in (select * from track_order where repository_part_id=rr.repository_part_id order by id) loop
                if tor.robot_id=rid_ then
                    obj_robot.Log(rid_,'  отбой прогона, самая свежая заявка от этого робота');
                    return;
            end if;
            exit;
            end loop;
            -- проверяем, а нет ли команды "по пути"
            for crp in (select crp.* from robot r, command_rp crp where r.id=rid_ and crp.id=command_rp_id) loop
                if nvl(crp.substate,0) in (0,1,2) then -- только начала выполняться или уже доехали
                    crp_npp__:=crp.npp_src;
                    crp_dir__:=crp.direction_1;
                else
                    crp_npp__:=crp.npp_dest;
                    crp_dir__:=crp.direction_2;
            end if;
            if crp_dir__=dir_ and is_track_locked(rid_,crp_npp__,crp_dir__,1)=1 then
                obj_robot.Log(rid_,'  отбой прогона, можно тиснуть команду '||crp.id||' до трека '||crp_npp__||' dir='||crp_dir__);
                return;
            end if;
            if is_track_locked(rid_,crp_npp__,crp_dir__,0)=1 then
                obj_robot.Log(rid_,'  отбой прогона, целевой трек и так заблокирован');
                return;
            end if;
            end loop;
            npp_to_sorb__:=add_track_npp(rr.repository_part_id, npp_to_,rr.spacing_of_robots+1, dir_);
            ttl__:=Try_Track_Lock(rid_ , npp_to_sorb__, dir_ );
            if ttl__=npp_to_sorb__ then
                m_cell_sname__:=Get_Cell_Name_By_Track_Npp(npp_to_sorb__, rr.repository_part_id);
            elsif ttl__<>rr.current_track_npp and ttl__>=0 then
            else
                obj_robot.Log(rid_,'ERROR - Не могу прогнаться, все заблокировано');
                return;
            end if;
             */
        END LOOP;
    END IF;
    -- FIXME: There should be some logic to handle ELSE
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.robot_stop_drive_away_try(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.robot_stop_drive_away_try(bigint, bigint)
    IS 'пытаемся прогнать робота, который мешает двинуться
=0, не можем двинуться
=1, прогнали явно
=3, есть по направлению команда (или по смененнному), отбой прогона, и так уйдем
=4, надо ждать цепочки событий с заявок ';


CREATE OR REPLACE FUNCTION obj_rpart.container_change_placement(
    bc_ text,
    rp_id_ bigint,
    cell_id_ bigint)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cc container;
BEGIN
    FOR cc IN (
        SELECT *
            FROM container
            WHERE barcode = bc_
    ) LOOP
        IF coalesce(cc.cell_id, 0) = coalesce(cell_id_, 0) THEN
            RAISE EXCEPTION 'Контейнер % и так находится в указанной ячейке!', bc_
                USING errcode = 50012;
        END IF;
        UPDATE cell
            SET is_full = 0, container_id = 0
            WHERE id = coalesce(cc.cell_id, 0);
        UPDATE container
            SET cell_id = cell_id_, location = 1
            WHERE id = cc.id;
        UPDATE cell
            SET is_full = 1, container_id = cc.id
            WHERE id = cell_id_;
        PERFORM service.add_shelving_need_to_redraw(
            obj_rpart.get_cell_shelving_id(coalesce(cc.cell_id, 0))
        );
        PERFORM service.add_shelving_need_to_redraw(
            obj_rpart.get_cell_shelving_id(coalesce(cell_id_, 0))
        );
        RETURN;
    END LOOP;
    RAISE EXCEPTION 'Контейнер % не найден!', bc_
        USING errcode = 50012;
END;
$BODY$;
ALTER FUNCTION obj_rpart.container_change_placement(text, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.container_change_placement(text, bigint, bigint)
    IS 'назначить новое место реального расположения контейнера';


CREATE OR REPLACE FUNCTION obj_rpart.inc_npp(
    cur_npp bigint,
    dir bigint,
    rp_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    next_npp BIGINT;
    -- rp_rec_min_npp BIGINT;
    rp_rec_max_npp BIGINT;
BEGIN
    SELECT max(npp)
        INTO rp_rec_max_npp
        FROM track
        WHERE repository_part_id = rp_id_;
    IF (dir = 1) THEN -- по часовой
        IF (cur_npp < rp_rec_max_npp) THEN
            next_npp := cur_npp + 1;
        ELSIF (cur_npp = rp_rec_max_npp) THEN
            next_npp := 0;
        -- ELSE
            --if emu_log_level>=1 then emu_log('  inp: Error cur_npp='||cur_npp); end if;
            --null;
        END IF;
    ELSE
        IF (cur_npp > 0) THEN
            next_npp := cur_npp - 1;
        ELSIF (cur_npp = 0) THEN
            next_npp := rp_rec_max_npp;
        -- ELSE
            --if emu_log_level>=1 then emu_log('  inp: Error cur_npp='||cur_npp); end if;
            --null;
        END IF;
    END IF;
    RETURN next_npp;
end;
$BODY$;
ALTER FUNCTION obj_rpart.inc_npp(bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.inc_npp(bigint, bigint, bigint)
    IS 'увеличивает указанный трек на 1 по направлению';

-- vim: ft=pgsql
