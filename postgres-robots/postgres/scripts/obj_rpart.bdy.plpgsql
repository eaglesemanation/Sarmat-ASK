CREATE OR REPLACE FUNCTION obj_rpart.get_log_file_name(
    rp_id_ numeric)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    RETURN 'rp_ora_' || rp_id_ || '_' || to_char(LOCALTIMESTAMP, 'DDMMYY') || '.log';
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_log_file_name(numeric) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_log_file_name(numeric)
    IS 'Generates log filename based on sub warehouse id.
получить имя файла лога';


CREATE OR REPLACE PROCEDURE obj_rpart.log(
    rp_id_ numeric,
    txt_ text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    filename TEXT;
BEGIN
    filename := obj_rpart.get_log_file_name(rp_id_);
    PERFORM pg_catalog.pg_file_write(
        filename,
        to_char(LOCALTIMESTAMP, 'HH24:MI:SS.MS') || ' ' || txt_ || E'\n',
        true
    );
END;
$BODY$;
COMMENT ON PROCEDURE obj_rpart.log(numeric, text)
    IS 'Logs timestamped entry into file specific to current sub warehouse.
процедура ведения журнала';


CREATE OR REPLACE FUNCTION obj_rpart.get_another_direction(
    direction_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    IF (direction_ = 1) THEN
        RETURN 0;
    ELSE
        RETURN 1;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_another_direction(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_another_direction(bigint)
    IS 'получить иное, чем указанное, направление движения робота';


CREATE OR REPLACE FUNCTION obj_rpart.get_cell_name_by_track_id(
    track_id_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res__ TEXT;
BEGIN
    SELECT cell_sname INTO res__
        FROM track
        WHERE id = track_id_;
    RETURN res__;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cell_name_by_track_id(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cell_name_by_track_id(bigint)
    IS 'получить имя ячейки по ID трека (для команды робота move)';


CREATE OR REPLACE FUNCTION obj_rpart.get_cell_track_npp(
    cell_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cc cell;
BEGIN
    FOR cc IN (
        SELECT track_npp
            FROM cell
            WHERE id = cell_id_
    ) LOOP
        RETURN cc.track_npp;
    END LOOP;
    RETURN null;
end;
$BODY$;
ALTER FUNCTION obj_rpart.get_cell_track_npp(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cell_track_npp(bigint)
    IS 'взять номер трека по ID ячейки';


CREATE OR REPLACE FUNCTION obj_rpart.calc_track_free_cell(
    rpid_ bigint,
    track_npp_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cnt_ BIGINT;
BEGIN
    SELECT count(*) INTO cnt_
        FROM cell
        WHERE repository_part_id = rpid_
            AND track_npp = track_npp_
            AND hi_level_type = 1
            AND is_full = 0
            AND NOT exists(
                SELECT *
                    FROM cell_cmd_lock
                    WHERE cell_id = cell.id
            );
    RETURN cnt_;
END;
$BODY$;
ALTER FUNCTION obj_rpart.calc_track_free_cell(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.calc_track_free_cell(bigint, bigint)
    IS 'посчитать сколько в треке соводных ячеек для хранения';


CREATE OR REPLACE FUNCTION obj_rpart.get_cmd_max_priority(
    rp_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cnt BIGINT;
    res BIGINT;
BEGIN
    SELECT count(*) INTO cnt
        FROM command_rp
        WHERE state IN (0,1)
            AND command_type_id = 3
            AND rp_id = rp_id_
            AND date_time_begin IS null;
    IF (cnt = 0) THEN -- нет запущенных команд
        RETURN 0;
    ELSE
        SELECT coalesce(max(priority), 0) INTO res
            FROM command_rp
            WHERE command_type_id = 3
                AND state IN (0,1)
                AND rp_id = rp_id_
                AND date_time_begin IS null;
        RETURN res;
    END IF;
    RETURN 0;
EXCEPTION WHEN others THEN
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cmd_max_priority(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cmd_max_priority(bigint)
    IS 'получить максимальный приоритет активной команды по подскладу';


CREATE OR REPLACE FUNCTION obj_rpart.get_cmd_dir_text(
    dir_ bigint)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
BEGIN
    IF (dir_ = 1) THEN
        RETURN '';
    ELSE
        RETURN 'CCW';
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cmd_dir_text(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cmd_dir_text(bigint)
    IS 'получить по ID направления кусок команды в текстовом виде для отдачи роботу';


CREATE OR REPLACE PROCEDURE obj_rpart.get_next_npp(
    rp_type bigint,
    max_npp bigint,
    cur_npp bigint,
    npp_to bigint,
    dir bigint,
    INOUT next_npp bigint,
    INOUT is_loop_end bigint)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    is_loop_end := 0;
    IF (cur_npp = npp_to) THEN
        is_loop_end := 1;
    END IF;
    -- Clockwise
    IF (dir = 1) THEN -- по часовой
        IF (cur_npp < max_npp) THEN
            next_npp:= cur_npp+1;
        ELSIF (cur_npp = max_npp) THEN -- Reached edge
            -- Line
            IF (rp_type = 0) THEN -- линейный
                next_npp := cur_npp;
                is_loop_end := 1;
            -- Cyclic
            ELSE
                next_npp := 0;
            END IF;
        --ELSE
            --if emu_log_level>=1 then emu_log('  gnp: Error cur_npp='||cur_npp); end if;
        END IF;
    -- Counterclockwise
    ELSE
        IF (cur_npp > 0) THEN
            next_npp := cur_npp - 1;
        ELSIF (cur_npp = 0) THEN -- Reached edge
            IF (rp_type = 0) THEN -- Line
                next_npp := cur_npp;
                is_loop_end := 1;
            ELSE
                next_npp:=max_npp;
            END IF;
        --ELSE
            --if emu_log_level>=1 then emu_log('  gnp: Error cur_npp='||cur_npp); end if;
        END IF;
    END IF;
END;
$BODY$;
COMMENT ON PROCEDURE obj_rpart.get_next_npp(bigint, bigint, bigint, bigint, bigint, bigint, bigint)
    IS 'Get next track number in set direction.
взять следующий № трека по направлению (и высчитать, не пришди ли уже куда надо)';


CREATE OR REPLACE FUNCTION obj_rpart.add_track_npp(
    rp_id_ bigint,
    npp_from_ bigint,
    npp_num_ bigint,
    dir_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    k_ BIGINT;
    inc_ BIGINT;
    rp RECORD;
BEGIN
    FOR rp IN (
        SELECT num_of_robots, spacing_of_robots, repository_type, max_npp
             FROM repository_part WHERE id = rp_id_
    ) LOOP
        k_ := npp_from_;
        inc_ := npp_num_;
        -- FIXME: Isn't that trivially solvable with modulus?
        LOOP
            -- Clockwise
            IF (dir_ = 1) THEN -- по часовой стрелке
                IF (k_ = rp.max_npp) THEN -- достигли максимума
                    -- Line, edge reached
                    IF (rp.repository_type = 0) THEN -- склад линейный
                        RETURN rp.max_npp;
                    -- Cyclic, looping over
                    ELSE -- склад кольцевой, начинаем сначала
                        k_:=0;
                        inc_:=inc_-1;
                    END IF;
                ELSE
                    k_:=k_+1;
                    inc_:=inc_-1;
                END IF;
            -- Counterclockwise
            ELSE -- против часовой стрелке
                IF (k_ = 0) THEN -- достигли минимума
                    -- Line, edge reached
                    IF (rp.repository_type = 0) THEN -- склад линейный
                        RETURN 0;
                    -- Cyclic, looping over
                    ELSE -- склад кольцевой, начинаем с конца
                        k_ := rp.max_npp;
                        inc_ := inc_-1;
                    END IF;
                ELSE
                    k_ := k_-1;
                    inc_ := inc_-1;
                END IF;
            END IF;
            EXIT WHEN inc_ = 0;
        END LOOP;
    END LOOP;
    RETURN k_;
END;
$BODY$;
ALTER FUNCTION obj_rpart.add_track_npp(bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.add_track_npp(bigint, bigint, bigint, bigint)
    IS 'Adds section to track.
примитив для добавления к номеру трека столько-то секций';


-- FIXME: Duplicate of obj_ask.calc_distance
CREATE OR REPLACE FUNCTION obj_rpart.calc_min_distance(
    rp_type bigint,
    max_npp bigint,
    n1 bigint,
    n2 bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BIGINT;
    nn1 BIGINT;
    nn2 BIGINT;
BEGIN
    IF (n2 < n1) THEN
        nn1 := n2;
        nn2 := n1;
    ELSE
        nn1 := n1;
        nn2 := n2;
    END IF;
    res := nn2 - nn1;
    IF (rp_type = 1) THEN -- только для кольцевого
        IF (max_npp - nn2 + nn1) < res THEN
            res := max_npp - nn2 + nn1;
        END IF;
    END IF;
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_rpart.calc_min_distance(bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.calc_min_distance(bigint, bigint, bigint, bigint)
    IS 'вычисляет расстояние между двумя треками npp по оптимальному направлению';


CREATE OR REPLACE FUNCTION obj_rpart.correct_npp_to_track_order(
    rid_ bigint,
    to_rid_ bigint,
    dir_ bigint,
    npp_to_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    npp_to_ar BIGINT;
    ro_ RECORD;
BEGIN
    FOR ro_ IN (
        SELECT rp.num_of_robots, spacing_of_robots, rp.id rpid
        FROM robot_order ro
        INNER JOIN robot r
            ON ro.robot_id = r.id
        INNER JOIN repository_part rp
            ON r.repository_part_id = rp.id
        WHERE corr_robot_id = to_rid_
        AND dir = dir_
        AND r.id = rid_
    ) LOOP
        IF (ro_.num_of_robots > 0) THEN
            npp_to_ar := obj_rpart.add_track_npp(ro_.rpid, npp_to_, ro_.num_of_robots * (ro_.spacing_of_robots * 2 + 1), dir_);
        ELSE
            npp_to_ar := npp_to_;
        END IF;
        RETURN npp_to_ar;
    END LOOP;
    RETURN npp_to_;
END;
$BODY$;
ALTER FUNCTION obj_rpart.correct_npp_to_track_order(bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.correct_npp_to_track_order(bigint, bigint, bigint, bigint)
    IS 'корректируем заявку на блокировку трека по вновь открывшимся обстоятельствам';


CREATE OR REPLACE PROCEDURE obj_rpart.add_check_point(
    rp_id_ bigint,
    sorb_ bigint,
    robot_id_ bigint,
    dir_ bigint,
    track_npp_ bigint)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    tr_ BIGINT;
    ci RECORD;
BEGIN
    FOR ci IN (
        SELECT * FROM command_inner
        WHERE robot_id = robot_id_
        AND STATE IN (0,1,3,4)
        AND coalesce(check_point, -1) >= 0
    ) LOOP
        tr_ := obj_rpart.add_track_npp(rp_id_, track_npp_, sorb_, obj_rpart.get_another_direction(dir_));
        INSERT INTO command_inner_checkpoint(command_inner_id, npp)
            VALUES(ci.id, tr_);
    END LOOP;
END;
$BODY$;
COMMENT ON PROCEDURE obj_rpart.add_check_point(bigint, bigint, bigint, bigint, bigint)
    IS 'Adds checkpoint for robot if it''s supported
добавить промежуточную точку для робота, если он поддерживает';


CREATE OR REPLACE FUNCTION obj_rpart.get_track_npp_by_id(
    id_ numeric)
    RETURNS numeric
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    npp_ numeric;
BEGIN
    SELECT npp INTO npp_ FROM track WHERE id = id_;
    RETURN npp_;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_track_npp_by_id(numeric) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_track_npp_by_id(numeric)
    IS 'взять ID трека по его номеру на конкретном огурце';


CREATE OR REPLACE PROCEDURE obj_rpart.unlock_track(
    robot_id_ bigint,
    rp_id_ bigint,
    npp_from_ bigint,
    npp_to_ bigint,
    dir_ bigint)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rrp RECORD;
    ord RECORD;
    errmm TEXT;
    npp1_ BIGINT;
    npp2_ BIGINT;
    npp2 BIGINT;
    tr_npp BIGINT;
    tr_id BIGINT;
    tr_locked_by_robot_id BIGINT;
    is_loop_exit BIGINT;
BEGIN
    FOR rrp IN (
        SELECT rp.id rpid_, spacing_of_robots sorb, max_npp, repository_type rpt, num_of_robots
            FROM repository_part rp
            WHERE rp.id = rp_id_
    ) LOOP
        CALL obj_rpart.log(rrp.rpid_, 'unlock_track: пришла npp_from_=' || npp_from_ || '; npp_to_=' || npp_to_ || '; direction=' || dir_ || '; robot.id=' || robot_id_);
        IF (npp_from_ = npp_to_) THEN
            CALL obj_rpart.log(rrp.rpid_, '  нет смысла сразу npp_from_=' || npp_from_ || '; npp_to_=' || npp_to_ || '; direction=' || dir_ || '; robot.id=' || robot_id_);
            RETURN;
        END IF;
        -- FIXME: confusing naming
        npp2 := obj_rpart.add_track_npp(rrp.rpid_, npp_to_, 1, obj_rpart.get_another_direction(dir_));
        npp1_ := obj_rpart.add_track_npp(rrp.rpid_, npp_from_, rrp.sorb, obj_rpart.get_another_direction(dir_));
        npp2_ := obj_rpart.add_track_npp(rrp.rpid_, npp2, rrp.sorb, obj_rpart.get_another_direction(dir_));
        IF (rrp.rpt = 0) AND (npp_to_ <= rrp.sorb) AND (dir_ = 1) THEN
            null;
        ELSEIF (rrp.rpt = 0) AND (npp_to_ >= rrp.max_npp - rrp.sorb) AND (dir_ = 0) THEN
            null;
        ELSE
            tr_npp := npp1_;
            LOOP
                SELECT id, locked_by_robot_id
                    INTO tr_id, tr_locked_by_robot_id
                    FROM track
                    WHERE npp = tr_npp AND repository_part_id = rrp.rpid_;
                IF coalesce(tr_locked_by_robot_id, 0) NOT IN (robot_id_, 0) THEN
                    errmm := 'ERROR - Ошибка ошибка разблокировки трека ' || tr_npp || '! locked by ' || coalesce(tr_locked_by_robot_id,0);
                    CALL obj_rpart.log(rrp.rpid_, errmm);
                    RAISE EXCEPTION '%', errmm USING errcode = 50012;
                END IF;
                UPDATE track SET locked_by_robot_id = 0 WHERE id = tr_id;
                -- Fulfil orders and delete them
                -- освобождаем заявки их удовлетворяя
                FOR ord IN (
                    SELECT * FROM track_order
                        WHERE tr_npp = npp_from
                        AND robot_id <> robot_id_
                        AND repository_part_id = rrp.rpid_
                        ORDER BY id
                ) LOOP
                    CALL obj_rpart.log(rrp.rpid_,'  есть заявка =' || ord.id || ' - освобождаем');
                    UPDATE track SET locked_by_robot_id = ord.robot_id WHERE id = tr_id;
                    CALL obj_rpart.add_check_point(ord.repository_part_id, rrp.sorb, ord.robot_id, ord.direction, tr_npp);
                    -- Order is fulfilled
                    IF ord.npp_from = ord.npp_to THEN -- нет нужды в этой заявке - удаляем ее
                        DELETE FROM track_order WHERE id = ord.id;
                        CALL obj_rpart.log(rrp.rpid_,'  уже все выбрано по заявке - удаляем');
                    -- Still fulfilling
                    ELSE -- еще есть нужда в заявке - уменьшаем ее размер
                        IF ord.npp_from = tr_npp THEN
                            CALL obj_rpart.log(rrp.rpid_,'  уменьшаем заявку трек ' || tr_npp);
                            npp1_ := obj_rpart.add_track_npp(rrp.rpid_, tr_npp, 1, ord.direction);
                            UPDATE track_order SET npp_from=npp1_ WHERE id = ord.id;
                        END IF;
                    END IF;
                END LOOP;
                CALL obj_rpart.get_next_npp(rrp.rpt, rrp.max_npp, tr_npp, npp2_, dir_, tr_npp, is_loop_exit);
                EXIT WHEN is_loop_exit = 1;
            END LOOP;
        END IF;
    END LOOP;
END;
$BODY$;
COMMENT ON PROCEDURE obj_rpart.unlock_track(bigint, bigint, bigint, bigint, bigint)
    IS 'Unlocks track by fulfilling track orders.
вызывается из триггера при смене текущего трека; нужно передавать rp_id_, чтобы не было мутации';


CREATE OR REPLACE PROCEDURE obj_rpart.unlock_track_after_cmd_error(
    robot_id_ bigint)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    rr robot;
    npp1 BIGINT;
    npp2 BIGINT;
    tr_id BIGINT;
    tr_npp BIGINT;
    tr_locked_by_robot_id BIGINT;
    max_npp_ BIGINT;
    is_loop_exit BIGINT;
    sorb BIGINT;
    rpt BIGINT;
BEGIN
    SELECT * INTO rr
        FROM robot
        WHERE id = robot_id_;
    SELECT spacing_of_robots, max_npp, repository_type
        INTO sorb, max_npp_, rpt
        FROM repository_part
        WHERE id = rr.repository_part_id;
    IF (rpt = 0) THEN
        -- нет смысла замарачиваться с блокировкой на линейный склад
        RETURN;
    END IF;
    CALL obj_rpart.log(rr.repository_part_id, 'unlock_track_after_cmf_error: robot.id=' || robot_id_);
    npp1 := obj_rpart.inc_spacing_of_robots(
        rr.current_track_npp,
        1,
        sorb + 1,
        rr.repository_part_id
    );
    npp2 := obj_rpart.inc_spacing_of_robots(
        rr.current_track_npp,
        obj_rpart.get_another_direction(1),
        sorb + 1,
        rr.repository_part_id
    );
    --log_track(rr.repository_part_id);
    tr_npp := npp1;
    LOOP
        SELECT id, locked_by_robot_id
            INTO tr_id, tr_locked_by_robot_id
            FROM track
            WHERE npp = tr_npp
                AND repository_part_id = rr.repository_part_id;
        --log_ut_step(4,'  ttle: tr_npp='||tr_npp);
        IF coalesce(tr_locked_by_robot_id, 0) IN (robot_id_) THEN
            UPDATE track SET locked_by_robot_id = 0 WHERE id = tr_id;
        END IF;
        CALL obj_rpart.get_next_npp(rpt, max_npp_, tr_npp, npp2, 1, tr_npp, is_loop_exit);
        EXIT WHEN is_loop_exit = 1;
    END LOOP;
    --log_track(rr.repository_part_id);
end;
$BODY$;
COMMENT ON PROCEDURE obj_rpart.unlock_track_after_cmd_error(bigint)
    IS 'разблокировать трек после ошибки команды робота';


CREATE OR REPLACE FUNCTION obj_rpart.is_way_free(
    robot_id_ bigint,
    npp_d bigint,
    dir bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    r RECORD;
    rp RECORD;
    cnpp BIGINT;
    ll BIGINT;
    dnppsorb BIGINT;
    is_dest_npp_reached BOOLEAN;
BEGIN
    is_dest_npp_reached := false;
    FOR r IN (
        SELECT *
            FROM robot
            WHERE id = robot_id_
    ) LOOP
        CALL obj_rpart.log(r.repository_part_id, 'is_way_free: robot_id_=' || robot_id_ || ' ' || npp_d || ' ' || dir);
        FOR rp IN (
            SELECT repository_type, id, max_npp, spacing_of_robots sorb, num_of_robots
                FROM repository_part
                WHERE id = r.repository_part_id
        ) LOOP
            IF /*rp.repository_type =0 or */rp.num_of_robots=1 THEN -- один робот - всегда все свободно
                RETURN 1;
            END IF;
            cnpp := r.real_npp; --r.current_track_npp;
            IF (cnpp = npp_d) THEN
                RETURN 1; -- там же и стоим
            END IF;
            -- считаем максимум сколько нужно хапануть
            dnppsorb := obj_rpart.inc_spacing_of_robots(npp_d, dir, rp.sorb, rp.id, 0, rp.max_npp);
            CALL obj_rpart.log(r.repository_part_id, 'dnppsorb=' || dnppsorb);
            LOOP
                CALL obj_rpart.log(r.repository_part_id, '  cnpp=' || cnpp);
                IF (cnpp = npp_d) THEN
                    is_dest_npp_reached := true;
                    CALL obj_rpart.log(r.repository_part_id, '    is_dest_npp_reached:=true');
                END IF;
                EXIT WHEN cnpp = dnppsorb AND is_dest_npp_reached;
                IF (dir = 1) THEN -- по часовой
                    IF (rp.repository_type = 1) THEN -- для кольцевого склада
                        IF (cnpp = rp.max_npp) THEN
                            cnpp := 0;
                        ELSE
                            cnpp := cnpp + 1;
                        END IF;
                    ELSE  -- для линейного
                        IF (cnpp < rp.max_npp) THEN
                            cnpp := cnpp + 1;
                        ELSE
                            EXIT; -- выход из цикла
                        END IF;
                    END IF;
                ELSE -- против
                    IF (rp.repository_type = 1) THEN -- для кольцевого склада
                        IF cnpp=0 THEN
                            cnpp := rp.max_npp;
                        ELSE
                            cnpp := cnpp - 1;
                        END IF;
                    ELSE  -- для линейного
                        IF (cnpp > 0) THEN
                            cnpp := cnpp - 1;
                        ELSE
                            EXIT; -- выход из цикла
                        END IF;
                    END IF;
                END IF;
                -- dbms_output.put_line('cnpp='||cnpp);
                RAISE DEBUG 'cnpp=%', cnpp;
                SELECT locked_by_robot_id INTO ll
                    FROM track
                    WHERE repository_part_id = rp.id
                        AND npp = cnpp;
                IF (ll <> r.id) THEN -- ошибка
                    RETURN 0; -- путь не готов - ОШИБКА!!!
                END IF;
            END LOOP;
        END LOOP;
    END LOOP;
    RETURN 1; -- все проверено, мин нет
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_way_free(bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_way_free(bigint, bigint, bigint)
    IS 'проверка на свободность пути';


-- FIXME: Isn't that just inverted "is_way_free"? If not - confusing naming
CREATE OR REPLACE FUNCTION obj_rpart.is_way_locked(
    rp_id_ bigint,
    robot_id_ bigint,
    goal_npp bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    g1 BIGINT;
    g2 BIGINT;
    cur_npp BIGINT;
    -- dir BIGINT;
    g1_is BIGINT;
    g2_is BIGINT;
    rob_rec robot;
    sorb BIGINT;
    lbrid BIGINT;
BEGIN
    SELECT * INTO rob_rec FROM robot WHERE id = robot_id_;
    SELECT spacing_of_robots INTO sorb FROM repository_part WHERE id = rp_id_;
    --if emu_log_level>=2 then emu_log('  is_locked: id='||r(ro_num).id||'; goal_npp='||goal_npp); end if;
    g1 := obj_rpart.inc_spacing_of_robots(goal_npp, 1, sorb, rp_id_);
    g2 := obj_rpart.inc_spacing_of_robots(
        goal_npp,
        obj_rpart.get_another_direction(1),
        sorb,
        rp_id_
    );
    --if emu_log_level>=4 then emu_log('    il: g1='||g1||'; g2='||g2); end if;
    FOR dir IN 0..1 LOOP
        cur_npp := obj_rpart.inc_spacing_of_robots(
            rob_rec.current_track_npp,
            obj_rpart.get_another_direction(dir),
            sorb,
            rp_id_
        );
        g1_is := 0;
        g2_is := 0;
        LOOP
            --if emu_log_level>=4 then emu_log('    il: loop cur_npp='||cur_npp); end if;
            SELECT locked_by_robot_id INTO lbrid
                FROM track
                WHERE npp = cur_npp
                    AND repository_part_id = rp_id_;
            IF (lbrid <> rob_rec.id) THEN
                EXIT;
            END IF;
            IF (cur_npp = g1) THEN
                g1_is := 1;
            END IF;
            IF (cur_npp = g2) THEN
                g2_is := 1;
            END IF;
            EXIT WHEN g1_is = 1 AND g2_is = 1;
            cur_npp := obj_rpart.inc_npp(cur_npp, dir, rp_id_);
        END LOOP;
        IF (g1_is = 1) AND (g2_is = 1) THEN
            --if emu_log_level>=2 then emu_log('    il: return 1'); end if;
            RETURN 1;
        END IF;
    END LOOP;
    --if emu_log_level>=2 then emu_log('    il: return 0'); end if;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_way_locked(bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_way_locked(bigint, bigint, bigint)
    IS 'заблокирован ли путь для робота до цели?';


CREATE OR REPLACE FUNCTION obj_rpart.is_track_between(
    goal_npp numeric,
    npp_from numeric,
    npp_to numeric,
    dir numeric,
    rp_id_ numeric)
    RETURNS numeric
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp_rec_max_npp NUMERIC;
    rp_rec_min_npp NUMERIC;
BEGIN
    SELECT min(npp), max(npp) INTO rp_rec_min_npp, rp_rec_max_npp
        FROM track WHERE repository_part_id = rp_id_;
    -- Clockwise
    -- по часовой стрелке
    IF (dir = 1) THEN
        FOR i IN npp_from..rp_rec_max_npp LOOP
            IF (i = goal_npp) THEN
                RETURN 1;
            END IF;
            IF (i = npp_to) THEN
                RETURN 0;
            END IF;
        END LOOP;
        -- Looping over
        -- за конец
        FOR i IN rp_rec_min_npp..npp_to LOOP
            IF (i = goal_npp) THEN
                RETURN 1;
            END IF;
            IF (i = npp_to) THEN
                RETURN 0;
            END IF;
        END LOOP;
    -- Counterclockwise
    -- против часовой стрелке
    ELSE
        FOR i IN REVERSE rp_rec_min_npp..npp_from LOOP
            IF (i = goal_npp) THEN
                RETURN 1;
            END IF;
            IF (i = npp_to) THEN
                RETURN 0;
            END IF;
        END LOOP;
        -- Looping over
        -- за конец
        FOR i IN REVERSE npp_to..rp_rec_max_npp LOOP
            IF (i = goal_npp) THEN
                RETURN 1;
            END IF;
            IF (i = npp_to) THEN
                RETURN 0;
            END IF;
        END LOOP;
    END IF;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_track_between(numeric, numeric, numeric, numeric, numeric) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_track_between(numeric, numeric, numeric, numeric, numeric)
    IS 'указанный трек между двумя треками по направлению?';


CREATE OR REPLACE FUNCTION obj_rpart.get_cell_id_by_name(
    rp_id_ bigint,
    sname_ text)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BIGINT;
BEGIN
    SELECT id INTO res
    FROM cell
    WHERE sname = sname_ AND shelving_id IN (
        SELECT id FROM shelving WHERE track_id IN (
            SELECT id FROM track WHERE repository_part_id = rp_id_
        )
    );
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cell_id_by_name(bigint, text) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cell_id_by_name(bigint, text)
    IS 'взять ID ячейки по ее имени на конкретном огурце';


CREATE OR REPLACE FUNCTION obj_rpart.get_cell_shelving_id(
    cell_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    shelving_id_ BIGINT;
begin
    FOR shelving_id_ IN (
        SELECT shelving_id
            FROM cell
            WHERE id = cell_id_
    ) LOOP
        RETURN shelving_id_;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_cell_shelving_id(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_cell_shelving_id(bigint)
    IS 'получить ID стеллажа по ID ячейки';


CREATE OR REPLACE FUNCTION obj_rpart.get_track_id_by_cell_and_rp(
    rp_id_ bigint,
    sname_ text)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BIGINT;
BEGIN
    SELECT t.id INTO res
    FROM cell c
    INNER JOIN shelving s
        ON c.shelving_id = s.id
    INNER JOIN track t
        ON s.track_id = t.id
    WHERE c.sname = sname_ AND t.repository_part_id = rp_id_;
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_track_id_by_cell_and_rp(bigint, text) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_track_id_by_cell_and_rp(bigint, text)
    IS 'получить ID трека по огурцу и названию ячейки';


CREATE OR REPLACE FUNCTION obj_rpart.get_track_npp_by_cell_and_rp(
    rp_id_ bigint,
    sname_ text)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BIGINT;
BEGIN
    SELECT t.npp INTO res
    FROM cell c
    INNER JOIN shelving s
        ON c.shelving_id = s.id
    INNER JOIN track t
        ON s.track_id = t.id
    WHERE c.sname = sname_ AND t.repository_part_id = rp_id_;
    RETURN res;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_track_npp_by_cell_and_rp(bigint, text) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_track_npp_by_cell_and_rp(bigint, text)
    IS 'взять № трека по огурцу и названию ячейки';


CREATE OR REPLACE FUNCTION obj_rpart.calc_repair_robots(
    rpid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cnt_ BIGINT;
BEGIN
    SELECT count(*) INTO cnt_ FROM robot
        WHERE repository_part_id = rpid_
        AND state = obj_robot."ROBOT_STATE_REPAIR"();
    RETURN cnt_;
END;
$BODY$;
ALTER FUNCTION obj_rpart.calc_repair_robots(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.calc_repair_robots(bigint)
    IS 'сколько роботов на огурце находится в режиме починки?';


CREATE OR REPLACE FUNCTION obj_rpart.calc_distance_by_dir(
    rpid_ bigint,
    n1 bigint,
    n2 bigint,
    dir_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp RECORD;
    res BIGINT;
    nn BIGINT;
BEGIN
    IF (n1 = n2) THEN
        RETURN 0;
    END IF;
    FOR rp IN (
        SELECT repository_type, max_npp
        FROM repository_part
        WHERE id = rpid_
    ) LOOP
        -- Linear track
        IF (rp.repository_type = 0) THEN -- линейный
            IF (n2 < n1) AND (dir_ = 1)
                OR (n2 > n1) AND (dir_ = 0)
            THEN
                res := rp.max_npp * 100;
            ELSE
                res := abs(n2 - n1);
            END IF;
        -- Cyclic track
        ELSE -- кольцевой
            nn := n1;
            res := 0;
            LOOP
                res := res + 1;
                -- Clockwise
                IF (dir_ = 1) THEN -- по часовой
                    IF (nn = rp.max_npp) THEN
                        nn := 0;
                    ELSE
                        nn := nn+1;
                    END IF;
                -- Counterclockwise
                ELSE -- против
                    IF (nn = 0) THEN
                        nn := rp.max_npp;
                    ELSE
                        nn := nn - 1;
                    END IF;
                END IF;
                EXIT WHEN nn = n2;
            END LOOP;
        END IF;
    END LOOP;
    RETURN res;
end;
$BODY$;
ALTER FUNCTION obj_rpart.calc_distance_by_dir(bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.calc_distance_by_dir(bigint, bigint, bigint, bigint)
    IS 'вычисляет расстояние между двумя треками npp по указанному направлению';


CREATE OR REPLACE FUNCTION obj_rpart.get_rp_spacing_of_robots(
    rpid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp RECORD;
BEGIN
    FOR rp IN (
        SELECT spacing_of_robots FROM repository_part WHERE id = rpid_
    ) LOOP
        RETURN rp.spacing_of_robots;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_rp_spacing_of_robots(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_rp_spacing_of_robots(bigint)
    IS 'получить минимальное расстояние между роботами в огурце';


CREATE OR REPLACE FUNCTION obj_rpart.get_track_id_by_robot_and_npp(
    robot_id_ bigint,
    track_no bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    ctid BIGINT;
BEGIN
    SELECT id INTO ctid
        FROM track
        WHERE npp=track_no
        AND repository_part_id = (
            SELECT repository_part_id FROM robot WHERE id = robot_id_
        );
    RETURN ctid;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_track_id_by_robot_and_npp(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_track_id_by_robot_and_npp(bigint, bigint)
    IS 'получить ID трека по ID роботу и № трека';


CREATE OR REPLACE FUNCTION obj_rpart.inc_spacing_of_robots(
    npp_ bigint,
    direction bigint,
    spr bigint,
    rp_id_ bigint,
    minnppr bigint default -1,
    maxnppr bigint default -1)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    maxnpp BIGINT;
    minnpp BIGINT;
    rpt BIGINT;
BEGIN
    SELECT repository_type INTO rpt FROM repository_part WHERE id = rp_id_;
    IF (maxnppr <> -1) THEN
        maxnpp := maxnppr;
    ELSE
        SELECT max(npp) INTO maxnpp FROM track WHERE repository_part_id = rp_id_;
    END IF;
    IF (minnppr <> -1) THEN
        minnpp := minnppr;
    ELSE
        SELECT min(npp) INTO minnpp FROM track WHERE repository_part_id = rp_id_;
    END IF;
    IF (direction = 1) THEN -- по часовой стрелке
        IF (npp_ + spr <= maxnpp) THEN
            RETURN npp_ + spr;
        ELSE
            IF (rpt = 1) THEN  -- для кольцевого
                -- например, есть 0 1 2 3 4, мы стоим на 3, нужно увеличить на 2, 3+2-4-1
                RETURN npp_ + spr - maxnpp - 1;
            ELSE -- для линейного при перехлесте
                RETURN maxnpp;
            END IF;
        END IF;
    ELSE -- против часовой стрелке
        IF (npp_ - spr >= minnpp) THEN
            RETURN (npp_ - spr);
        ELSE
            IF (rpt = 1) THEN  -- для кольцевого
                -- например, есть 0 1 2 3 4, мы стоим на 1, нужно уменьшить на 2, 1-2+4+1
                RETURN npp_ - spr + maxnpp + 1;
            ELSE -- для линейного при самом начале
                RETURN minnpp;
            END IF;
        END IF;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.inc_spacing_of_robots(bigint, bigint, bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.inc_spacing_of_robots(bigint, bigint, bigint, bigint, bigint, bigint)
    IS 'возвращает номер участка пути увеличенное на spr секций';


CREATE OR REPLACE FUNCTION obj_rpart.get_rp_num_of_robots(
    rpid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp RECORD;
BEGIN
    FOR rp IN (
        SELECT num_of_robots FROM repository_part WHERE id = rpid_
    ) LOOP
        RETURN rp.num_of_robots;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_rp_num_of_robots(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_rp_num_of_robots(bigint)
    IS 'сколько в огурце роботов?';


CREATE OR REPLACE FUNCTION obj_rpart.is_track_near_repair_robot(
    rp_id_ bigint,
    npp_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rr RECORD;
    d1 BIGINT;
    d2 BIGINT;
    md BIGINT;
BEGIN
    FOR rr IN (
        SELECT * FROM robot
        WHERE state = obj_robot."ROBOT_STATE_REPAIR"()
        AND repository_part_id = rp_id_
    ) LOOP
        d1 := obj_rpart.calc_distance_by_dir(rp_id_, npp_, rr.current_track_npp, 0);
        d2 := obj_rpart.calc_distance_by_dir(rp_id_ , npp_, rr.current_track_npp, 1);
        md := obj_rpart.get_rp_spacing_of_robots(rp_id_) * (obj_rpart.get_rp_num_of_robots(rp_id_) - 1) * 2 +(obj_rpart.get_rp_num_of_robots(rp_id_) - 1);
        IF (d1 <= md) OR (d2 <= md) THEN
            RETURN 1;
        END IF;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_track_near_repair_robot(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_track_near_repair_robot(bigint, bigint)
    IS 'находится ли трек в шлейфе поломанного робота?';


CREATE OR REPLACE FUNCTION obj_rpart.get_another_robot_id(
    r_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BIGINT;
BEGIN
    SELECT id INTO res
        FROM robot
        WHERE id <> r_id_
        AND repository_part_id = (
            SELECT repository_part_id FROM robot WHERE id = r_id_
        );
    RETURN res;
EXCEPTION WHEN OTHERS THEN
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_another_robot_id(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_another_robot_id(bigint)
    IS 'получить id второго робота';


CREATE OR REPLACE FUNCTION obj_rpart.is_track_npp_ban_move_to(
    rp_id_ bigint,
    npp_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res_ BIGINT;
BEGIN
    SELECT coalesce(ban_move_to, 0) INTO res_ FROM track WHERE repository_part_id = rp_id_ AND npp = npp_;
    RETURN res_;
EXCEPTION WHEN OTHERS THEN
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_track_npp_ban_move_to(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_track_npp_ban_move_to(bigint, bigint)
    IS 'является ли трек запрещенным для команд Move туда?';


CREATE OR REPLACE FUNCTION obj_rpart.is_track_part_between(
    to_id_ bigint,
    npp_from bigint,
    npp_to bigint,
    dir bigint)
    RETURNS boolean
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    to_ RECORD;
BEGIN
    FOR to_ IN (SELECT * FROM track_order WHERE to_id_ = id) LOOP
        -- ->->
        IF ((to_.direction = 1) AND (dir = 1)) THEN -- заявка по часовой стеклки и часть трека по часовой стрелки
            IF (to_.npp_to < to_.npp_from) THEN -- заявка с перехлестом через 0
                IF (npp_to < npp_from) THEN -- участок с перехлестом через 0
                    RETURN true; -- оба перехлеста
                ELSE -- участок без перехлеста через 0
                    RETURN (npp_to >= to_.Npp_From) -- участок вначале попадает
                        OR (npp_from <= to_.Npp_To); -- участок вконце попадает
                END IF;
            ELSE -- без перехлеста через 0
                IF (npp_to < npp_from) THEN -- с перехлестом через 0
                    RETURN (npp_from <= to_.npp_to) -- участок сначала задевает заявку
                        OR (npp_to >= to_.npp_from); -- участок в конце задевает заявку
                ELSE -- без перехлеста через 0
                    RETURN (npp_to >= to_.npp_from AND npp_from <= to_.npp_from) -- участок вначале попадает
                        OR (npp_from >= to_.npp_from AND npp_to <= to_.npp_to) -- участок целиком попадает
                        OR (npp_from <= to_.npp_to AND npp_to >= to_.npp_to); -- участок справа попадает
                END IF;
            END IF;
        -- <-<-
        ELSIF ((to_.direction = 0) AND (dir = 0)) THEN -- заявка против часовой стрелки и часть трека против часовой стрелки
            IF (to_.npp_to < to_.npp_from) THEN -- заявка без перехлеста через 0
                IF (npp_to < npp_from) THEN -- участок без перехлеста через 0
                    RETURN (npp_from >= to_.npp_to AND npp_to <= to_.npp_to) -- участок слева попадает
                        OR (npp_from <= to_.npp_from AND npp_to >= to_.npp_to) -- участок целиком попадает
                        OR (npp_from >= to_.npp_from AND npp_to <= to_.npp_from); -- участок справа попадает
                ELSE -- с перехлестом участок через 0
                    RETURN (npp_from >= to_.npp_to) -- участок сначала задевает заявку
                        OR (npp_to <= to_.npp_from); -- участок в конце задевает заявку
                END IF;
            ELSE -- заявка с перехлестом через 0
                IF (npp_to < npp_from) THEN -- участок без перехлеста через 0
                    RETURN (npp_to <= to_.npp_from) -- участок вначале попадает
                        OR (npp_from >= to_.npp_to); -- участок вконце попадает
                ELSE -- с перехлестом участок через 0
                    RETURN true;
                END IF;
            END IF;
        -- -><-
        ELSIF ((to_.direction = 1) AND (dir = 0)) THEN -- заявка по часовой стрелки , а часть трека против часовой стрелки
            IF (to_.npp_to < to_.npp_from) THEN -- заявка с перехлестом через 0
                IF (npp_to < npp_from) THEN -- участок без перехлеста через 0
                    RETURN (npp_from >= to_.npp_from) -- участок слева попадает
                        OR (npp_to <= to_.npp_to); -- участок справа попадает
                ELSE -- участок с перехлестом через 0
                    RETURN true;
                END IF;
            ELSE -- заявка без перехлеста через 0
                IF (npp_to < npp_from) THEN -- участок без перехлеста через 0
                    RETURN (npp_from >= to_.npp_from AND npp_to <= to_.npp_to); -- участок попадает
                ELSE -- участок с перехлестом через 0
                    RETURN (npp_from >= to_.npp_from) -- участок слева попадает
                        OR (npp_to <= to_.npp_to); -- участок справа попадает
                END IF;
            END IF;
        -- <-->
        ELSIF ((to_.direction = 0) AND (dir = 1)) THEN -- заявка против часовой стрелки , а часть трека по часовой стрелки
            IF (to_.npp_to < to_.npp_from) THEN -- заявка без перехлеста через 0
                IF (npp_to < npp_from) THEN -- участок c перехлестом через 0
                    RETURN (npp_to >= to_.npp_to) -- участок слева попадает
                        OR (npp_from <= to_.npp_from); -- участок справа попадает
                ELSE -- участок без перехлеста через 0
                    RETURN (npp_from <= to_.npp_from AND npp_to >= to_.npp_from) -- участок справа попадает
                        OR (npp_from >= to_.npp_to AND npp_to <= to_.npp_from) -- участок целиком попадает
                        OR (npp_to >= to_.npp_to AND npp_from <= to_.npp_to); -- участок справа попадает
                END IF;
            ELSE -- заявка c перехлестом через 0
                IF (npp_to < npp_from) THEN -- участок c перехлестом через 0
                    RETURN true;
                ELSE -- участок без перехлеста через 0
                    RETURN (npp_from <= to_.npp_from) -- участок слева попадает
                        OR (npp_to >= to_.npp_to); -- участок справа попадает
                END IF;
            END IF;
        END IF;
    END LOOP;
    RETURN false; -- сюда дойти не должно вроде как
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_track_part_between(bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_track_part_between(bigint, bigint, bigint, bigint)
    IS 'является ли указанная заявка на блокировку между указанными треками по заданному направлению?';


CREATE OR REPLACE FUNCTION obj_rpart.is_track_locked(
    robot_id_ in bigint,
    npp_d bigint,
    dir bigint,
    maybe_locked_ bigint default 0,
    check_ask_1_robot bigint default 0)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    r RECORD;
    rp RECORD;
    cnpp BIGINT;
    ll BIGINT;
    dnppsorb BIGINT;
    is_dest_npp_reached BOOLEAN;
BEGIN
    is_dest_npp_reached := false;
    FOR r IN (SELECT * FROM robot WHERE id = robot_id_) LOOP
        CALL obj_rpart.log(r.repository_part_id, ' is_track_locked robot_id_=' || robot_id_ || ' npp_d=' || npp_d || ' dir=' || dir);
        FOR rp IN (
            SELECT repository_type, id, max_npp, spacing_of_robots sorb, num_of_robots
                FROM repository_part rp
                WHERE id=r.repository_part_id
        ) LOOP
            IF (check_ask_1_robot = 0) AND (rp.num_of_robots = 1) THEN -- один робот - всегда все свободно
                RETURN 1;
            END IF;
            cnpp := r.current_track_npp;
            RAISE NOTICE '  cnpp=%', cnpp;
            SELECT locked_by_robot_id INTO ll FROM track WHERE repository_part_id = rp.id AND npp = cnpp;
            IF (cnpp = npp_d) AND (ll = robot_id_) /*or maybe_locked_=1 and ll=0)*/ THEN
                RETURN 1; -- там же и стоим
            END IF;
            -- считаем максимум сколько нужно хапануть
            dnppsorb := obj_rpart.add_track_npp(rp.id, npp_d,rp.sorb, dir);
            IF (obj_rpart.is_track_npp_ban_move_to(rp.id, npp_d) = 1) THEN
                dnppsorb := obj_rpart.add_track_npp(rp.id, dnppsorb, 1, dir);
            END IF;
            LOOP
                IF cnpp=npp_d THEN
                    is_dest_npp_reached:=true;
                END IF;
                EXIT WHEN cnpp=dnppsorb AND is_dest_npp_reached;
                IF (dir = 1) THEN -- по часовой
                    IF (rp.repository_type = 1) THEN -- для кольцевого склада
                        IF (cnpp = rp.max_npp) THEN
                            cnpp := 0;
                        ELSE
                            cnpp := cnpp + 1;
                        END IF;
                    ELSE -- для линейного
                        IF (cnpp < rp.max_npp) THEN
                            cnpp := cnpp + 1;
                        ELSE
                            EXIT; -- выход из цикла
                        END IF;
                    END IF;
                ELSE -- против
                    IF (rp.repository_type = 1) THEN -- для кольцевого склада
                        IF (cnpp = 0) THEN
                            cnpp := rp.max_npp;
                        ELSE
                            cnpp := cnpp - 1;
                        END IF;
                    ELSE -- для линейного
                        IF (cnpp > 0) THEN
                            cnpp := cnpp - 1;
                        ELSE
                            EXIT; -- выход из цикла
                        END IF;
                    END IF;
                END IF;
                SELECT locked_by_robot_id INTO ll FROM track WHERE repository_part_id = rp.id AND npp = cnpp;
                IF (ll <> r.id) AND (maybe_locked_ = 0) THEN -- ошибка
                    RETURN 0; -- путь не готов - ОШИБКА!!!
                ELSIF (ll NOT IN (r.id, 0)) AND (maybe_locked_ = 1) THEN
                    RETURN 0; -- путь не готов - ОШИБКА!!!
                END IF;
            END LOOP;
        END LOOP;
    END LOOP;
    RETURN 1; -- все проверено, мин нет
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_track_locked(bigint, bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_track_locked(bigint, bigint, bigint, bigint, bigint)
    IS 'интеллектуальная функция определения - заблокирован ли трек? (учитывает шлейф робота)';


CREATE OR REPLACE FUNCTION obj_rpart.form_track_order(
    rid_ bigint,
    npp_from_ bigint,
    npp_to_ bigint,
    dir_ bigint,
    robot_stop_id_ bigint)
    RETURNS boolean
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    r RECORD;
    tt RECORD;
    cnt BIGINT;
    nor_ BIGINT;
BEGIN
    FOR r IN (SELECT * FROM robot WHERE id = rid_) LOOP
        CALL obj_rpart.log(r.repository_part_id, 'Пришла заявка на трек от робота ' || rid_
            || ' NPP_FROM=' || NPP_FROM_
            || ' NPP_TO=' || NPP_TO_
            || ' dir=' || dir_
            || ' robot_stop_id_=' || robot_stop_id_);
        -- первым делом проверяем, а нет ли уже заявки от этого же робота
        FOR tt IN (SELECT * FROM track_order WHERE repository_part_id = r.repository_part_id AND rid_ = robot_id) LOOP
            CALL obj_rpart.log(r.repository_part_id, 'ERROR - попытка заявки, когда уже есть заявка от робота ' || rid_
                || ' NPP_FROM=' || tt.NPP_FROM
                || ' NPP_TO=' || tt.NPP_TO
                || ' DIRECTION=' || tt.DIRECTION
                || ' robot_stop_id=' || tt.robot_stop_id);
            RETURN true;
        END LOOP;
        SELECT count(*) INTO cnt FROM track_order WHERE repository_part_id = r.repository_part_id;
        SELECT num_of_robots INTO nor_ FROM repository_part WHERE id = r.repository_part_id;
        IF (cnt >= nor_ - 1) THEN
            CALL obj_rpart.log(r.repository_part_id, 'ERROR - слишком много заявок по подскладу, отбой!');
            RETURN false;
        END IF;
        FOR tt IN (SELECT * FROM track_order WHERE repository_part_id = r.repository_part_id) LOOP
            IF (robot_stop_id_ = tt.robot_stop_id) THEN
                CALL obj_rpart.log(r.repository_part_id, 'ERROR - попытка второй заявки на одного мешающего робота');
                RETURN false;
            END IF;
            IF (robot_stop_id_ = tt.robot_id) THEN
                CALL obj_rpart.log(r.repository_part_id, 'ERROR - попытка ранее инициировавшего заявку робота выставить мешающим');
                RETURN false;
            END IF;
            IF (tt.direction <> dir_) AND obj_rpart.is_track_part_between(tt.id, npp_from_, npp_to_, dir_) THEN
                CALL obj_rpart.log(r.repository_part_id, 'ERROR - попытка добавить встречную мешающую заявку');
                RETURN false;
            END IF;
        END LOOP;
        INSERT INTO track_order(robot_id, repository_part_id, npp_from, npp_to, direction, robot_stop_id)
            VALUES (rid_, r.repository_part_id, npp_from_, npp_to_, dir_, robot_stop_id_);
    END LOOP;
    RETURN true;
END;
$BODY$;
ALTER FUNCTION obj_rpart.form_track_order(bigint, bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.form_track_order(bigint, bigint, bigint, bigint, bigint)
    IS 'неинтеллектуальный запрос формирования заявки на блокировку трека';


CREATE OR REPLACE FUNCTION obj_rpart.is_poss_ass_new_unload_cell(
    old_cell_id bigint,
    robot_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    cellrec cell;
    dir BIGINT;
BEGIN
    CALL obj_rpart.try_assign_new_unload_cell(old_cell_id, robot_id_, cellrec, dir);
    IF cellrec.id IS null THEN
        RETURN 0;
    ELSE
        RETURN 1;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_poss_ass_new_unload_cell(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_poss_ass_new_unload_cell(bigint, bigint)
    IS 'можно ли назначить новую ячейку для выгрузки контейнера?';


CREATE OR REPLACE PROCEDURE obj_rpart.try_assign_new_unload_cell(
    old_cell_id bigint,
    robot_id_ bigint,
    INOUT cellrec cell,
    INOUT dir bigint)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    old_cell cell;
    appr_cell cell;
    cnt BIGINT;
    rpt BIGINT;
    cnpp BIGINT;
    cnpp_sorb BIGINT;
    max_npp_ BIGINT;
    delta1 BIGINT;
    delta0 BIGINT;
    sorb BIGINT;
    rp_id_ BIGINT;
    was_found BIGINT;
BEGIN
    SELECT * INTO old_cell FROM cell WHERE id = old_cell_id;
    -- если ничего не нашли - Null возвращаем
    cellrec.id := null;
    cellrec.sname := null;
    dir := -1;
    -- а вдруг в той же секции есть местечко
    FOR appr_cell IN (
        SELECT *
            FROM cell
            WHERE repository_part_id = old_cell.repository_part_id
                AND cell_size = old_cell.cell_size
                AND is_full = 0
                AND (
                    (hi_level_type = 1 AND zone_id <> 0) OR hi_level_type = 10
                )
                AND is_error = 0
                AND service.is_cell_cmd_locked(id) = 0
                AND id <> old_cell_id
                AND track_npp = old_cell.track_npp
    ) LOOP
        CALL obj_rpart.log(
            appr_cell.repository_part_id,
            'try_assign_new_unload_cell - нашли в текущей секции ' || appr_cell.sname
        );
        cellrec := appr_cell;
        dir := 1;
        RETURN;
    END LOOP;
    -- раз дошли до сюда, значит нет свободного места в текущей секции
    CALL obj_rpart.log(
        old_cell.repository_part_id,
        'try_assign_new_unload_cell - нет свободного места в текущей секции'
    );
    SELECT max_npp, spacing_of_robots, id, repository_type
        INTO max_npp_, sorb, rp_id_, rpt
        FROM repository_part
        WHERE id = (
            SELECT repository_part_id
                FROM robot
                WHERE id = robot_id_
        );
    delta1 := 0;
    delta0 := 0;
    FOR dir_f IN 0..1 LOOP
        was_found := 0;
        cnpp := old_cell.track_npp;
        cnpp_sorb := obj_rpart.inc_spacing_of_robots(cnpp, dir_f, sorb, rp_id_, 0, max_npp_);
        LOOP -- цикл по направлению
            IF (dir_f = 0) THEN -- против часовой
                IF (rpt = 0) THEN -- линейный
                    EXIT WHEN cnpp = 0;
                END IF;
                delta0 := delta0 + 1;
            ELSE -- по часовой
                IF (rpt = 0) THEN -- линейный
                    EXIT WHEN cnpp = max_npp_;
                END IF;
                delta1 := delta1 + 1;
            END IF;
            cnpp_sorb := obj_rpart.inc_spacing_of_robots(cnpp_sorb, dir_f, 1, rp_id_, 0, max_npp_);
            cnpp      := obj_rpart.inc_spacing_of_robots(cnpp,      dir_f, 1, rp_id_, 0, max_npp_);
            SELECT count(*) INTO cnt
                FROM track
                WHERE repository_part_id = rp_id_
                    AND npp = cnpp_sorb
                    AND locked_by_robot_id IN (0,robot_id_);
            IF (cnt > 0) THEN -- трэк свободен
                FOR appr_cell IN (
                    SELECT *
                        FROM cell
                        WHERE repository_part_id = rp_id_
                            AND track_npp = cnpp
                            AND is_full = 0
                            AND cell_size <= old_cell.cell_size
                            AND (
                                (hi_level_type = 1 AND zone_id <> 0) OR hi_level_type = 10
                            )
                            AND id <> old_cell_id
                            AND is_error = 0
                            AND service.is_cell_cmd_locked(id) = 0
                        ORDER BY abs(old_cell.cell_size - cell_size)
                ) LOOP
                    -- ура, есть ячейка
                    CALL obj_rpart.log(
                        old_cell.repository_part_id,
                        'try_assign_new_unload_cell - нашли подходящую ячейку ' || appr_cell.sname || ' dir=' || dir_f
                    );
                    was_found := 1;
                    IF (cellrec.id IS null) THEN -- раньше не было - пишем
                        cellrec := appr_cell;
                        dir := dir_f;
                    ELSE --уже было - на 0-вом шаге
                        IF (delta1 < delta0) AND (delta1 <> 0) AND (delta0 <> 0) THEN
                            cellrec := appr_cell;
                            dir := dir_f;
                        END IF;
                    END IF;
                    EXIT;
                END LOOP;
                EXIT WHEN was_found = 1;
            ELSE
                EXIT; -- дальше блокировано - вываливаемся
            END IF;
        END LOOP; -- по направлению одному
    END LOOP; -- по направлениям
END;
$BODY$;
COMMENT ON PROCEDURE obj_rpart.try_assign_new_unload_cell(bigint, bigint, cell, bigint)
    IS 'пытаемся назначить новую ячейку выгрузки вместо старой';


CREATE OR REPLACE FUNCTION obj_rpart.is_exists_cell_type(
    rp_id_ bigint,
    ct_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BOOLEAN;
BEGIN
    SELECT exists(
        SELECT * FROM cell
        WHERE repository_part_id = rp_id_
        AND hi_level_type = ct_
        AND is_error = 0
    ) INTO res;
    IF res THEN
        RETURN 1;
    END IF;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_exists_cell_type(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_exists_cell_type(bigint, bigint)
    IS 'Checks if there are any cells of specified type that have no erorrs.
есть ли неошибочные ячейки указанного подтипа на складе?';


CREATE OR REPLACE FUNCTION obj_rpart.is_cell_locked_by_repaire(
    cell_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    onp BIGINT;
    cnp BIGINT;
    cc cell;
    rr robot;
    tla track;
    rp RECORD;
BEGIN
    FOR cc IN (
        SELECT *
            FROM cell
            WHERE id = cell_id_
    ) LOOP
        FOR rr IN (
            SELECT *
                FROM robot
                WHERE repository_part_id = cc.repository_part_id
                    AND state = 6
        ) LOOP
            FOR tla IN (
                SELECT *
                    FROM track
                    WHERE repository_part_id = rr.repository_part_id
                        AND locked_by_robot_id = rr.id
                        AND npp = cc.track_npp
            ) LOOP
                RETURN 1;
            END LOOP;
            FOR rp IN (
                SELECT id, spacing_of_robots sor, max_npp
                    FROM repository_part
                    WHERE id = cc.repository_part_id
            ) LOOP
                --cnp:=rr.current_track_npp;
                -- по часовой стрелке
                onp := rr.current_track_npp;
                FOR dir IN 0..1 LOOP
                    FOR delt IN 1..rp.sor*2 LOOP
                        cnp := obj_rpart.inc_spacing_of_robots(rr.current_track_npp, dir,delt, rp.id, 0, rp.max_npp);
                        IF (cnp <> onp) THEN -- чтоб не застряли на туда, куда нельзя пройти
                            IF (cnp = cc.track_npp) THEN
                                RETURN 1;
                            END IF;
                        END IF;
                        onp := cnp;
                    END LOOP;
                END LOOP;
            END LOOP;
        END LOOP;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_cell_locked_by_repaire(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_cell_locked_by_repaire(bigint)
    IS 'заблокирована ли ячейка роботом в состоянии починки?';


CREATE OR REPLACE PROCEDURE obj_rpart.change_cmd_rp_goal(
    cmd_rp_id_ bigint,
    new_cell_dest_id bigint)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    old_rp command_rp;
    cc RECORD;
    crp command_rp;
    cmd command;
    crprec command_rp;
BEGIN
    SELECT * INTO old_rp FROM command_rp WHERE id = cmd_rp_id_;
    FOR cc IN (
        SELECT c.sname, s.track_id, t.npp, hi_level_type
            FROM cell c
            INNER JOIN shelving s
                ON c.shelving_id = s.id
            INNER JOIN track t
                ON s.track_id = t.id
            WHERE c.id = new_cell_dest_id
    ) LOOP
        UPDATE cell_cmd_lock
            SET cell_id = new_cell_dest_id, sname = cc.sname
            WHERE cell_id = old_rp.cell_dest_id
                AND cmd_id = old_rp.command_id;
        UPDATE command_rp
            SET cell_dest_id = new_cell_dest_id,
                cell_dest_sname = cc.sname,
                track_dest_id = cc.track_id,
                npp_dest = cc.npp
            WHERE id = cmd_rp_id_;
        IF (cc.hi_level_type = 1) THEN -- выгружаем на хранение
            FOR crp IN (
                SELECT * FROM command_rp WHERE id = cmd_rp_id_
            ) LOOP
                UPDATE command
                    SET cell_dest_sname=cc.sname,
                        cell_dest_id=new_cell_dest_id,
                        npp_dest=cc.npp,
                        track_dest_id=cc.track_id
                    WHERE id=crp.command_id;
                -- а теперь command_gas правим
                FOR cmd IN (
                    SELECT * FROM command WHERE id = crp.command_id
                ) LOOP
                    UPDATE command_gas
                        SET cell_out_name = cc.sname
                        WHERE command_type_id IN (11,18)
                            AND id = cmd.command_gas_id;
                END LOOP;
            END LOOP;
        ELSE -- особые действия при выгрузке на временное хранение в транзитный склад
            FOR crprec IN (
                SELECT * FROM command_rp WHERE id = cmd_rp_id_
            ) LOOP
                UPDATE command_rp
                    SET cell_src_id = new_cell_dest_id,
                        cell_src_sname = cc.sname,
                        track_src_id = cc.track_id,
                        npp_src = cc.npp
                    WHERE id <> cmd_rp_id_
                        AND command_id = crprec.command_id
                        AND rp_id = crprec.rp_id
                        AND state = 1;
            END LOOP;
        END IF;
    END LOOP;
END;
$BODY$;
COMMENT ON PROCEDURE obj_rpart.change_cmd_rp_goal(bigint, bigint)
    IS 'назначаем новую целевую ячейки команде перемещения контейнера';


CREATE OR REPLACE FUNCTION obj_rpart.get_transit_1rp_cell(
    rpid_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    ncl RECORD;
BEGIN
    FOR ncl IN (
        SELECT * FROM cell
            WHERE repository_part_id = rpid_
            AND is_full = 0
            AND coalesce(blocked_by_ci_id, 0) = 0
            AND service.is_cell_over_locked(id) = 0
            AND coalesce(is_error, 0) = 0
            AND hi_level_type = obj_ask."CELL_TYPE_TRANSIT_1RP"()
    ) LOOP
        RETURN ncl.id;
    END LOOP;
    RETURN 0;
END;
$BODY$;
ALTER FUNCTION obj_rpart.get_transit_1rp_cell(bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.get_transit_1rp_cell(bigint)
    IS 'Returns available transit cell inside specified track
получить id свободной транзитной ячейки для передач внутри одного огурца';


CREATE OR REPLACE PROCEDURE obj_rpart.track_lock_prim(
    rpid_ bigint,
    rid_ bigint)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    UPDATE track
        SET locked_by_robot_id = rid_
        WHERE repository_part_id = rpid_
        AND npp IN (
            SELECT npp FROM tmp_track_lock WHERE rp_id = rpid_
        );
    DELETE FROM tmp_track_lock WHERE rp_id = rpid_;
END;
$BODY$;
COMMENT ON PROCEDURE obj_rpart.track_lock_prim(bigint, bigint)
    IS 'функция примитивной блокировки трека';


CREATE OR REPLACE FUNCTION obj_rpart.has_free_cell(
    csize bigint,
    rp_id_ bigint DEFAULT 0)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    res BOOLEAN;
BEGIN
    SELECT exists(
        SELECT * FROM cell
            WHERE is_full=0
                AND coalesce(blocked_by_ci_id, 0) = 0
                AND service.is_cell_over_locked(cell.id) = 0
                AND coalesce(is_error, 0) = 0
                AND hi_level_type = 1
                AND zone_id <> 0
                AND (repository_part_id = rp_id_ or coalesce(rp_id_, 0) = 0)
                AND cell_size <= csize
    ) INTO res;
    RETURN res::INT::BIGINT;
END;
$BODY$;
ALTER FUNCTION obj_rpart.has_free_cell(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.has_free_cell(bigint, bigint)
    IS 'есть ли свободное место?';


CREATE OR REPLACE FUNCTION obj_rpart.has_free_cell_by_cnt(
    cntid bigint,
    rp_id_ bigint DEFAULT 0)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    ct BIGINT;
BEGIN
    SELECT type INTO ct
        FROM container
        WHERE id = cntid;
    IF ct IS null THEN
        RETURN 0;
    END IF;
    RETURN obj_rpart.has_free_cell(ct, rp_id_);
END;
$BODY$;
ALTER FUNCTION obj_rpart.has_free_cell_by_cnt(bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.has_free_cell_by_cnt(bigint, bigint)
    IS 'есть ли свободное место для контейнера заданного размера?';


CREATE OR REPLACE FUNCTION obj_rpart.try_track_lock(
    rid_ bigint,
    npp_to_ bigint,
    dir_ bigint,
    ignore_buf_track_order boolean,
    barrier_robot_id out bigint,
    result out bigint)
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    rp_ RECORD;
    to_ RECORD;
    tr RECORD;
    tor RECORD;
    tt RECORD;
    npp_from_sorb__ BIGINT;
    npp_to_sorb__ BIGINT;
    npp_cur__ BIGINT;
    npp_to_was_locked__ BOOLEAN;
    npp_old__ BIGINT;
    npp_tmp__ BIGINT;
    distance__ BIGINT;
    cnt_ BIGINT;
    npp_to_ar BIGINT;
    ft BOOLEAN;
BEGIN
    -- Assume there are no barriers
    barrier_robot_id := 0; -- типа ничего не мешает
    FOR rp_ IN (
        SELECT rp.id, num_of_robots, spacing_of_robots, repository_type, max_npp, r.current_track_npp
            FROM robot r
            INNER JOIN repository_part rp
                ON r.repository_part_id = rp.id
            WHERE r.id = rid_
    ) LOOP
        DELETE FROM tmp_track_lock WHERE rp_id = rp_.id;
        CALL obj_rpart.log(rp_.id, 'Try_Track_Lock robot=' || rid_
            || ' робот находится c_npp=' || rp_.current_track_npp
            || ' npp_to_=' || npp_to_
            || ' dir_=' || dir_);
        IF (obj_rpart.is_track_locked(rid_, npp_to_, dir_, 0, 1) = 1) THEN
            CALL obj_rpart.log(rp_.id,'  уже заблокировано, нет смысла блокировать');
            result := npp_to_;
            RETURN;
        END IF;
        IF (rp_.current_track_npp = npp_to_) THEN
            CALL obj_rpart.log(rp_.id,'  находится робот там же, куда нужно дойти. Бред какой-то');
            result := npp_to_;
            RETURN;
        END IF;
        npp_from_sorb__ := obj_rpart.add_track_npp(rp_.id, rp_.current_track_npp, rp_.spacing_of_robots + 1, dir_);
        npp_to_sorb__ := obj_rpart.add_track_npp(rp_.id, npp_to_, rp_.spacing_of_robots, dir_);
        IF (obj_rpart.is_track_npp_ban_move_to(rp_.id, npp_to_) = 1) THEN
            CALL obj_rpart.log(rp_.id, '  попали на BAN_MOVE_TO, увеличиваем npp_to_sorb__ на 1 в сторону ' || dir_);
            npp_to_sorb__ := obj_rpart.add_track_npp(rp_.id, npp_to_sorb__, 1, dir_);
        END IF;
        npp_cur__ := npp_from_sorb__;
        -- для блокировки around или на 1 секцию
        distance__ := obj_rpart.calc_distance_by_dir(rp_.id, rp_.current_track_npp, npp_to_, dir_);
        npp_to_was_locked__ := (npp_to_ = rp_.current_track_npp) OR (distance__ <= rp_.spacing_of_robots);
        npp_old__ := -1;
        CALL obj_rpart.log(rp_.id, '  npp_from_sorb__=' || npp_from_sorb__ || ' npp_to_sorb__=' || npp_to_sorb__);
        -- а теперь проверяем заявки, если нужно
        IF (NOT ignore_buf_track_order) THEN
            cnt_ := 0;
            FOR to_ IN (SELECT * FROM track_order WHERE repository_part_id = rp_.id ORDER BY id) LOOP
                EXIT WHEN (cnt_ = 0) AND (to_.robot_id = rid_); -- если самая свежая заявка от текущего робота, то ему все пофиг
                IF (to_.robot_id <> rid_) AND (to_.robot_stop_id <> rid_) THEN
                    npp_to_ar := obj_rpart.correct_npp_to_track_order(rid_, to_.robot_id, dir_, npp_to_sorb__);
                    IF (obj_rpart.is_track_locked(rid_, npp_to_, dir_, 0) = 0)
                        AND (
                            obj_rpart.is_track_part_between(rp_.id, npp_from_sorb__, npp_to_ar, dir_)
                            OR obj_rpart.is_track_part_between(rp_.id, npp_from_sorb__, npp_to_, dir_) -- это нужно чтобы избежать перехлеста при блокировки с 44 по 42 по часовой
                        )
                    THEN
                        CALL obj_rpart.log(rp_.id, '  отмена запроса на блокировку трека, т.к. требуемый участок уже в заявке по цепочке');
                        result := npp_old__;
                        RETURN;
                    END IF;
                END IF;
                cnt_ := cnt_ + 1;
            END LOOP;
        END IF;
        LOOP
            --Log(rp.id,'  loop npp_cur__='||npp_cur__);
            FOR tr IN (SELECT * FROM track WHERE repository_part_id = rp_.id AND npp = npp_cur__) LOOP
                IF (tr.locked_by_robot_id = 0) THEN
                    --update track set locked_by_robot_id=rid_ where id=tr.id;
                    INSERT INTO tmp_track_lock(npp, rp_id) VALUES (npp_cur__, rp_.id);
                    -- освобождаем заявку с трека
                    FOR tor IN (
                        SELECT * FROM track_order
                        WHERE robot_id = rid_
                        AND npp_from = npp_cur__
                        AND npp_from <> npp_to
                    ) LOOP
                        npp_tmp__ := obj_rpart.add_track_npp(rp_.id, npp_cur__, 1, obj_rpart.get_another_direction(dir_));
                        CALL obj_rpart.log(rp_.id,'  освободили кусок заявки track_order ' || tor.id
                            || ' робота ' || tor.robot_id
                            || ' на трек с ' || tor.npp_from
                            || ' на трек с  ' || npp_tmp__);
                        UPDATE track_order SET npp_from = npp_tmp__ WHERE robot_id = rid_;
                    END LOOP;
                    -- удаляем всю заявку
                    FOR tor IN (
                        SELECT * FROM track_order
                        WHERE robot_id = rid_
                            AND npp_from = npp_cur__
                            AND npp_from = npp_to
                    ) LOOP
                        CALL obj_rpart.log(rp_.id, '  удалили заявку track_order ' || tor.id
                            || ' робота ' || tor.robot_id
                            || ' на трек с ' || tor.npp_from
                            || ' по ' || tor.npp_to
                            || ' робот мешал ' || tor.robot_stop_id);
                        DELETE FROM track_order WHERE robot_id = rid_;
                    END LOOP;
                ELSIF (tr.locked_by_robot_id <> rid_) THEN
                    barrier_robot_id := tr.locked_by_robot_id;
                    IF (npp_old__ < 0) THEN
                        CALL obj_rpart.log(rp_.id, '  ERROR - заблокировано другим роботом');
                        ft := obj_rpart.form_track_order(rid_, npp_from_sorb__, npp_to_sorb__, dir_, tr.locked_by_robot_id);
                        IF (NOT ft) AND (NOT ignore_buf_track_order) THEN
                            result := -1;
                            RETURN;
                        END IF;
                        CALL obj_rpart.track_lock_prim(rp_.id, rid_);
                        result := npp_old__;
                        RETURN;
                    ELSE
                        ft := obj_rpart.form_track_order(rid_, tr.npp, npp_to_sorb__, dir_, tr.locked_by_robot_id);
                        IF (NOT ft) AND (NOT ignore_buf_track_order) THEN
                            result := -1;
                            RETURN;
                        END IF;
                        CALL obj_rpart.track_lock_prim(rp_.id, rid_);
                        npp_old__ := obj_rpart.add_track_npp(rp_.id, npp_old__, rp_.spacing_of_robots, obj_rpart.get_another_direction(dir_));
                        result := npp_old__;
                        RETURN;
                    END IF;
                END IF;
            END LOOP;
            IF (NOT npp_to_was_locked__) AND (npp_cur__ = npp_to_) THEN
                npp_to_was_locked__ := true;
            END IF;
            npp_old__ := npp_cur__;
            EXIT WHEN npp_cur__ = npp_to_sorb__ AND npp_to_was_locked__;
            npp_cur__ := obj_rpart.add_track_npp(rp_.id, npp_cur__, 1, dir_);
            CALL obj_rpart.log(rp_.id, '  tr.npp_cur__=' || npp_cur__);
        END LOOP;
        CALL obj_rpart.track_lock_prim(rp_.id, rid_);
        -- удаляем заявки на трек, если были, раз сюда дошли, то
        FOR tt IN (SELECT * FROM track_order WHERE robot_id = rid_) LOOP
            DELETE FROM track_order WHERE robot_id = rid_;
            CALL obj_rpart.log(rp_.id, '  удалили заявку track_order ' || tt.id
                || ' робота ' || tt.robot_id
                || ' на трек с ' || tt.npp_from
                || ' по ' || tt.npp_to
                || ' робот мешал ' || tt.robot_stop_id);
        END LOOP;
        result := npp_to_;
        RETURN;
    END LOOP;
END;
$BODY$;
ALTER FUNCTION obj_rpart.try_track_lock(bigint, bigint, bigint, boolean, out bigint, out bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.try_track_lock(bigint, bigint, bigint, boolean, out bigint, out bigint)
    IS 'возврщает track_npp, до которого удалось дойти
если не может сдвинуться с места, шлет -1
если не удалось дойти, то шлет заявку на участок пути
здесь задаем № трека без учета ореола (интеллектуальное)';


CREATE OR REPLACE FUNCTION obj_rpart.is_poss_to_lock(
    robot_id_ bigint,
    track_npp_dest bigint,
    direction_ bigint,
    crp_id_ bigint default 0)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    r1 RECORD;
    -- r2 RECORD;
    track_id_dest BIGINT;
    rp_id_ BIGINT;
    sorb BIGINT;
    max_npp_ BIGINT;
    rpt BIGINT;
    nr BIGINT;
    -- anroid BIGINT;
    -- is_in_dest BIGINT;
    cur_track_id BIGINT;
    npp1 BIGINT;
    npp1r BIGINT;
    npp2 BIGINT;
    npp2r BIGINT;
    track_id_dest_pl_sor BIGINT;
    -- track_npp_dest_pl_sor BIGINT;
    tr_npp BIGINT;
    tr_id BIGINT;
    is_loop_exit BIGINT;
    tr_locked_by_robot_id BIGINT;
    ret_track_id BIGINT;
    -- npp_ret BIGINT;
BEGIN
    -- зачитываем нужные значения, инициализируем данные, пишем логи
    SELECT * INTO r1 FROM robot WHERE id = robot_id_;
    SELECT t.id, rp.id, spacing_of_robots, max_npp, repository_type, num_of_robots
        INTO track_id_dest, rp_id_, sorb, max_npp_, rpt, nr
        FROM track t, repository_part rp
        WHERE t.npp = track_npp_dest AND repository_part_id = rp.id AND rp.id = r1.repository_part_id;
    IF (/*rpt=0*/ nr = 1) THEN
        -- для склада с одним роботом
        IF (r1.current_track_npp = track_npp_dest) THEN
            RETURN -1; -- уже тама
        ELSE
            RETURN track_id_dest;
        END IF;
    END IF;
    -- anroid := obj_rpart.get_another_robot_id(robot_id_);
    -- SELECT * INTO r2 FROM robot WHERE id = anroid;
    -- is_in_dest := 0;
    cur_track_id := r1.current_track_id;
    IF (track_id_dest = cur_track_id) THEN
        RETURN 1;
    END IF;

    npp1 := r1.current_track_npp;
    npp1r := obj_rpart.inc_spacing_of_robots(npp1, direction_, sorb, rp_id_); -- убрали +1
    npp2 := track_npp_dest;
    npp2r := obj_rpart.inc_spacing_of_robots(npp2, direction_, sorb, rp_id_);

    track_id_dest_pl_sor := obj_rpart.get_track_id_by_robot_and_npp(robot_id_, npp2r);
    -- track_npp_dest_pl_sor := npp2r;

    tr_npp := npp1r;
    LOOP
        tr_id := obj_rpart.get_track_id_by_robot_and_npp(robot_id_, tr_npp);
        SELECT locked_by_robot_id INTO tr_locked_by_robot_id FROM track WHERE id=tr_id;
        IF (coalesce(tr_locked_by_robot_id, 0) = 0) then
            --update track set locked_by_robot_id=r1.id where id=tr_id;
            ret_track_id := tr_id;
            -- npp_ret := tr_npp;
        -- заблокировано кем то иным
        ELSIF (coalesce(tr_locked_by_robot_id, 0) <> r1.id) THEN
            RETURN 0;
        ELSE -- этим же роботом и заблокировано
            ret_track_id := tr_id;
            -- npp_ret := tr_npp;
        END IF;
        CALL obj_rpart.get_next_npp(rpt, max_npp_, tr_npp, npp2r, direction_, tr_npp, is_loop_exit);
        EXIT WHEN is_loop_exit = 1;
    END LOOP;

    IF (ret_track_id = track_id_dest_pl_sor) THEN
        -- добрались до конечного трека с учетом расстояния между роботами
        RETURN 1;
    ELSE -- не дошли до конечного трека
        RETURN 0;
    END IF;
END;
$BODY$;
ALTER FUNCTION obj_rpart.is_poss_to_lock(bigint, bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.is_poss_to_lock(bigint, bigint, bigint, bigint)
    IS 'определяет, возможно ли заблокировать путь';

CREATE OR REPLACE PROCEDURE obj_rpart.container_change_placement(
    bc_ text,
    rp_id_ bigint,
    cell_id_ bigint)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    cc container;
BEGIN
    FOR cc IN (
        SELECT *
            FROM container
            WHERE barcode = bc_
    ) LOOP
        IF coalesce(cc.cell_id, 0) = coalesce(cell_id_, 0) THEN
            RAISE EXCEPTION 'Контейнер % и так находится в указанной ячейке!', bc_
                USING errcode = 50012;
        END IF;
        UPDATE cell
            SET is_full = 0, container_id = 0
            WHERE id = coalesce(cc.cell_id, 0);
        UPDATE container
            SET cell_id = cell_id_, location = 1
            WHERE id = cc.id;
        UPDATE cell
            SET is_full = 1, container_id = cc.id
            WHERE id = cell_id_;
        CALL service.add_shelving_need_to_redraw(
            obj_rpart.get_cell_shelving_id(coalesce(cc.cell_id, 0))
        );
        CALL service.add_shelving_need_to_redraw(
            obj_rpart.get_cell_shelving_id(coalesce(cell_id_, 0))
        );
        RETURN;
    END LOOP;
    RAISE EXCEPTION 'Контейнер % не найден!', bc_
        USING errcode = 50012;
END;
$BODY$;
COMMENT ON PROCEDURE obj_rpart.container_change_placement(text, bigint, bigint)
    IS 'назначить новое место реального расположения контейнера';

CREATE OR REPLACE FUNCTION obj_rpart.inc_npp(
    cur_npp bigint,
    dir bigint,
    rp_id_ bigint)
    RETURNS bigint
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    next_npp BIGINT;
    -- rp_rec_min_npp BIGINT;
    rp_rec_max_npp BIGINT;
BEGIN
    SELECT max(npp)
        INTO rp_rec_max_npp
        FROM track
        WHERE repository_part_id = rp_id_;
    IF (dir = 1) THEN -- по часовой
        IF (cur_npp < rp_rec_max_npp) THEN
            next_npp := cur_npp + 1;
        ELSIF (cur_npp = rp_rec_max_npp) THEN
            next_npp := 0;
        -- ELSE
            --if emu_log_level>=1 then emu_log('  inp: Error cur_npp='||cur_npp); end if;
            --null;
        END IF;
    ELSE
        IF (cur_npp > 0) THEN
            next_npp := cur_npp - 1;
        ELSIF (cur_npp = 0) THEN
            next_npp := rp_rec_max_npp;
        -- ELSE
            --if emu_log_level>=1 then emu_log('  inp: Error cur_npp='||cur_npp); end if;
            --null;
        END IF;
    END IF;
    RETURN next_npp;
end;
$BODY$;
ALTER FUNCTION obj_rpart.inc_npp(bigint, bigint, bigint) OWNER TO postgres;
COMMENT ON FUNCTION obj_rpart.inc_npp(bigint, bigint, bigint)
    IS 'увеличивает указанный трек на 1 по направлению';

-- vim: ft=pgsql
